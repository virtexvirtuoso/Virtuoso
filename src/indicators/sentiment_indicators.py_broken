import logging
from typing import Dict, Any, List, Optional, Tuple
import pandas as pd
import numpy as np
from src.utils.error_handling import handle_indicator_error
import time
from src.core.logger import Logger
from .base_indicator import BaseIndicator
from src.core.analysis.indicator_utils import log_score_contributions, log_component_analysis, log_final_score, log_calculation_details
import copy

class SentimentIndicators(BaseIndicator):
    """
    A class to calculate various sentiment indicators based on market data.
    Each indicator provides a score from 1 (most bearish) to 100 (most bullish).
    """
    
    def __init__(self, config: Dict[str, Any], logger: Optional[Logger] = None):
        """Initialize SentimentIndicators.
        
        Components and weights:
        - Funding Rate (15%): Analyzes funding rate trends and volatility
        - Long/Short Ratio (15%): Measures market positioning
        - Liquidations (15%): Tracks forced position closures
        - Volume Sentiment (15%): Analyzes buying/selling volume
        - Market Mood (15%): Overall market mood indicators
        - Risk Score (15%): Measures market risk
        """
        # Set required attributes before calling super().__init__
        self.indicator_type = 'sentiment'
        
        # Default component weights
        default_weights = {
            'funding_rate': 0.2,  # Increased to absorb funding_rate_volatility
            'long_short_ratio': 0.2,
            'liquidations': 0.2,  # Maps to 'liquidation_events' in config
            'volume_sentiment': 0.2,
            'market_mood': 0.2,
            'risk': 0.2,  # Maps to 'risk_score' in config
        }
        
        # Get sigmoid transformation parameters from config
        sigmoid_config = config.get('analysis', {}).get('indicators', {}).get('sentiment', {}).get('parameters', {}).get('sigmoid_transformation', {})
        self.default_sensitivity = sigmoid_config.get('default_sensitivity', 0.12)
        self.long_short_sensitivity = sigmoid_config.get('long_short_sensitivity', 0.12)
        self.funding_sensitivity = sigmoid_config.get('funding_sensitivity', 0.15)
        self.liquidation_sensitivity = sigmoid_config.get('liquidation_sensitivity', 0.10)
        
        # **** IMPORTANT: Must set component_weights BEFORE calling super().__init__ ****
        
        # Initialize component weights dictionary with defaults
        self.component_weights = default_weights.copy()
        
        # Now call parent class constructor
        super().__init__(config, logger)
        
        # Get sentiment specific config
        sentiment_config = config.get('analysis', {}).get('indicators', {}).get('sentiment', {})
        
        # Try to get weights from confluence section first (most accurate)
        confluence_weights = config.get('confluence', {}).get('weights', {}).get('sub_components', {}).get('sentiment', {})
        
        # Map config keys to internal keys
        config_to_internal = {
            'funding_rate': 'funding_rate',
            'long_short_ratio': 'long_short_ratio',
            'liquidation_events': 'liquidations',
            'volume_sentiment': 'volume_sentiment',
            'market_mood': 'market_mood',
            'risk_score': 'risk',
        }
        
        # Override defaults with weights from config
        if confluence_weights:
            # First, handle the funding_rate and funding_rate_volatility special case
            funding_rate_weight = confluence_weights.get('funding_rate', 0.15)
            volatility_weight = confluence_weights.get('funding_rate_volatility', 0.1)
            
            # Combine the weights
            combined_funding_weight = funding_rate_weight + volatility_weight
            self.component_weights['funding_rate'] = combined_funding_weight
            self.logger.debug(f"Combined funding rate weight: {combined_funding_weight} (rate: {funding_rate_weight} + volatility: {volatility_weight})")
            
            # Process other components
            for config_key, internal_key in config_to_internal.items():
                if config_key in confluence_weights and config_key != 'funding_rate':
                    self.component_weights[internal_key] = float(confluence_weights[config_key])
                    self.logger.debug(f"Using weight from config: {config_key} -> {internal_key}: {self.component_weights[internal_key]}")
        
        # Normalize weights to ensure they sum to 1.0
        weight_sum = sum(self.component_weights.values())
        if weight_sum != 0:
            for component in self.component_weights:
                self.component_weights[component] /= weight_sum
            self.logger.debug(f"Normalized weights (sum: {weight_sum}): {self.component_weights}")
        
        # Store the internal funding rate volatility weight (for use in calculation)
        self.funding_volatility_weight = 0.3  # 30% volatility, 70% raw rate
        self.logger.debug(f"Internal funding rate volatility weight: {self.funding_volatility_weight}")
        
        # Initialize parameters
        self.funding_threshold = sentiment_config.get('funding_threshold', 0.01)
        self.liquidation_threshold = sentiment_config.get('liquidation_threshold', 1000000)
        self.sentiment_window = sentiment_config.get('window', 20)
        
        # Initialize tracking variables
        self.sentiment_history = []
        self.last_update = 0
        
        # Cache for missing data
        self._missing_risk_data = False
        
        # Validate weights
        self._validate_weights()
        
        self.logger.info(f"Initialized {self.__class__.__name__} with config: {sentiment_config}")
        
        # Add cache for expensive operations
        self._cache = {
            'missing_risk_data': False,
            'last_funding_rate': None,
            'last_lsr': None,
            'last_calculation_time': 0
        }
        
        # Cache expiration time (10 minutes)
        self.cache_expiration = 10 * 60  # seconds
        
    def _validate_weights(self):
        """Validate that weights sum to 1.0"""
        comp_total = sum(self.component_weights.values())
        if not np.isclose(comp_total, 1.0, rtol=1e-5):
            self.logger.warning(f"Component weights sum to {comp_total}, normalizing")
            self.component_weights = {k: v/comp_total for k, v in self.component_weights.items()}
            self.logger.debug(f"Normalized weights: {self.component_weights}")

    def calculate_long_short_ratio(self, market_data: Dict[str, Any]) -> float:
        """Calculate sentiment score based on long/short ratio."""
        try:
            sentiment_data = market_data.get('sentiment', {})
            long_short_data = sentiment_data.get('long_short_ratio')
            
            self.logger.debug(f"Long/Short raw data: {long_short_data}")
            
            if not long_short_data:
                self.logger.debug("No long/short data available, returning neutral score")
                return 50.0

            # Extract long/short ratio from the data
            if isinstance(long_short_data, dict):
                long_ratio = float(long_short_data.get('long', 0))
                short_ratio = float(long_short_data.get('short', 0))
                self.logger.debug(f"Long ratio: {long_ratio}, Short ratio: {short_ratio}")
                
                if long_ratio == 0 and short_ratio == 0:
                    self.logger.debug("Both ratios are 0, returning neutral score")
                    return 50.0
                    
                total = long_ratio + short_ratio
                long_percentage = (long_ratio / total) if total > 0 else 0.5
            else:
                # If it's a single value, assume it's already a percentage
                long_percentage = float(long_short_data)
                self.logger.debug(f"Direct long percentage: {long_percentage}")
            
            # Convert ratio to score (0.5 ratio = 50 score)
            score = long_percentage * 100
            
            # Bound the score between 0 and 100
            score = max(0, min(100, score))
            
            self.logger.debug(f"Long percentage: {long_percentage:.3f}, Final Score: {score:.2f}")
            return float(score)
            
        except Exception as e:
            self.logger.error(f"Error calculating long/short ratio: {str(e)}")
            return 50.0

    def calculate_funding_rate(self, market_data: Dict[str, Any]) -> float:
        """Calculate funding rate score (redirects to _calculate_funding_score)."""
        # Process sentiment data first
        sentiment = self._process_sentiment_data(market_data)
        # Use the canonical method
        return self._calculate_funding_score(sentiment)

    def calculate_funding_rate_volatility(self, funding_history: Any) -> float:
        """Calculate sentiment score based on funding rate volatility.
        
        Args:
            funding_history: List or dict of historical funding rates
            
        Returns:
            Sentiment score from 0-100
        """
        try:
            # Handle different formats of funding history data
            rates = []
            
            if isinstance(funding_history, list):
                # Handle list format - extract rates from each item
                for item in funding_history:
                    if isinstance(item, dict) and 'rate' in item:
                        rate = item.get('rate')
                        if isinstance(rate, (int, float)):
                            rates.append(float(rate))
                    elif isinstance(item, (int, float)):
                        rates.append(float(item))
            elif isinstance(funding_history, dict):
                # Handle dict format
                if 'rates' in funding_history:
                    # Format: {'rates': [0.001, 0.002, ...]}
                    rates_list = funding_history.get('rates', [])
                    if isinstance(rates_list, list):
                        for r in rates_list:
                            if isinstance(r, (int, float)):
                                rates.append(float(r))
                elif 'history' in funding_history:
                    # Format: {'history': [{rate: 0.001}, {rate: 0.002}, ...]}
                    history_list = funding_history.get('history', [])
                    if isinstance(history_list, list):
                        for item in history_list:
                            if isinstance(item, dict) and 'rate' in item:
                                rate = item.get('rate')
                                if isinstance(rate, (int, float)):
                                    rates.append(float(rate))
                    else:
                        # Iterate through all keys in case it's an object with timestamp keys
                        for key, value in funding_history.items():
                            if isinstance(value, dict) and 'rate' in value:
                                rate = value.get('rate')
                                if isinstance(rate, (int, float)):
                                    rates.append(float(rate))
                            elif isinstance(value, (int, float)):
                                rates.append(float(value))
            
            # If no valid rates found, return default
            if not rates:
                self.logger.warning("No valid funding rates found in history")
                return 50.0
            
            # Calculate volatility (standard deviation)
            rate_array = np.array(rates)
            volatility = float(np.std(rate_array))
            
            # Map volatility to a score
            # Higher volatility = higher risk = lower score
            # Lower volatility = lower risk = higher score
            
            # For reference, typical funding rate volatility in crypto:
            # Very low: < 0.0001 (0.01%)
            # Low: 0.0001-0.0005 (0.01%-0.05%)
            # Medium: 0.0005-0.001 (0.05%-0.1%)
            # High: 0.001-0.002 (0.1%-0.2%)
            # Very high: > 0.002 (>0.2%)
            
            if volatility < 0.0001:
                score = 75.0  # Very stable funding rates - positive
            elif volatility < 0.0005:
                score = 65.0  # Stable funding rates - slightly positive
            elif volatility < 0.001:
                score = 50.0  # Moderate volatility - neutral
            elif volatility < 0.002:
                score = 40.0  # High volatility - slightly negative
            else:
                score = 30.0  # Very high volatility - negative
            
            self.logger.debug(f"Funding rate volatility calculation - Volatility: {volatility:.6f}, Score: {score:.2f}")
            
            return score
            
        except Exception as e:
            self.logger.error(f"Error calculating funding rate volatility score: {str(e)}")
            return 50.0

    def calculate_liquidation_events(self, liquidations_data: Any) -> float:
        """Calculate sentiment score based on liquidation events.
        
        Args:
            liquidations_data: Liquidation data, can be dict or list
            
        Returns:
            Sentiment score from 0-100
        """
        try:
            # Track liquidation volumes in each direction
            long_liquidations = 0.0
            short_liquidations = 0.0
            
            # Get liquidation threshold from config
            liquidation_threshold = 1000000  # Default
            if hasattr(self, 'config') and isinstance(self.config, dict):
                liquidation_threshold = self.config.get('liquidation_threshold', 1000000)
            
            # Handle different formats of liquidation data
            if isinstance(liquidations_data, dict):
                # Format: {'longs': 10.5, 'shorts': 5.2}
                long_liquidations = self._safe_get(liquidations_data, 'longs', self._safe_get(liquidations_data, 'long', 0.0))
                short_liquidations = self._safe_get(liquidations_data, 'shorts', self._safe_get(liquidations_data, 'short', 0.0))
            elif isinstance(liquidations_data, list):
                # Format: List of liquidation events
                for item in liquidations_data:
                    if isinstance(item, dict):
                        # Extract necessary fields
                        side = self._safe_get(item, 'side', '')
                        size = self._safe_get(item, 'size', 0.0)
                        qty = self._safe_get(item, 'qty', self._safe_get(item, 'quantity', size))
                        
                        # Convert to float if necessary
                        if not isinstance(qty, (int, float)):
                            try:
                                qty = float(qty)
                            except (ValueError, TypeError):
                                qty = 0.0
                        
                        # Add to appropriate direction
                        if isinstance(side, str):
                            if side.lower() in ('long', 'buy'):
                                long_liquidations += qty
                            elif side.lower() in ('short', 'sell'):
                                short_liquidations += qty
            
            # Calculate total liquidations
            total_liquidations = long_liquidations + short_liquidations
            
            # If there are no liquidations or not above threshold, return neutral score
            if total_liquidations < liquidation_threshold:
                self.logger.debug(f"Total liquidations ({total_liquidations:.2f}) below threshold ({liquidation_threshold})")
                return 50.0

            # Calculate long liquidation percentage
            if total_liquidations > 0:
                long_percentage = (long_liquidations / total_liquidations) * 100
            else:
                long_percentage = 50.0
            
            # For liquidations, more long liquidations = bearish (lower score)
            # More short liquidations = bullish (higher score)
            # Inverse mapping from percentage to score:
            # 100% long liquidations = 0 score (extremely bearish)
            # 0% long liquidations = 100 score (extremely bullish)
            # 50% both directions = 50 score (neutral)
            
            score = 100 - long_percentage
            
            # Ensure score is within bounds
            score = float(np.clip(score, 0, 100))
            
            self.logger.debug(f"Liquidation calculation - Long: {long_liquidations:.2f}, Short: {short_liquidations:.2f}, Total: {total_liquidations:.2f}")
            self.logger.debug(f"Long liquidation %: {long_percentage:.2f}%, Score: {score:.2f}")
            
            return score
            
        except Exception as e:
            self.logger.error(f"Error calculating liquidation events score: {str(e)}")
            return 50.0

    def calculate_volume_sentiment(self, volume_data: Dict[str, Any]) -> float:
        """Calculate sentiment score based on volume metrics.
        
        Args:
            volume_data: Volume metrics data
            
        Returns:
            Sentiment score from 0-100
        """
        try:
            # Handle case where volume_data might be None or not a dict
            if not isinstance(volume_data, dict):
                self.logger.warning(f"Invalid volume_data format: {type(volume_data)}")
                return 50.0
                
            # Extract buy percentage with different possible formats
            buy_percentage = None
            
            # Format 1: Direct buy_percentage field
            if 'buy_percentage' in volume_data:
                buy_percentage = volume_data['buy_percentage']
            # Format 2: buy/sell volumes
            elif 'buy_volume' in volume_data and 'sell_volume' in volume_data:
                buy_vol = float(volume_data.get('buy_volume', 0))
                sell_vol = float(volume_data.get('sell_volume', 0))
                total_vol = buy_vol + sell_vol
                if total_vol > 0:
                    buy_percentage = (buy_vol / total_vol) * 100
                else:
                    buy_percentage = 50.0  # Default to neutral if no volume
            # Format 3: Nested structure
            elif 'volume' in volume_data:
                nested_vol = volume_data['volume']
                if isinstance(nested_vol, dict):
                    if 'buy_percentage' in nested_vol:
                        buy_percentage = nested_vol['buy_percentage']
                    elif 'buy' in nested_vol and 'sell' in nested_vol:
                        buy_vol = float(nested_vol.get('buy', 0))
                        sell_vol = float(nested_vol.get('sell', 0))
                        total_vol = buy_vol + sell_vol
                        if total_vol > 0:
                            buy_percentage = (buy_vol / total_vol) * 100
            
            # If no valid percentage found, use default
            if buy_percentage is None:
                self.logger.debug(f"No valid buy percentage found in volume data: {volume_data}")
                return 50.0
            
            # Ensure buy_percentage is a float
            try:
                buy_percentage = float(buy_percentage)
            except (ValueError, TypeError):
                self.logger.warning(f"Invalid buy percentage value: {buy_percentage}")
                return 50.0
                
            # Ensure buy percentage is in 0-100 range
            if 0 <= buy_percentage <= 1:
                # Convert from 0-1 to 0-100 scale
                buy_percentage *= 100
                
            # Map directly to sentiment score (linear mapping where buy % = score)
            score = float(np.clip(buy_percentage, 0, 100))
            
            self.logger.debug(f"Volume sentiment calculation - Buy %: {buy_percentage:.2f}%, Score: {score:.2f}")
            
            return score
            
        except Exception as e:
            self.logger.error(f"Error calculating volume sentiment score: {str(e)}")
            return 50.0
            
    def _calculate_funding_score(self, sentiment_data: Dict[str, Any]) -> float:
        """Calculate sentiment score based on funding rate."""
        try:
            # Handle different funding rate data formats
            current_funding = None
            
            # Check if sentiment_data is directly the funding rate
            if isinstance(sentiment_data, (int, float)):
                current_funding = float(sentiment_data)
                self.logger.debug(f"Using direct funding rate value: {current_funding}")
            # If it's a dict with a 'rate' field
            elif isinstance(sentiment_data, dict) and 'rate' in sentiment_data:
                current_funding = float(sentiment_data.get('rate', 0))
                self.logger.debug(f"Using funding rate from dictionary 'rate' field: {current_funding}")
            # If funding_rate is a key in the dictionary
            elif isinstance(sentiment_data, dict) and 'funding_rate' in sentiment_data:
                funding_rate = sentiment_data.get('funding_rate')
                if isinstance(funding_rate, (int, float)):
                    current_funding = float(funding_rate)
                    self.logger.debug(f"Using funding rate from dictionary 'funding_rate' field: {current_funding}")
                elif isinstance(funding_rate, dict) and 'rate' in funding_rate:
                    current_funding = float(funding_rate.get('rate', 0))
                    self.logger.debug(f"Using funding rate from nested dictionary: {current_funding}")
            # Check if it's nested in a 'sentiment' field
            elif isinstance(sentiment_data, dict) and 'sentiment' in sentiment_data:
                nested_data = sentiment_data.get('sentiment', {})
                if isinstance(nested_data, dict) and 'funding_rate' in nested_data:
                    funding_rate = nested_data.get('funding_rate')
                    if isinstance(funding_rate, (int, float)):
                        current_funding = float(funding_rate)
                        self.logger.debug(f"Using funding rate from nested sentiment dictionary: {current_funding}")
                    elif isinstance(funding_rate, dict) and 'rate' in funding_rate:
                        current_funding = float(funding_rate.get('rate', 0))
                        self.logger.debug(f"Using funding rate from deeply nested structure: {current_funding}")
            
            # If no valid funding rate was found
            if current_funding is None:
                self.logger.debug(f"No valid funding rate found in data: {sentiment_data}")
                return 50.0
                
            # Get funding threshold from config
            funding_threshold = self.config.get('funding_threshold', 0.0075)
            
            # For interpretation: Positive funding rate means longs pay shorts
            # Therefore, higher positive funding = bearish (lower score)
            # Higher negative funding = bullish (higher score)
            
            # Cap the funding rate at the threshold
            capped_funding = max(min(current_funding, funding_threshold), -funding_threshold)
            
            # Convert to a score from 0-100 (inverse relationship)
            # -threshold maps to 100, +threshold maps to 0, 0 maps to 50
            normalized_score = 50 - (capped_funding / funding_threshold) * 50
            
            self.logger.debug(f"Funding rate: {current_funding:.6f}, Capped: {capped_funding:.6f}, Score: {normalized_score:.2f}")
            
            return float(normalized_score)
            
        except Exception as e:
            self.logger.error(f"Error calculating funding rate score: {str(e)}")
            return 50.0
            
    def _calculate_lsr_score(self, lsr_data: Any) -> float:
        """Calculate sentiment score based on long-short ratio.
        
        Args:
            lsr_data: Long-short ratio data, can be dict with 'long'/'short' or direct float ratio
            
        Returns:
            Sentiment score from 0-100
        """
        try:
            # Handle different formats
            if isinstance(lsr_data, dict):
                # Extract from format {'long': 0.XX, 'short': 0.XX}
                long_value = self._safe_get(lsr_data, 'long', 0.5)
                short_value = self._safe_get(lsr_data, 'short', 0.5)
            
            # Validate values
            if not isinstance(long_value, (int, float)) or not isinstance(short_value, (int, float)):
                    self.logger.warning(f"Invalid LSR values: long={long_value}, short={short_value}")
                return 50.0
                
                # Calculate long percentage
            total = long_value + short_value
            if total <= 0:
                return 50.0
                
                long_percentage = (long_value / total) * 100
            elif isinstance(lsr_data, (int, float)):
                # Direct ratio provided (long/short)
                ratio = float(lsr_data)
                long_percentage = (ratio / (1 + ratio)) * 100
            else:
                self.logger.warning(f"Unsupported LSR data format: {type(lsr_data)}")
                return 50.0
            
            # Map to sentiment score (linear mapping)
            # 50% long = 50 score (neutral)
            # 100% long = 100 score (extremely bullish)
            # 0% long = 0 score (extremely bearish)
            score = long_percentage
            
            # Ensure the score is within bounds
            score = float(np.clip(score, 0, 100))
            
            self.logger.debug(f"LSR calculation - Long %: {long_percentage:.2f}%, Score: {score:.2f}")
            
            return score
            
        except Exception as e:
            self.logger.error(f"Error calculating LSR score: {str(e)}")
            return 50.0
                
    def _apply_sigmoid_transformation(self, value, sensitivity=None, center=50):
        """
        Apply sigmoid transformation to make values more sensitive around the center.
        
        Args:
            value: Raw value to transform
            sensitivity: Controls the steepness of the curve
            center: Center point of the transformation
            
        Returns:
            Transformed value
        """
        try:
            # Use provided sensitivity or default from config
            sensitivity = sensitivity or self.default_sensitivity
            
            # Normalize around center
            normalized = (value - center) / 50
            
            # Apply sigmoid with sensitivity parameter
            transformed = 1 / (1 + np.exp(-normalized / sensitivity))
            
            # Scale back to original range
            result = transformed * 100
            
            self.logger.debug(f"Sigmoid transformation: input={value:.2f}, sensitivity={sensitivity}, output={result:.2f}")
            
            return float(result)
        except Exception as e:
            self.logger.error(f"Error in sigmoid transformation: {str(e)}")
            return value  # Return original value on error

    def _calculate_market_mood(self, sentiment_data: Dict[str, Any]) -> float:
        """Calculate sentiment score based on overall market mood indicators."""
        try:
            # Extract market mood data - first try direct access
            market_mood = sentiment_data.get('market_mood', {})
            
            # Fallback to nested structure if needed
            if not market_mood and 'sentiment' in sentiment_data:
                market_mood = sentiment_data.get('sentiment', {}).get('market_mood', {})
            
            if not market_mood:
                self.logger.debug("No market mood data available")
                return 50.0

            # Set component weights
            weights = {
                'social_sentiment': 0.25,
                'fear_and_greed': 0.40,  # Increased weight for Fear & Greed as it's most reliable
                'search_trends': 0.15,
                'positive_mentions': 0.20  # Reduced slightly to increase fear_and_greed importance
            }
            
            scores = {}
            
            # Log the raw market mood data for debugging
            self.logger.debug("\n=== Market Mood Calculation ===")
            self.logger.debug(f"Raw market mood data: {market_mood}")
            
            # Calculate social sentiment score (assumed to be on a 0-100 scale)
            if 'social_sentiment' in market_mood:
                social_score = float(market_mood['social_sentiment'])
                scores['social_sentiment'] = np.clip(social_score, 0, 100)
                self.logger.debug(f"Social sentiment: {social_score:.2f}")
                
            # Calculate fear and greed score (0-100 scale)
            # Fear and Greed index is 0-100 where:
            # 0-24: Extreme Fear
            # 25-44: Fear
            # 45-55: Neutral
            # 56-75: Greed
            # 76-100: Extreme Greed
            if 'fear_and_greed' in market_mood:
                try:
                fear_greed = float(market_mood['fear_and_greed'])
                    
                    # Fear & Greed Index interpretation:
                    # - Convert 0-100 scale to sentiment score
                    # - Apply scaling to enhance signal at extremes
                    
                    # Extreme fear (0-24) maps to bearish sentiment (0-40)
                    if fear_greed <= 24:
                        # Linear mapping from [0,24] to [0,40]
                        fear_greed_score = (fear_greed / 24) * 40
                        mood = "Extreme Fear"
                    
                    # Fear (25-44) maps to moderately bearish (41-48)
                    elif fear_greed <= 44:
                        # Linear mapping from [25,44] to [41,48]
                        fear_greed_score = 41 + ((fear_greed - 25) / (44 - 25)) * (48 - 41)
                        mood = "Fear"
                    
                    # Neutral (45-55) maps to neutral sentiment (49-51)
                    elif fear_greed <= 55:
                        # Linear mapping from [45,55] to [49,51]
                        fear_greed_score = 49 + ((fear_greed - 45) / (55 - 45)) * (51 - 49)
                        mood = "Neutral"
                    
                    # Greed (56-75) maps to moderately bullish (52-60)
                    elif fear_greed <= 75:
                        # Linear mapping from [56,75] to [52,60]
                        fear_greed_score = 52 + ((fear_greed - 56) / (75 - 56)) * (60 - 52)
                        mood = "Greed"
                    
                    # Extreme Greed (76-100) maps to bullish (61-100)
                    else:
                        # Linear mapping from [76,100] to [61,100]
                        fear_greed_score = 61 + ((fear_greed - 76) / (100 - 76)) * (100 - 61)
                        mood = "Extreme Greed"
                    
                    scores['fear_and_greed'] = np.clip(fear_greed_score, 0, 100)
                    self.logger.debug(f"Fear & Greed: {fear_greed:.2f} ({mood}) → Score: {fear_greed_score:.2f}")
                except (ValueError, TypeError) as e:
                    self.logger.warning(f"Error processing Fear & Greed Index: {e}")
                    # Default to neutral if we can't convert to float
                    scores['fear_and_greed'] = 50.0
                    self.logger.debug("Using default score for Fear & Greed: 50.0")
                
            # Calculate search trends score (higher search = higher score, assume 0-100)
            if 'search_trends' in market_mood:
                search_score = float(market_mood['search_trends'])
                scores['search_trends'] = np.clip(search_score, 0, 100)
                self.logger.debug(f"Search trends: {search_score:.2f}")
                
            # Calculate positive mentions score
            if 'positive_mentions' in market_mood:
                pos_mentions = float(market_mood['positive_mentions'])
                # Convert to a 0-100 scale (0.5 = 50)
                pos_score = pos_mentions * 100
                scores['positive_mentions'] = np.clip(pos_score, 0, 100)
                self.logger.debug(f"Positive mentions: {pos_mentions:.2f} → Score: {pos_score:.2f}")
                
            # If we have no scores, return neutral
            if not scores:
                return 50.0
                
            # Calculate weighted average
            total_weight = 0
            weighted_sum = 0
            
            for component, score in scores.items():
                weight = weights.get(component, 0)
                weighted_sum += score * weight
                total_weight += weight
                
            if total_weight == 0:
                return 50.0
                
            # Calculate final score
            final_score = weighted_sum / total_weight
            
            # Log detailed calculation
            self.logger.debug(f"Market mood - " + 
                            ", ".join([f"{k}: {v:.2f}" for k, v in scores.items()]) + 
                            f", Final: {final_score:.2f}")
            
            return float(np.clip(final_score, 0, 100))
            
        except Exception as e:
            self.logger.error(f"Error calculating market mood: {str(e)}")
            return 50.0

    async def calculate(self, market_data: Dict[str, Any]) -> Dict[str, Any]:
        """Calculate overall sentiment score based on market data.
        
        Args:
            market_data: Dictionary containing market data
            
        Returns:
            Dictionary containing sentiment analysis results
        """
        try:
            start_time = time.time()
            
            # Ensure we have a sentiment section
            if 'sentiment' not in market_data:
                self.logger.warning("No sentiment data in market_data")
                return self._get_default_result()
                
            # Make a copy to avoid mutating the original
            sentiment_data = copy.deepcopy(market_data.get('sentiment', {}))
            
            # Extra debug logging to verify data structure
            self.logger.debug(f"Working with sentiment data: {sentiment_data}")
            
            # Components we'll process
            component_scores = {}
            
            # Process funding rate
            funding_rate = None
            if 'funding_rate' in sentiment_data:
                if isinstance(sentiment_data['funding_rate'], dict):
                    funding_rate = sentiment_data['funding_rate']
                else:
                    # Convert to proper dictionary format if needed
                    raw_rate = sentiment_data['funding_rate']
                    if isinstance(raw_rate, (int, float)):
                        funding_rate = {'rate': raw_rate}
                        self.logger.debug(f"Converted funding_rate from {type(raw_rate)} to dict: {funding_rate}")
                
                if funding_rate:
                    component_scores['funding_rate'] = self._calculate_funding_score(funding_rate)
                    self.logger.debug(f"Funding Rate Score: {component_scores['funding_rate']:.2f}")
            
            # Process funding history
            if 'funding_history' in sentiment_data:
                funding_history = sentiment_data['funding_history']
                if isinstance(funding_history, dict) or isinstance(funding_history, list):
                    volatility_score = self.calculate_funding_rate_volatility(funding_history)
                    if volatility_score:
                        component_scores['funding_volatility'] = volatility_score
                        self.logger.debug(f"Funding Volatility Score: {volatility_score:.2f}")
            
            # Process long-short ratio
            if 'long_short_ratio' in sentiment_data:
                lsr_data = sentiment_data['long_short_ratio']
                if isinstance(lsr_data, dict) or isinstance(lsr_data, (int, float)):
                    lsr_score = self._calculate_lsr_score(lsr_data)
                    component_scores['long_short_ratio'] = lsr_score
                    self.logger.debug(f"Long-Short Ratio Score: {lsr_score:.2f}")
            
            # Process liquidations
            if 'liquidations' in sentiment_data:
                liquidations_data = sentiment_data['liquidations']
                if isinstance(liquidations_data, dict) or isinstance(liquidations_data, list):
                    liquidations_score = self.calculate_liquidation_events(liquidations_data)
                    component_scores['liquidations'] = liquidations_score
                    self.logger.debug(f"Liquidations Score: {liquidations_score:.2f}")
            
            # Process market mood
            if 'market_mood' in sentiment_data:
                market_mood_data = sentiment_data['market_mood']
                if isinstance(market_mood_data, dict):
                    market_mood_score = self._calculate_market_mood(market_mood_data)
                    component_scores['market_mood'] = market_mood_score
                    self.logger.debug(f"Market Mood Score: {market_mood_score:.2f}")
            
            # Process risk limit if available
            risk_score = 50.0  # Default
            if 'risk_limit' in market_data:
                risk_limit_data = market_data['risk_limit']
                risk_score = self._calculate_risk_score({"risk_limit": risk_limit_data})
                component_scores['risk'] = risk_score
                self.logger.debug(f"Risk Score: {risk_score:.2f}")
            
            # Calculate volume sentiment if available
            if 'volume' in market_data:
                volume_data = market_data['volume']
                volume_score = self.calculate_volume_sentiment(volume_data)
                component_scores['volume_sentiment'] = volume_score
                self.logger.debug(f"Volume Sentiment Score: {volume_score:.2f}")
            
            # Debug log component scores
            self.logger.debug(f"Component scores: {component_scores}")
            
            # Calculate overall score from components using weights
            # Apply weights to each component
            weighted_scores = []
            total_weight = 0.0
            
            for component, score in component_scores.items():
                # Skip if not a valid score
                if not isinstance(score, (int, float)):
                    continue
                
                # Get weight for this component
                weight = self.component_weights.get(component, 0.1)
                
                # Add to weighted scores
                weighted_scores.append((score, weight))
                total_weight += weight
            
            # Calculate overall score
            if not weighted_scores:
                self.logger.warning("No valid component scores to calculate overall sentiment")
                overall_score = 50.0
            else:
                # Normalize weights if needed
                if total_weight != 1.0 and total_weight > 0:
                    weighted_scores = [(score, weight / total_weight) for score, weight in weighted_scores]
                
                # Calculate weighted average
                overall_score = sum(score * weight for score, weight in weighted_scores)
                overall_score = float(np.clip(overall_score, 0, 100))
            
            # Generate interpretation
            if not isinstance(component_scores, dict):
                component_scores = {}  # Ensure it's a dictionary
            interpretation = self._generate_interpretation(component_scores, overall_score)
            signals = self._generate_signals(component_scores, overall_score)
            
            # Calculate confidence level
            confidence = self._calculate_confidence(market_data)
            
            # Calculate the time taken for the calculation
            calc_time = (time.time() - start_time) * 1000  # Convert to milliseconds
            
            # Prepare result dictionary
            result = {
                'score': overall_score,
                'components': component_scores,
                'interpretation': interpretation,
                'signals': signals,
                'confidence': confidence,
                'metadata': {
                    'timestamp': int(time.time() * 1000),
                    'calculation_time': calc_time,
                    'status': 'SUCCESS'
                }
            }
            
            return result
            
        except Exception as e:
            self.logger.error(f"Error calculating sentiment score: {str(e)}")
            return self._get_default_result()

    def _process_sentiment_data(self, market_data: Dict[str, Any]) -> Dict[str, Any]:
        """Process and normalize sentiment data from market_data."""
        # Create a copy of the sentiment data (avoid double nesting)
        sentiment_data = market_data.get('sentiment', {}).copy()
        
        # Add other required fields directly from market_data if not already in sentiment
        for field in ['long_short_ratio', 'liquidations', 'risk_limit']:
            if field in market_data and field not in sentiment_data:
                sentiment_data[field] = market_data[field]
        
        # Handle funding_rate specially since it might be a float
        if 'funding_rate' in market_data and 'funding_rate' not in sentiment_data:
            sentiment_data['funding_rate'] = market_data['funding_rate']
                
        return sentiment_data
        
    def _calculate_liquidation_score(self, sentiment_data: Dict[str, Any]) -> float:
        """Calculate score based on liquidation events."""
        return self.calculate_liquidation_events(sentiment_data)
        
    def _calculate_risk_score(self, sentiment_data: Dict[str, Any]) -> float:
        """Calculate risk score based on risk limits and utilization."""
        try:
            # Try to get risk data from sentiment_data or from a safer source
            risk_data = self._safe_get(sentiment_data, 'risk_limit', {})
            
            # Handle case where risk_data itself isn't a dictionary
            if not isinstance(risk_data, dict):
                self.logger.debug(f"Non-dictionary risk data found: {type(risk_data)}")
                return 50.0
                
            # Extract risk levels
            risk_levels = self._safe_get(risk_data, 'levels', [])
            
            if not risk_levels:
                self.logger.debug("No risk levels available")
                return 50.0
                
            # Extract current utilization
            utilization = self._safe_get(risk_data, 'current_utilization', 0.5)
            
            # Ensure utilization is a valid float
            if not isinstance(utilization, (int, float)):
                try:
                    utilization = float(utilization)
                except (ValueError, TypeError):
                    self.logger.warning(f"Invalid utilization value: {utilization}")
                    utilization = 0.5
            
            # Calculate risk score based on margin requirements and utilization
            # Higher margin requirements = higher risk = lower score
            # Higher utilization = higher risk = lower score
            
            # Extract margin data from first level (lowest risk tier)
            first_level = risk_levels[0] if risk_levels else {}
            
            # Use safe_get to extract values from the first level
            initial_margin = self._safe_get(first_level, 'starting_margin', 0.05)
            maintenance_margin = self._safe_get(first_level, 'maintain_margin', 0.025)
            
            # Normalize values to percentages
            if isinstance(initial_margin, (int, float)) and initial_margin > 0 and initial_margin < 1:
                # Already a percentage (0-1)
                initial_margin_pct = initial_margin * 100
            elif isinstance(initial_margin, (int, float)) and initial_margin >= 1 and initial_margin <= 100:
                # Already a percentage (1-100)
                initial_margin_pct = initial_margin
            else:
                # Default
                initial_margin_pct = 5.0
                
            if isinstance(maintenance_margin, (int, float)) and maintenance_margin > 0 and maintenance_margin < 1:
                # Already a percentage (0-1)
                maintenance_margin_pct = maintenance_margin * 100
            elif isinstance(maintenance_margin, (int, float)) and maintenance_margin >= 1 and maintenance_margin <= 100:
                # Already a percentage (1-100)
                maintenance_margin_pct = maintenance_margin
            else:
                # Default
                maintenance_margin_pct = 2.5
                
            # Convert utilization to percentage
            if utilization > 0 and utilization < 1:
                # Already a percentage (0-1)
                utilization_pct = utilization * 100
            elif utilization >= 1 and utilization <= 100:
                # Already a percentage (1-100)
                utilization_pct = utilization
            else:
                # Default
                utilization_pct = 50.0
                
            # Calculate score components
            # 1. Margin requirements component (lower margins = better)
            margin_score = 100 - (initial_margin_pct * 10)  # 0.5% margin = 95 score, 10% margin = 0 score
            
            # 2. Utilization component (lower utilization = better)
            utilization_score = 100 - utilization_pct  # 0% utilization = 100 score, 100% utilization = 0 score
            
            # Combined score (weighted average)
            combined_score = (margin_score * 0.4) + (utilization_score * 0.6)
            
            # Ensure score is within 0-100 range
            final_score = float(np.clip(combined_score, 0, 100))
            
            self.logger.debug(f"Risk calculation - Initial margin: {initial_margin_pct:.2f}%, Maintenance margin: {maintenance_margin_pct:.2f}%, Utilization: {utilization_pct:.2f}%")
            self.logger.debug(f"Risk components - Margin score: {margin_score:.2f}, Utilization score: {utilization_score:.2f}")
            self.logger.debug(f"Final risk score: {final_score:.2f}")
            
            return final_score
            
        except Exception as e:
            self.logger.error(f"Error calculating risk score: {str(e)}")
            return 50.0

    def _generate_interpretation(self, component_scores: Dict[str, float], overall_score: float) -> Dict[str, Any]:
        """Generate human-readable interpretation of sentiment scores."""
        def get_sentiment_label(score):
            if score < 30:
                return "strongly bearish"
            elif score < 45:
                return "moderately bearish"
            elif score < 55:
                return "neutral"
            elif score < 70:
                return "moderately bullish"
            else:
                return "strongly bullish"
            
        def get_risk_label(score):
            if score < 30:
                return "extremely risky"
            elif score < 45:
                return "moderately risky"
            elif score < 55:
                return "neutral risk"
            elif score < 70:
                return "moderately favorable"
            else:
                return "extremely favorable"

        # Ensure component_scores is a dictionary
        if not isinstance(component_scores, dict):
            self.logger.warning(f"component_scores is not a dictionary: {type(component_scores)}")
            component_scores = {}
                
        # Generate component interpretations
        component_interpretations = {}
        for component, score in component_scores.items():
            if component == 'risk':
                component_interpretations[component] = get_risk_label(score)
            else:
                component_interpretations[component] = get_sentiment_label(score)
                
        # Generate signal direction and strength
        if overall_score < 30:
            signal = "bearish"
            strength = "strong"
        elif overall_score < 45:
            signal = "bearish"
            strength = "moderate"
        elif overall_score < 55:
            signal = "neutral"
            strength = "weak"
        elif overall_score < 70:
            signal = "bullish"
            strength = "moderate"
        else:
            signal = "bullish"
            strength = "strong"
            
        # Determine if risk is favorable
        risk_score = self._safe_get(component_scores, 'risk', 50)
        risk_favorable = risk_score >= 55
        
        # Generate overall summary
        summary = f"Market sentiment is {get_sentiment_label(overall_score)}"
        if risk_favorable:
            summary += f" with favorable risk conditions"
        else:
            summary += f" with unfavorable risk conditions"
            
        return {
            'summary': summary,
            'signal': signal,
            'strength': strength,
            'risk_favorable': risk_favorable,
            'component_interpretations': component_interpretations
        }
        
    def _generate_signals(self, component_scores: Dict[str, float], overall_score: float) -> List[Dict[str, Any]]:
        """Generate trading signals based on sentiment scores."""
            signals = []
        
        # Ensure component_scores is a dictionary
        if not isinstance(component_scores, dict):
            self.logger.warning(f"component_scores is not a dictionary in _generate_signals: {type(component_scores)}")
            component_scores = {}
            
        # Generate overall sentiment signal
        if overall_score < 30:
                signals.append({
                    'signal': 'SELL',
                'strength': 'strong',
                'reason': 'Extremely bearish market sentiment',
                'confidence': 0.8
            })
        elif overall_score < 45:
                signals.append({
                    'signal': 'SELL',
                'strength': 'moderate',
                'reason': 'Moderately bearish market sentiment',
                'confidence': 0.6
            })
        elif overall_score > 70:
                signals.append({
                    'signal': 'BUY',
                'strength': 'strong',
                'reason': 'Extremely bullish market sentiment',
                'confidence': 0.8
            })
        elif overall_score > 55:
                signals.append({
                    'signal': 'BUY',
                'strength': 'moderate',
                'reason': 'Moderately bullish market sentiment',
                'confidence': 0.6
            })
            
        # Add risk-based signal modifier
        risk_score = self._safe_get(component_scores, 'risk', 50)
        if risk_score < 30 and len(signals) > 0:
            signals[0]['confidence'] *= 0.7
            signals[0]['reason'] += ' (high risk environment)'
        elif risk_score > 70 and len(signals) > 0:
            signals[0]['confidence'] *= 1.2
            signals[0]['confidence'] = min(signals[0]['confidence'], 0.9)
            signals[0]['reason'] += ' (favorable risk environment)'
            
        return signals

    def _calculate_confidence(self, market_data: Dict[str, Any]) -> float:
        """Calculate the confidence level in our sentiment calculation.
        
        Based on data quality, completeness, and timeliness.
        
        Args:
            market_data: The market data dictionary
            
        Returns:
            float: Confidence score from 0.0-1.0
        """
        try:
            # Create confidence assessment for each component
            confidence_factors = {
                'long_short_ratio': 0,
                'funding_rate': 0,
                'liquidations': 0,
                'market_mood': 0,
                'risk_limit': 0,
                'volume': 0
            }
            
            # Check long/short ratio
            if 'sentiment' in market_data and 'long_short_ratio' in market_data['sentiment']:
                lsr = market_data['sentiment'].get('long_short_ratio', {})
                if lsr and isinstance(lsr, dict) and 'long' in lsr and 'short' in lsr:
                    confidence_factors['long_short_ratio'] = 1.0
                elif lsr:  # At least some data is present
                    confidence_factors['long_short_ratio'] = 0.5
                    
            # Check funding rate - now handling both float and dict types
            if 'sentiment' in market_data and 'funding_rate' in market_data['sentiment']:
                fr = market_data['sentiment'].get('funding_rate', None)
                if fr is not None:
                    if isinstance(fr, dict) and 'rate' in fr:
                        confidence_factors['funding_rate'] = 1.0
                    elif isinstance(fr, (int, float)):
                        # Direct funding rate as a number is also valid
                        confidence_factors['funding_rate'] = 1.0
                    else:  # Some other format
                        confidence_factors['funding_rate'] = 0.5
                    
            # Check liquidations
            if 'sentiment' in market_data and 'liquidations' in market_data['sentiment']:
                liq = market_data['sentiment'].get('liquidations', [])
                if isinstance(liq, list) and len(liq) > 5:
                    confidence_factors['liquidations'] = 1.0
                elif liq:  # At least some data is present
                    confidence_factors['liquidations'] = 0.5
                    
            # Check market mood
            if 'sentiment' in market_data and 'market_mood' in market_data['sentiment']:
                mood = market_data['sentiment'].get('market_mood', {})
                if mood and isinstance(mood, dict) and len(mood) >= 2:
                    confidence_factors['market_mood'] = 1.0
                elif mood:  # At least some data is present
                    confidence_factors['market_mood'] = 0.5
                    
            # Check risk limit
            if 'risk_limit' in market_data:
                risk = market_data.get('risk_limit', {})
                if risk and isinstance(risk, dict) and 'levels' in risk:
                    confidence_factors['risk_limit'] = 1.0
                elif risk:  # At least some data is present
                    confidence_factors['risk_limit'] = 0.5
                    
            # Check volume data
            if 'volume' in market_data:
                volume = market_data.get('volume', {})
                if volume and isinstance(volume, dict) and 'buy_volume_percent' in volume:
                    confidence_factors['volume'] = 1.0
                elif volume:  # At least some data is present
                    confidence_factors['volume'] = 0.5
                    
            # Calculate overall confidence (weighted average)
            weights = {
                'long_short_ratio': 0.2,
                'funding_rate': 0.2,
                'liquidations': 0.15,
                'market_mood': 0.15,
                'risk_limit': 0.15,
                'volume': 0.15
            }
            
            weighted_sum = sum(confidence_factors[k] * weights[k] for k in confidence_factors)
            total_weight = sum(weights.values())
            
            if total_weight > 0:
                confidence = weighted_sum / total_weight
            else:
                confidence = 0.5  # Default moderate confidence
                
            self.logger.debug(f"Confidence factors: {confidence_factors}")
            self.logger.debug(f"Overall confidence: {confidence:.2f}")
            
            return float(confidence)
            
        except Exception as e:
            self.logger.error(f"Error calculating confidence: {str(e)}")
            return 0.5  # Default moderate confidence on error

    def _calculate_funding_history(self, sentiment_data: Dict[str, Any]) -> float:
        """Calculate sentiment score based on funding rate history."""
        try:
            # Extract funding history data safely
            funding_history = sentiment_data.get('funding_history')
            
            # Handle the case where funding_history might be None or not a list/dict
            if funding_history is None:
                self.logger.debug("No funding history data available")
                return 50.0
            
            # If it's directly a float value, just return it as a score
            if isinstance(funding_history, (int, float)):
                normalized_score = 50 + funding_history * 5000  # Simple adjustment
                return float(np.clip(normalized_score, 0, 100))
                
            # Handle list format with different possible structures
            if isinstance(funding_history, list):
                if not funding_history:  # Empty list
                    self.logger.debug("Empty funding history list")
                    return 50.0
                
                # Try to extract rates from the history
                rates = []
                
                # Handle dictionaries in the list
                if isinstance(funding_history[0], dict):
                    # Try common field names for funding rate
                    for entry in funding_history:
                        rate = None
                        if 'rate' in entry:
                            rate = entry['rate']
                        elif 'fundingRate' in entry:
                            rate = entry['fundingRate']
                        elif 'funding_rate' in entry:
                            rate = entry['funding_rate']
                        
                        if rate is not None:
                            try:
                                rates.append(float(rate))
                            except (ValueError, TypeError):
                                pass
                # Handle direct list of values
                else:
                    for value in funding_history:
                        try:
                            rates.append(float(value))
                        except (ValueError, TypeError):
                            pass
                
                if not rates:
                    self.logger.debug("Could not extract any valid rates from funding history")
                    return 50.0
                
                # Calculate average recent funding rate
                avg_rate = sum(rates[:5]) / min(len(rates), 5)
                
                # Map to score - negative is bullish, positive is bearish
                normalized_score = 50 - (avg_rate * 5000)  # Scale appropriately
                
                return float(np.clip(normalized_score, 0, 100))
            
            # If we get here, the format wasn't recognized
            self.logger.warning(f"Unrecognized funding history format: {type(funding_history)}")
                return 50.0
            
        except Exception as e:
            self.logger.error(f"Error calculating funding history score: {str(e)}")
            return 50.0

    def _safe_get(self, data: Any, key: str, default_value: Any = None) -> Any:
        """Safely get a value from a dictionary, handling cases where data might not be a dictionary.
        
        Args:
            data: The data to extract from (could be a dict, float, or other type)
            key: The key to look for in the dictionary
            default_value: The default value to return if key is not found or data is not a dict
            
        Returns:
            The value if key exists in data, otherwise the default_value
        """
        try:
            if data is None:
                return default_value
            elif isinstance(data, dict):
                return data.get(key, default_value)
            elif hasattr(data, '__getitem__') and hasattr(data, 'get'):
                # For dict-like objects that support get()
                return data.get(key, default_value)
            elif hasattr(data, key) and not callable(getattr(data, key)):
                # For objects with the attribute as a property
                return getattr(data, key)
            else:
                # For primitive types or unsupported structures
                self.logger.debug(f"Cannot safely get '{key}' from {type(data)}")
                return default_value
        except Exception as e:
            self.logger.debug(f"Error safely getting '{key}': {str(e)}")
            return default_value
        
    def _ensure_dict(self, data):
        """Ensure data is a dictionary.
        
        Args:
            data: Data to check
            
        Returns:
            dict: The data if it's a dict, or an empty dict otherwise
        """
        return data if isinstance(data, dict) else {}

    def _ensure_component_defaults(self, component_scores: Dict[str, float]) -> None:
        """Ensure all components have default values if missing."""
        for component in self.component_weights.keys():
            if component not in component_scores:
                component_scores[component] = 50.0  # Default neutral score

    def _get_default_result(self) -> Dict[str, Any]:
        """Return a default result for sentiment calculation."""
        return {
            'score': 50.0,
            'components': {k: 50.0 for k in self.component_weights.keys()},
            'signals': [],
            'metadata': {'error': 'No sentiment data in market_data', 'timestamp': int(time.time() * 1000)},
            'interpretation': {'summary': 'No sentiment data in market_data'}
        }
