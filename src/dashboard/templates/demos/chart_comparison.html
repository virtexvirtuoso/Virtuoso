<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Chart Library Comparison | Virtuoso</title>

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;600;700&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

    <!-- Chart Libraries -->
    <!-- 1. Plotly.js (Full: ~3MB, Basic: ~800KB) -->
    <script src="https://cdn.plot.ly/plotly-basic-2.27.0.min.js"></script>

    <!-- 2. TradingView Lightweight Charts (~45KB) -->
    <script src="https://unpkg.com/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>

    <!-- 3. ApexCharts (~150KB) -->
    <script src="https://cdn.jsdelivr.net/npm/apexcharts@3.45.0/dist/apexcharts.min.js"></script>

    <!-- 4. Chart.js (~60KB) + Date Adapter -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0a0a0a;
            --bg-secondary: #111111;
            --bg-card: #1a1a1a;
            --border-light: #2a2a2a;
            --text-primary: #e0e0e0;
            --text-secondary: #9ca3af;
            --accent-amber: #fbbf24;
            --accent-cyan: #06B6D4;
            --accent-green: #10b981;
            --accent-red: #ef4444;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 16px;
            padding-bottom: 100px;
        }

        .header {
            text-align: center;
            margin-bottom: 24px;
            padding: 20px;
            background: var(--bg-card);
            border-radius: 12px;
            border: 1px solid var(--border-light);
        }

        .header h1 {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 20px;
            color: var(--accent-amber);
            margin-bottom: 8px;
        }

        .header p {
            font-size: 13px;
            color: var(--text-secondary);
        }

        .metrics-bar {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-bottom: 20px;
        }

        .metric {
            background: var(--bg-card);
            border: 1px solid var(--border-light);
            border-radius: 8px;
            padding: 12px 8px;
            text-align: center;
        }

        .metric-label {
            font-size: 9px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .metric-value {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 14px;
            font-weight: 600;
            margin-top: 4px;
        }

        .chart-section {
            background: var(--bg-card);
            border: 1px solid var(--border-light);
            border-radius: 12px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px;
            border-bottom: 1px solid var(--border-light);
        }

        .chart-title {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .chart-title h2 {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 14px;
            font-weight: 600;
        }

        .chart-badge {
            font-size: 10px;
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: 600;
        }

        .badge-size {
            background: rgba(6, 182, 212, 0.2);
            color: var(--accent-cyan);
        }

        .badge-render {
            background: rgba(16, 185, 129, 0.2);
            color: var(--accent-green);
        }

        .chart-stats {
            display: flex;
            gap: 12px;
            font-size: 10px;
            color: var(--text-secondary);
        }

        .chart-container {
            padding: 12px;
            height: 300px;
            position: relative;
        }

        .chart-container canvas,
        .chart-container > div {
            width: 100% !important;
            height: 100% !important;
        }

        .loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 200px;
            color: var(--text-secondary);
        }

        .spinner {
            width: 32px;
            height: 32px;
            border: 3px solid var(--border-light);
            border-top-color: var(--accent-amber);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .legend-container {
            display: flex;
            overflow-x: auto;
            gap: 8px;
            padding: 12px 16px;
            border-top: 1px solid var(--border-light);
            -webkit-overflow-scrolling: touch;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-light);
            border-radius: 6px;
            white-space: nowrap;
            font-size: 11px;
            font-family: 'IBM Plex Mono', monospace;
            cursor: pointer;
            transition: all 0.2s;
        }

        .legend-item:hover {
            border-color: var(--accent-amber);
        }

        .legend-item.highlighted {
            border-color: var(--accent-amber);
            background: rgba(251, 191, 36, 0.1);
        }

        .legend-color {
            width: 12px;
            height: 3px;
            border-radius: 2px;
        }

        .summary-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        .summary-table th,
        .summary-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid var(--border-light);
        }

        .summary-table th {
            background: var(--bg-secondary);
            font-weight: 600;
            color: var(--accent-amber);
        }

        .summary-table tr:last-child td {
            border-bottom: none;
        }

        .verdict {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
        }

        .verdict-best {
            background: rgba(16, 185, 129, 0.2);
            color: var(--accent-green);
        }

        .verdict-good {
            background: rgba(251, 191, 36, 0.2);
            color: var(--accent-amber);
        }

        .verdict-poor {
            background: rgba(239, 68, 68, 0.2);
            color: var(--accent-red);
        }

        .recommendation {
            background: linear-gradient(135deg, rgba(251, 191, 36, 0.1), rgba(6, 182, 212, 0.1));
            border: 1px solid var(--accent-amber);
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
        }

        .recommendation h3 {
            color: var(--accent-amber);
            font-size: 14px;
            margin-bottom: 12px;
        }

        .recommendation p {
            font-size: 13px;
            line-height: 1.6;
            color: var(--text-secondary);
        }

        /* Controls Bar */
        .controls-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: var(--bg-card);
            border: 1px solid var(--border-light);
            border-radius: 12px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 12px;
        }

        .timeframe-selector {
            display: flex;
            gap: 4px;
        }

        .tf-btn {
            padding: 6px 12px;
            font-size: 11px;
            font-family: 'IBM Plex Mono', monospace;
            font-weight: 600;
            background: var(--bg-secondary);
            border: 1px solid var(--border-light);
            border-radius: 6px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
        }

        .tf-btn:hover {
            border-color: var(--accent-amber);
            color: var(--text-primary);
        }

        .tf-btn.tf-active {
            background: rgba(251, 191, 36, 0.15);
            border-color: var(--accent-amber);
            color: var(--accent-amber);
        }

        .refresh-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .refresh-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent-green);
            animation: pulse 2s infinite;
        }

        .refresh-indicator.paused {
            background: var(--text-secondary);
            animation: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        .last-updated {
            font-size: 10px;
            color: var(--accent-amber);
            font-family: 'IBM Plex Mono', monospace;
        }

        .refresh-toggle {
            padding: 4px 10px;
            font-size: 10px;
            font-family: 'IBM Plex Mono', monospace;
            font-weight: 600;
            background: rgba(16, 185, 129, 0.15);
            border: 1px solid var(--accent-green);
            border-radius: 4px;
            color: var(--accent-green);
            cursor: pointer;
            transition: all 0.2s;
        }

        .refresh-toggle.paused {
            background: rgba(156, 163, 175, 0.15);
            border-color: var(--text-secondary);
            color: var(--text-secondary);
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>CHART LIBRARY COMPARISON</h1>
        <p>Same Bybit data rendered with 4 different libraries</p>
    </div>

    <!-- Performance Metrics -->
    <div class="metrics-bar">
        <div class="metric">
            <div class="metric-label">Symbols</div>
            <div class="metric-value" id="symbolCount">--</div>
        </div>
        <div class="metric">
            <div class="metric-label">Data Points</div>
            <div class="metric-value" id="dataPoints">--</div>
        </div>
        <div class="metric">
            <div class="metric-label">Fetch Time</div>
            <div class="metric-value" id="fetchTime">--</div>
        </div>
        <div class="metric">
            <div class="metric-label" id="btcLabel">BTC 4H</div>
            <div class="metric-value" id="btcChange" style="color: var(--accent-amber);">--</div>
        </div>
    </div>

    <!-- Controls Bar -->
    <div class="controls-bar">
        <div class="timeframe-selector">
            <button onclick="setTimeframe(1)" class="tf-btn" data-tf="1">1H</button>
            <button onclick="setTimeframe(4)" class="tf-btn tf-active" data-tf="4">4H</button>
            <button onclick="setTimeframe(8)" class="tf-btn" data-tf="8">8H</button>
            <button onclick="setTimeframe(12)" class="tf-btn" data-tf="12">12H</button>
            <button onclick="setTimeframe(24)" class="tf-btn" data-tf="24">24H</button>
        </div>
        <div class="refresh-controls">
            <span class="refresh-indicator" id="refreshIndicator"></span>
            <span class="last-updated" id="lastUpdated">--:--:--</span>
            <button onclick="toggleAutoRefresh()" class="refresh-toggle" id="refreshToggle">AUTO: ON</button>
        </div>
    </div>

    <!-- 1. Plotly.js -->
    <div class="chart-section">
        <div class="chart-header">
            <div class="chart-title">
                <h2>1. Plotly.js</h2>
                <span class="chart-badge badge-size">~800KB (basic)</span>
            </div>
            <div class="chart-stats">
                <span>Render: <strong id="plotlyRender">--</strong></span>
            </div>
        </div>
        <div class="chart-container" id="plotlyChart">
            <div class="loading">
                <div class="spinner"></div>
                <p style="margin-top: 12px;">Loading...</p>
            </div>
        </div>
        <div class="legend-container" id="plotlyLegend"></div>
    </div>

    <!-- 2. TradingView Lightweight Charts -->
    <div class="chart-section">
        <div class="chart-header">
            <div class="chart-title">
                <h2>2. Lightweight Charts</h2>
                <span class="chart-badge badge-size">~45KB</span>
                <span class="chart-badge badge-render">RECOMMENDED</span>
            </div>
            <div class="chart-stats">
                <span>Render: <strong id="lwcRender">--</strong></span>
            </div>
        </div>
        <div class="chart-container" id="lwcChart">
            <div class="loading">
                <div class="spinner"></div>
                <p style="margin-top: 12px;">Loading...</p>
            </div>
        </div>
        <div class="legend-container" id="lwcLegend"></div>
    </div>

    <!-- 3. ApexCharts -->
    <div class="chart-section">
        <div class="chart-header">
            <div class="chart-title">
                <h2>3. ApexCharts</h2>
                <span class="chart-badge badge-size">~150KB</span>
            </div>
            <div class="chart-stats">
                <span>Render: <strong id="apexRender">--</strong></span>
            </div>
        </div>
        <div class="chart-container" id="apexChart">
            <div class="loading">
                <div class="spinner"></div>
                <p style="margin-top: 12px;">Loading...</p>
            </div>
        </div>
    </div>

    <!-- 4. Chart.js -->
    <div class="chart-section">
        <div class="chart-header">
            <div class="chart-title">
                <h2>4. Chart.js</h2>
                <span class="chart-badge badge-size">~60KB</span>
            </div>
            <div class="chart-stats">
                <span>Render: <strong id="chartjsRender">--</strong></span>
            </div>
        </div>
        <div class="chart-container">
            <canvas id="chartjsChart"></canvas>
        </div>
    </div>

    <!-- Summary Table -->
    <div class="chart-section">
        <div class="chart-header">
            <div class="chart-title">
                <h2>Comparison Summary</h2>
            </div>
        </div>
        <div style="padding: 16px; overflow-x: auto;">
            <table class="summary-table">
                <thead>
                    <tr>
                        <th>Library</th>
                        <th>Size</th>
                        <th>Render</th>
                        <th>Mobile UX</th>
                        <th>Verdict</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Plotly.js</td>
                        <td>~800KB</td>
                        <td id="plotlySummary">--</td>
                        <td>Touch issues</td>
                        <td><span class="verdict verdict-poor">POOR</span></td>
                    </tr>
                    <tr>
                        <td>Lightweight Charts</td>
                        <td>~45KB</td>
                        <td id="lwcSummary">--</td>
                        <td>Excellent</td>
                        <td><span class="verdict verdict-best">BEST</span></td>
                    </tr>
                    <tr>
                        <td>ApexCharts</td>
                        <td>~150KB</td>
                        <td id="apexSummary">--</td>
                        <td>Good</td>
                        <td><span class="verdict verdict-good">GOOD</span></td>
                    </tr>
                    <tr>
                        <td>Chart.js</td>
                        <td>~60KB</td>
                        <td id="chartjsSummary">--</td>
                        <td>Good</td>
                        <td><span class="verdict verdict-good">GOOD</span></td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>

    <!-- Recommendation -->
    <div class="recommendation">
        <h3>Recommendation for Virtuoso Mobile</h3>
        <p>
            <strong>TradingView Lightweight Charts</strong> is the clear winner for mobile financial dashboards.
            It's 17x smaller than Plotly, purpose-built for trading, and has native touch support.
            Consider migrating the Performance tab to Lightweight Charts for optimal mobile experience.
        </p>
    </div>

    <script>
        // =====================================================
        // STATE MANAGEMENT
        // =====================================================

        let currentTimeframe = parseInt(localStorage.getItem('chartComparison_timeframe')) || 4;
        let autoRefreshEnabled = localStorage.getItem('chartComparison_autoRefresh') !== 'false';
        let autoRefreshInterval = null;
        const AUTO_REFRESH_MS = 120000; // 2 minutes

        // =====================================================
        // BYBIT API DATA FETCHING
        // =====================================================

        const BYBIT_SYMBOL_MAP = {
            'PEPE': '1000PEPEUSDT',
            'SHIB': '1000SHIBUSDT',
            'FLOKI': '1000FLOKIUSDT',
            'BONK': '1000BONKUSDT',
            'LUNC': '1000LUNCUSDT',
            'SATS': '1000SATSUSDT'
        };

        const COLOR_PALETTE = [
            '#fbbf24', // Amber (BTC)
            '#10b981', // Green
            '#ef4444', // Red
            '#06B6D4', // Cyan
            '#8b5cf6', // Purple
            '#f97316', // Orange
            '#ec4899', // Pink
            '#14b8a6', // Teal
            '#f59e0b', // Yellow
            '#6366f1', // Indigo
            '#84cc16', // Lime
            '#a855f7', // Violet
            '#22c55e', // Emerald
            '#0ea5e9', // Sky
            '#eab308'  // Gold
        ];

        let chartData = {};
        let performances = [];

        async function fetchBybitTickers() {
            const response = await fetch('https://api.bybit.com/v5/market/tickers?category=linear');
            const data = await response.json();

            if (data.retCode !== 0) throw new Error('Bybit API error');

            return data.result.list
                .filter(t => t.symbol.endsWith('USDT'))
                .map(t => ({
                    symbol: t.symbol,
                    normalized: normalizeSymbol(t.symbol),
                    volume: parseFloat(t.turnover24h) || 0,
                    price: parseFloat(t.lastPrice) || 0,
                    change24h: parseFloat(t.price24hPcnt) * 100 || 0
                }))
                .sort((a, b) => b.volume - a.volume);
        }

        function normalizeSymbol(symbol) {
            let normalized = symbol.replace('USDT', '');
            if (normalized.startsWith('1000000')) normalized = normalized.slice(7);
            else if (normalized.startsWith('1000')) normalized = normalized.slice(4);
            return normalized;
        }

        async function fetchBybitKlines(symbol, limit = null) {
            const bybitSymbol = BYBIT_SYMBOL_MAP[symbol] || `${symbol}USDT`;
            const candles = limit || currentTimeframe;
            const url = `https://api.bybit.com/v5/market/kline?category=linear&symbol=${bybitSymbol}&interval=60&limit=${candles}`;

            try {
                const response = await fetch(url);
                const data = await response.json();

                if (data.retCode !== 0 || !data.result.list) return null;

                return data.result.list
                    .map(candle => ({
                        timestamp: parseInt(candle[0]),
                        open: parseFloat(candle[1]),
                        high: parseFloat(candle[2]),
                        low: parseFloat(candle[3]),
                        close: parseFloat(candle[4]),
                        volume: parseFloat(candle[5])
                    }))
                    .reverse();
            } catch (e) {
                console.error(`Error fetching ${symbol}:`, e);
                return null;
            }
        }

        async function fetchAllData() {
            const startTime = performance.now();

            // Fetch tickers
            const tickers = await fetchBybitTickers();
            const topSymbols = tickers.slice(0, 15).map(t => t.normalized);

            // Ensure BTC is first
            if (!topSymbols.includes('BTC')) topSymbols.unshift('BTC');

            // Fetch klines for each symbol
            const historicalData = {};
            for (const symbol of topSymbols.slice(0, 15)) {
                const klines = await fetchBybitKlines(symbol);
                if (klines && klines.length > 0) {
                    historicalData[symbol] = klines;
                }
                await new Promise(r => setTimeout(r, 50)); // Rate limiting
            }

            const fetchTime = performance.now() - startTime;

            // Calculate rebased returns
            const rebasedData = {};
            performances = [];

            Object.keys(historicalData).forEach(symbol => {
                const candles = historicalData[symbol];
                if (candles.length === 0) return;

                const firstPrice = candles[0].close;
                rebasedData[symbol] = candles.map(c => ({
                    time: c.timestamp / 1000,
                    value: ((c.close - firstPrice) / firstPrice) * 100
                }));

                const lastPrice = candles[candles.length - 1].close;
                const change = ((lastPrice - firstPrice) / firstPrice) * 100;
                performances.push({ symbol, change });
            });

            performances.sort((a, b) => b.change - a.change);
            chartData = rebasedData;

            // Update metrics
            document.getElementById('symbolCount').textContent = Object.keys(rebasedData).length;
            document.getElementById('dataPoints').textContent = Object.values(rebasedData).reduce((sum, arr) => sum + arr.length, 0);
            document.getElementById('fetchTime').textContent = `${(fetchTime / 1000).toFixed(1)}s`;

            if (rebasedData.BTC && rebasedData.BTC.length > 0) {
                const btcChange = rebasedData.BTC[rebasedData.BTC.length - 1].value;
                document.getElementById('btcChange').textContent = `${btcChange >= 0 ? '+' : ''}${btcChange.toFixed(2)}%`;
                document.getElementById('btcChange').style.color = btcChange >= 0 ? 'var(--accent-green)' : 'var(--accent-red)';
            }

            // Update timestamp
            updateLastUpdated();

            return rebasedData;
        }

        function updateLastUpdated() {
            const now = new Date();
            const timeStr = now.toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
            document.getElementById('lastUpdated').textContent = timeStr;
        }

        // =====================================================
        // 1. PLOTLY.JS RENDERING
        // =====================================================

        function renderPlotly(data) {
            const startTime = performance.now();
            const container = document.getElementById('plotlyChart');
            container.innerHTML = '';

            const traces = performances.map((perf, idx) => {
                const symbol = perf.symbol;
                const color = symbol === 'BTC' ? COLOR_PALETTE[0] : COLOR_PALETTE[(idx % (COLOR_PALETTE.length - 1)) + 1];

                return {
                    type: 'scattergl', // WebGL for performance
                    mode: 'lines',
                    name: symbol,
                    x: data[symbol].map(d => new Date(d.time * 1000)),
                    y: data[symbol].map(d => d.value),
                    line: {
                        color: color,
                        width: symbol === 'BTC' ? 2.5 : 1.5
                    },
                    hoverinfo: 'name+y'
                };
            });

            const layout = {
                showlegend: false,
                margin: { l: 45, r: 15, t: 20, b: 40 },
                xaxis: {
                    fixedrange: true,
                    gridcolor: 'rgba(255, 191, 0, 0.08)',
                    color: '#9ca3af',
                    tickfont: { size: 9 }
                },
                yaxis: {
                    fixedrange: true,
                    gridcolor: 'rgba(255, 191, 0, 0.08)',
                    color: '#9ca3af',
                    tickfont: { size: 9 },
                    ticksuffix: '%',
                    zeroline: true,
                    zerolinecolor: '#444'
                },
                paper_bgcolor: '#1a1a1a',
                plot_bgcolor: '#1a1a1a',
                hovermode: 'closest',
                dragmode: false
            };

            const config = {
                displayModeBar: false,
                responsive: true,
                scrollZoom: false
            };

            Plotly.newPlot(container, traces, layout, config);

            const renderTime = performance.now() - startTime;
            document.getElementById('plotlyRender').textContent = `${renderTime.toFixed(0)}ms`;
            document.getElementById('plotlySummary').textContent = `${renderTime.toFixed(0)}ms`;

            // Render custom legend
            renderLegend('plotlyLegend', traces);
        }

        // =====================================================
        // 2. LIGHTWEIGHT CHARTS RENDERING
        // =====================================================

        let lwcChartInstance = null;
        let lwcSeriesMap = {};

        function renderLightweightCharts(data) {
            const startTime = performance.now();
            const container = document.getElementById('lwcChart');
            container.innerHTML = '';

            // Clean up tooltip if exists
            const existingTooltip = document.getElementById('lwcTooltip');
            if (existingTooltip) existingTooltip.remove();

            const chart = LightweightCharts.createChart(container, {
                width: container.clientWidth,
                height: 276,
                layout: {
                    background: { color: '#1a1a1a' },
                    textColor: '#9ca3af',
                    fontSize: 10
                },
                grid: {
                    vertLines: { color: 'rgba(255, 191, 0, 0.06)' },
                    horzLines: { color: 'rgba(255, 191, 0, 0.06)' }
                },
                crosshair: {
                    mode: LightweightCharts.CrosshairMode.Magnet, // Snaps to data points
                    vertLine: {
                        color: 'rgba(251, 191, 36, 0.4)',
                        width: 1,
                        style: LightweightCharts.LineStyle.Dashed,
                        labelBackgroundColor: '#fbbf24'
                    },
                    horzLine: {
                        color: 'rgba(251, 191, 36, 0.4)',
                        width: 1,
                        style: LightweightCharts.LineStyle.Dashed,
                        labelBackgroundColor: '#333'
                    }
                },
                rightPriceScale: {
                    borderColor: 'rgba(255, 191, 0, 0.15)',
                    scaleMargins: { top: 0.08, bottom: 0.08 },
                    entireTextOnly: true // Prevents partial label display
                },
                timeScale: {
                    borderColor: 'rgba(255, 191, 0, 0.15)',
                    timeVisible: true,
                    secondsVisible: false,
                    rightOffset: 5 // Space on right for last labels
                },
                handleScale: {
                    mouseWheel: false,
                    pinch: true
                },
                handleScroll: {
                    mouseWheel: false,
                    pressedMouseMove: true,
                    horzTouchDrag: true,
                    vertTouchDrag: false
                }
            });

            lwcChartInstance = chart;
            lwcSeriesMap = {};
            const seriesData = [];

            // Add zero reference line first (renders behind other series)
            const zeroLine = chart.addLineSeries({
                color: 'rgba(128, 128, 128, 0.5)',
                lineWidth: 1,
                lineStyle: LightweightCharts.LineStyle.Dashed,
                lastValueVisible: false,
                priceLineVisible: false,
                crosshairMarkerVisible: false
            });

            // Create zero line data spanning the time range
            const timePoints = data[Object.keys(data)[0]].map(d => d.time);
            zeroLine.setData(timePoints.map(t => ({ time: t, value: 0 })));

            performances.forEach((perf, idx) => {
                const symbol = perf.symbol;
                const color = symbol === 'BTC' ? COLOR_PALETTE[0] : COLOR_PALETTE[(idx % (COLOR_PALETTE.length - 1)) + 1];

                const series = chart.addLineSeries({
                    color: color,
                    lineWidth: symbol === 'BTC' ? 2.5 : 1.2,
                    priceFormat: {
                        type: 'custom',
                        formatter: price => `${price.toFixed(1)}%`
                    },
                    lastValueVisible: false, // Cleaner - no overlapping labels
                    priceLineVisible: false,
                    crosshairMarkerVisible: true,
                    crosshairMarkerRadius: symbol === 'BTC' ? 5 : 3,
                    crosshairMarkerBorderColor: color,
                    crosshairMarkerBackgroundColor: '#1a1a1a'
                });

                series.setData(data[symbol]);
                lwcSeriesMap[symbol] = { series, color };
                seriesData.push({ symbol, color, series, change: perf.change });
            });

            chart.timeScale().fitContent();

            // Create floating tooltip
            const tooltip = document.createElement('div');
            tooltip.id = 'lwcTooltip';
            tooltip.style.cssText = `
                position: absolute;
                display: none;
                padding: 8px 12px;
                background: rgba(26, 26, 26, 0.95);
                border: 1px solid rgba(251, 191, 36, 0.3);
                border-radius: 6px;
                font-family: 'IBM Plex Mono', monospace;
                font-size: 11px;
                color: #e0e0e0;
                pointer-events: none;
                z-index: 100;
                max-height: 200px;
                overflow-y: auto;
                backdrop-filter: blur(4px);
            `;
            container.style.position = 'relative';
            container.appendChild(tooltip);

            // Crosshair move handler for tooltip
            chart.subscribeCrosshairMove(param => {
                if (!param.time || param.seriesData.size === 0) {
                    tooltip.style.display = 'none';
                    return;
                }

                // Gather all values at this time
                const values = [];
                param.seriesData.forEach((priceData, series) => {
                    // Find matching symbol
                    for (const [symbol, data] of Object.entries(lwcSeriesMap)) {
                        if (data.series === series) {
                            values.push({
                                symbol,
                                value: priceData.value,
                                color: data.color
                            });
                            break;
                        }
                    }
                });

                // Sort by value descending
                values.sort((a, b) => b.value - a.value);

                // Show top 5 and bottom 2 for readability
                const topValues = values.slice(0, 5);
                const bottomValues = values.slice(-2);
                const displayValues = [...topValues];
                if (values.length > 7) {
                    displayValues.push({ symbol: '...', value: null, color: '#666' });
                }
                displayValues.push(...bottomValues.filter(v => !topValues.includes(v)));

                tooltip.innerHTML = displayValues.map(v => {
                    if (v.value === null) return `<div style="color: #666; text-align: center;">···</div>`;
                    const sign = v.value >= 0 ? '+' : '';
                    const valueColor = v.value >= 0 ? '#10b981' : '#ef4444';
                    return `<div style="display: flex; justify-content: space-between; gap: 12px;">
                        <span style="color: ${v.color}; font-weight: ${v.symbol === 'BTC' ? '700' : '400'};">${v.symbol}</span>
                        <span style="color: ${valueColor};">${sign}${v.value.toFixed(2)}%</span>
                    </div>`;
                }).join('');

                // Position tooltip
                const x = param.point.x;
                const y = param.point.y;
                const containerRect = container.getBoundingClientRect();

                // Position to left or right of cursor depending on space
                const tooltipX = x > containerRect.width / 2 ? x - 140 : x + 20;
                tooltip.style.left = `${tooltipX}px`;
                tooltip.style.top = `${Math.max(10, y - 60)}px`;
                tooltip.style.display = 'block';
            });

            // Handle resize
            const resizeObserver = new ResizeObserver(() => {
                chart.applyOptions({ width: container.clientWidth });
            });
            resizeObserver.observe(container);

            const renderTime = performance.now() - startTime;
            document.getElementById('lwcRender').textContent = `${renderTime.toFixed(0)}ms`;
            document.getElementById('lwcSummary').textContent = `${renderTime.toFixed(0)}ms`;

            // Render custom legend with click-to-highlight
            renderLwcLegend('lwcLegend', seriesData);
        }

        function renderLwcLegend(containerId, seriesData) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';

            seriesData.forEach((item) => {
                const legendItem = document.createElement('div');
                legendItem.className = 'legend-item';
                legendItem.dataset.symbol = item.symbol;

                const changeText = `${item.change >= 0 ? '+' : ''}${item.change.toFixed(1)}%`;
                const changeColor = item.change >= 0 ? 'var(--accent-green)' : 'var(--accent-red)';

                legendItem.innerHTML = `
                    <span class="legend-color" style="background: ${item.color}"></span>
                    <span style="font-weight: ${item.symbol === 'BTC' ? '700' : '400'};">${item.symbol}</span>
                    <span style="color: ${changeColor}; font-size: 10px;">${changeText}</span>
                `;

                // Click to highlight series
                legendItem.addEventListener('click', () => {
                    const isHighlighted = legendItem.classList.toggle('highlighted');

                    if (isHighlighted) {
                        // Dim all other series
                        Object.entries(lwcSeriesMap).forEach(([sym, data]) => {
                            if (sym !== item.symbol) {
                                data.series.applyOptions({
                                    color: hexToRgba(data.color, 0.15),
                                    lineWidth: 0.5
                                });
                            } else {
                                data.series.applyOptions({
                                    color: data.color,
                                    lineWidth: 3
                                });
                            }
                        });
                        // Mark other legend items as dimmed
                        container.querySelectorAll('.legend-item').forEach(li => {
                            if (li.dataset.symbol !== item.symbol) {
                                li.style.opacity = '0.3';
                            }
                        });
                    } else {
                        // Restore all series
                        Object.entries(lwcSeriesMap).forEach(([sym, data]) => {
                            data.series.applyOptions({
                                color: data.color,
                                lineWidth: sym === 'BTC' ? 2.5 : 1.2
                            });
                        });
                        // Restore legend items
                        container.querySelectorAll('.legend-item').forEach(li => {
                            li.style.opacity = '1';
                            li.classList.remove('highlighted');
                        });
                    }
                });

                container.appendChild(legendItem);
            });
        }

        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // =====================================================
        // 3. APEXCHARTS RENDERING
        // =====================================================

        function renderApexCharts(data) {
            const startTime = performance.now();
            const container = document.getElementById('apexChart');
            container.innerHTML = '';

            const series = performances.map((perf, idx) => {
                const symbol = perf.symbol;
                return {
                    name: symbol,
                    data: data[symbol].map(d => ({
                        x: d.time * 1000,
                        y: d.value
                    }))
                };
            });

            const colors = performances.map((perf, idx) => {
                return perf.symbol === 'BTC' ? COLOR_PALETTE[0] : COLOR_PALETTE[(idx % (COLOR_PALETTE.length - 1)) + 1];
            });

            const options = {
                chart: {
                    type: 'line',
                    height: 276,
                    background: '#1a1a1a',
                    toolbar: { show: false },
                    zoom: { enabled: false },
                    animations: { enabled: false }
                },
                series: series,
                colors: colors,
                stroke: {
                    width: performances.map(p => p.symbol === 'BTC' ? 2.5 : 1.5),
                    curve: 'smooth'
                },
                grid: {
                    borderColor: 'rgba(255, 191, 0, 0.08)',
                    strokeDashArray: 0
                },
                xaxis: {
                    type: 'datetime',
                    labels: {
                        style: { colors: '#9ca3af', fontSize: '9px' }
                    },
                    axisBorder: { color: 'rgba(255, 191, 0, 0.2)' },
                    axisTicks: { color: 'rgba(255, 191, 0, 0.2)' }
                },
                yaxis: {
                    labels: {
                        style: { colors: '#9ca3af', fontSize: '9px' },
                        formatter: val => `${val.toFixed(1)}%`
                    }
                },
                legend: {
                    show: false
                },
                tooltip: {
                    theme: 'dark',
                    shared: true,
                    intersect: false,
                    y: {
                        formatter: val => `${val.toFixed(2)}%`
                    }
                }
            };

            const chart = new ApexCharts(container, options);
            chart.render();

            const renderTime = performance.now() - startTime;
            document.getElementById('apexRender').textContent = `${renderTime.toFixed(0)}ms`;
            document.getElementById('apexSummary').textContent = `${renderTime.toFixed(0)}ms`;
        }

        // =====================================================
        // 4. CHART.JS RENDERING
        // =====================================================

        function renderChartJS(data) {
            const startTime = performance.now();
            const canvas = document.getElementById('chartjsChart');
            const ctx = canvas.getContext('2d');

            // Destroy existing chart if any
            if (window.chartjsInstance) {
                window.chartjsInstance.destroy();
            }

            const datasets = performances.map((perf, idx) => {
                const symbol = perf.symbol;
                const color = symbol === 'BTC' ? COLOR_PALETTE[0] : COLOR_PALETTE[(idx % (COLOR_PALETTE.length - 1)) + 1];

                return {
                    label: symbol,
                    data: data[symbol].map(d => ({ x: d.time * 1000, y: d.value })),
                    borderColor: color,
                    backgroundColor: 'transparent',
                    borderWidth: symbol === 'BTC' ? 2.5 : 1.5,
                    pointRadius: 0,
                    tension: 0.1
                };
            });

            window.chartjsInstance = new Chart(ctx, {
                type: 'line',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(26, 26, 26, 0.95)',
                            titleColor: '#fbbf24',
                            bodyColor: '#e0e0e0',
                            borderColor: 'rgba(251, 191, 36, 0.3)',
                            borderWidth: 1,
                            callbacks: {
                                label: ctx => `${ctx.dataset.label}: ${ctx.parsed.y.toFixed(2)}%`
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                displayFormats: { hour: 'HH:mm' }
                            },
                            grid: { color: 'rgba(255, 191, 0, 0.08)' },
                            ticks: { color: '#9ca3af', font: { size: 9 } }
                        },
                        y: {
                            grid: { color: 'rgba(255, 191, 0, 0.08)' },
                            ticks: {
                                color: '#9ca3af',
                                font: { size: 9 },
                                callback: val => `${val}%`
                            }
                        }
                    }
                }
            });

            const renderTime = performance.now() - startTime;
            document.getElementById('chartjsRender').textContent = `${renderTime.toFixed(0)}ms`;
            document.getElementById('chartjsSummary').textContent = `${renderTime.toFixed(0)}ms`;
        }

        // =====================================================
        // SHARED LEGEND RENDERER
        // =====================================================

        function renderLegend(containerId, traces) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';

            traces.forEach((trace, idx) => {
                const item = document.createElement('div');
                item.className = 'legend-item';

                const perf = performances.find(p => p.symbol === trace.name);
                const changeText = perf ? `${perf.change >= 0 ? '+' : ''}${perf.change.toFixed(1)}%` : '';
                const changeColor = perf && perf.change >= 0 ? 'var(--accent-green)' : 'var(--accent-red)';

                item.innerHTML = `
                    <span class="legend-color" style="background: ${trace.line.color}"></span>
                    <span>${trace.name}</span>
                    <span style="color: ${changeColor}; font-size: 10px;">${changeText}</span>
                `;

                container.appendChild(item);
            });
        }

        // =====================================================
        // TIMEFRAME & AUTO-REFRESH CONTROLS
        // =====================================================

        function setTimeframe(hours) {
            currentTimeframe = hours;
            localStorage.setItem('chartComparison_timeframe', hours);

            // Update button states
            document.querySelectorAll('.tf-btn').forEach(btn => {
                btn.classList.toggle('tf-active', parseInt(btn.dataset.tf) === hours);
            });

            // Update BTC label
            document.getElementById('btcLabel').textContent = `BTC ${hours}H`;

            // Reload all charts
            reloadAllCharts();
        }

        function toggleAutoRefresh() {
            autoRefreshEnabled = !autoRefreshEnabled;
            localStorage.setItem('chartComparison_autoRefresh', autoRefreshEnabled);
            updateRefreshUI();

            if (autoRefreshEnabled) {
                startAutoRefresh();
            } else {
                stopAutoRefresh();
            }
        }

        function startAutoRefresh() {
            if (autoRefreshInterval) clearInterval(autoRefreshInterval);
            autoRefreshInterval = setInterval(() => {
                reloadAllCharts();
            }, AUTO_REFRESH_MS);
        }

        function stopAutoRefresh() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
            }
        }

        function updateRefreshUI() {
            const indicator = document.getElementById('refreshIndicator');
            const toggle = document.getElementById('refreshToggle');

            indicator.classList.toggle('paused', !autoRefreshEnabled);
            toggle.classList.toggle('paused', !autoRefreshEnabled);
            toggle.textContent = autoRefreshEnabled ? 'AUTO: ON' : 'AUTO: OFF';
        }

        async function reloadAllCharts() {
            try {
                const data = await fetchAllData();
                renderPlotly(data);
                renderLightweightCharts(data);
                renderApexCharts(data);
                renderChartJS(data);
            } catch (error) {
                console.error('Error reloading charts:', error);
            }
        }

        function initializeUI() {
            // Set active timeframe button
            document.querySelectorAll('.tf-btn').forEach(btn => {
                btn.classList.toggle('tf-active', parseInt(btn.dataset.tf) === currentTimeframe);
            });

            // Update BTC label
            document.getElementById('btcLabel').textContent = `BTC ${currentTimeframe}H`;

            // Update refresh UI
            updateRefreshUI();
        }

        // =====================================================
        // INITIALIZATION
        // =====================================================

        async function init() {
            // Initialize UI from localStorage preferences
            initializeUI();

            try {
                const data = await fetchAllData();

                // Render all charts
                renderPlotly(data);
                renderLightweightCharts(data);
                renderApexCharts(data);
                renderChartJS(data);

                // Start auto-refresh if enabled
                if (autoRefreshEnabled) {
                    startAutoRefresh();
                }

            } catch (error) {
                console.error('Error initializing charts:', error);
                document.querySelectorAll('.chart-container').forEach(container => {
                    container.innerHTML = `<div class="loading" style="color: var(--accent-red);">Error: ${error.message}</div>`;
                });
            }
        }

        // Start
        init();
    </script>
</body>
</html>
