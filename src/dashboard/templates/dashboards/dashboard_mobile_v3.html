<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Virtuoso Mobile Dashboard</title>

    <!-- Theme Flash Prevention - Apply saved theme before render -->
    <script>
        (function() {
            var theme = localStorage.getItem('virtuoso-theme');
            if (theme) document.documentElement.setAttribute('data-theme', theme);
        })();
    </script>

    <!-- Access Control - Check for valid access cookie -->
    <script>
        (function() {
            // Check if we're on virtuosocrypto.com domain (production)
            if (window.location.hostname === 'virtuosocrypto.com' || window.location.hostname === 'www.virtuosocrypto.com') {
                // Check for mobile_access cookie
                function getCookie(name) {
                    const value = `; ${document.cookie}`;
                    const parts = value.split(`; ${name}=`);
                    if (parts.length === 2) return parts.pop().split(';').shift();
                    return null;
                }

                const accessToken = getCookie('mobile_access');

                if (!accessToken) {
                    // No access token, redirect to signin
                    console.log('[ACCESS] No mobile_access cookie found, redirecting to signin');
                    window.location.replace('/mobile/signin');
                } else {
                    console.log('[ACCESS] Valid access token found');
                }
            } else {
                // Local development - skip auth check
                console.log('[ACCESS] Development mode - auth check skipped');
            }
        })();
    </script>
    <meta name="description" content="Mobile-optimized cryptocurrency trading dashboard">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Virtuoso">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="Virtuoso">
    <meta name="theme-color" content="#000000">
    
    <!-- PWA Manifest for Android -->
    <link rel="manifest" href="/static/manifest.json">
    
    <!-- Custom Favicon with Amber Trending-Up Icon -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8IS0tIERhcmsgYmFja2dyb3VuZCBtYXRjaGluZyBkYXNoYm9hcmQgdGhlbWUgLS0+CiAgPHJlY3Qgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0IiByeD0iNCIgZmlsbD0iIzBhMGEwYSIvPgogIAogIDwhLS0gQW1iZXIgdHJlbmRpbmctdXAgaWNvbiAtLT4KICA8cGF0aCBkPSJtMyAxNyA2LTYgNCA0IDgtOCIgc3Ryb2tlPSIjZmJiZjI0IiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPgogIDxwYXRoIGQ9Im0yMSA3LTQgNFY3aDR6IiBmaWxsPSIjZmJiZjI0IiBzdHJva2U9IiNmYmJmMjQiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+Cjwvc3ZnPg==">
    
    <!-- Apple Touch Icons for iOS Home Screen -->
    <link rel="apple-touch-icon" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgwIiBoZWlnaHQ9IjE4MCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogIDxyZWN0IHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgcng9IjQiIGZpbGw9IiMwYTBhMGEiLz4KICA8cGF0aCBkPSJtMyAxNyA2LTYgNCA0IDgtOCIgc3Ryb2tlPSIjZmJiZjI0IiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPgogIDxwYXRoIGQ9Im0yMSA3LTQgNFY3aDR6IiBmaWxsPSIjZmJiZjI0IiBzdHJva2U9IiNmYmJmMjQiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+Cjwvc3ZnPg==">
    <link rel="apple-touch-icon" sizes="152x152" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUyIiBoZWlnaHQ9IjE1MiIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogIDxyZWN0IHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgcng9IjQiIGZpbGw9IiMwYTBhMGEiLz4KICA8cGF0aCBkPSJtMyAxNyA2LTYgNCA0IDgtOCIgc3Ryb2tlPSIjZmJiZjI0IiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPgogIDxwYXRoIGQ9Im0yMSA3LTQgNFY3aDR6IiBmaWxsPSIjZmJiZjI0IiBzdHJva2U9IiNmYmJmMjQiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+Cjwvc3ZnPg==">
    <link rel="apple-touch-icon" sizes="180x180" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgwIiBoZWlnaHQ9IjE4MCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogIDxyZWN0IHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgcng9IjQiIGZpbGw9IiMwYTBhMGEiLz4KICA8cGF0aCBkPSJtMyAxNyA2LTYgNCA0IDgtOCIgc3Ryb2tlPSIjZmJiZjI0IiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPgogIDxwYXRoIGQ9Im0yMSA3LTQgNFY3aDR6IiBmaWxsPSIjZmJiZjI0IiBzdHJva2U9IiNmYmJmMjQiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+Cjwvc3ZnPg==">
    
    <!-- Self-hosted Brand Fonts (Inter & IBM Plex Mono) - no external requests needed -->
    <link rel="stylesheet" href="/static/fonts/fonts.css">

    <!-- Preload critical JavaScript for parallel download -->
    <link rel="preload" href="/static/js/lightweight-charts.min.js" as="script">

    <!-- Self-hosted JS libraries for reliability -->
    <script src="/static/js/lucide.min.js" defer></script>
    <script src="/static/js/lightweight-charts.min.js"></script>

    <style>
        /* Virtuoso Brand Mobile Dashboard v2 */
        :root {
            /* Brand Colors from style.html */
            --neon-amber: #fbbf24;
            --neon-cyan: #06B6D4;
            --neon-red: #ff0066;

            /* Dark Backgrounds - OLED Optimized (True Black for 40% battery savings) */
            --bg-primary: #000000;  /* Pure black for OLED power savings */
            --bg-secondary: #0d0d0d;  /* Slightly lighter for contrast */
            --bg-panel: #1a1a1a;
            
            /* Borders */
            --border-light: #222222;
            --border-glow: rgba(251, 191, 36, 0.3);
            
            /* Text */
            --text-primary: #e0e0e0;
            --text-secondary: #9ca3af;
            --text-accent: #fbbf24;
            
            /* Semantic Colors */
            --accent-positive: #10b981;
            --accent-negative: #ef4444;
            --accent-warning: #f59e0b;
            --accent-primary: #fbbf24;  /* Primary action color (amber) */
            
            /* Layout */
            --mobile-header-height: 70px;
            --mobile-nav-height: 64px;  /* Compact glassmorphism nav */
            --safe-area-top: env(safe-area-inset-top);
            --safe-area-bottom: env(safe-area-inset-bottom);
            --content-padding: 20px;
            --card-gap: 17px;
        }

        /* Light Mode Theme - Warm Cream (matching /links) */
        [data-theme="light"] {
            /* Brand Colors - Deepened for cream bg contrast */
            --neon-amber: #b45309;
            --neon-cyan: #0e7490;
            --neon-red: #b91c1c;

            /* Warm Cream Backgrounds (from /links page) */
            --bg-primary: #fff8e0;
            --bg-secondary: #fff3cc;
            --bg-panel: #fffdf5;

            /* Warm Borders */
            --border-light: #e2d5a0;
            --border-glow: rgba(180, 83, 9, 0.25);

            /* Text - DARKER for cream bg readability */
            --text-primary: #1a1a1a;
            --text-secondary: #374151;
            --text-muted: #52525b;
            --text-accent: #b45309;

            /* Complementary Navy Accent */
            --accent-navy: #1e3a5f;
            --accent-navy-light: #2d4a73;

            /* Semantic Colors - deeper for cream bg */
            --accent-positive: #047857;
            --accent-negative: #b91c1c;
            --accent-warning: #b45309;
            --accent-primary: #b45309;

            /* Shadows - warmer tint */
            --shadow-card: 0 1px 3px rgba(180, 83, 9, 0.08), 0 1px 2px rgba(0, 0, 0, 0.04);
            --shadow-elevated: 0 4px 6px rgba(180, 83, 9, 0.12), 0 2px 4px rgba(0, 0, 0, 0.06);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            /* Disable text selection for app-like feel */
            -webkit-user-select: none;
            user-select: none;
        }

        /* Allow text selection in specific areas */
        .selectable, input, textarea {
            -webkit-user-select: text;
            user-select: text;
        }

        /* iOS Spring Animation Timing */
        :root {
            --ios-spring: cubic-bezier(0.34, 1.56, 0.64, 1);
            --ios-ease: cubic-bezier(0.25, 0.1, 0.25, 1);
            --ios-bounce: cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        /* iOS-style Press Effect for Interactive Elements */
        .pressable, button, .nav-item, .mobile-card, .tab-btn, .tf-btn {
            transition: transform 0.15s var(--ios-spring), opacity 0.15s ease;
            cursor: pointer;
        }

        .pressable:active, button:active, .nav-item:active, .tab-btn:active, .tf-btn:active {
            transform: scale(0.97);
            opacity: 0.9;
        }

        /* Card press effect - subtle */
        .mobile-card:active {
            transform: scale(0.99);
        }

        /* Overscroll behavior - contain prevents parent scroll chaining */
        .main-content, .tab-content {
            overscroll-behavior-y: contain;
            -webkit-overflow-scrolling: touch;
        }

        /* Horizontal scroll fade indicators - shows more content exists */
        .scroll-fade-wrapper {
            position: relative;
        }

        .scroll-fade-wrapper::before,
        .scroll-fade-wrapper::after {
            content: '';
            position: absolute;
            top: 0;
            bottom: 4px; /* Account for scrollbar padding */
            width: 24px;
            pointer-events: none;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .scroll-fade-wrapper::before {
            left: 0;
            background: linear-gradient(to right, var(--bg-panel) 0%, transparent 100%);
        }

        .scroll-fade-wrapper::after {
            right: 0;
            background: linear-gradient(to left, var(--bg-panel) 0%, transparent 100%);
        }

        .scroll-fade-wrapper.can-scroll-left::before {
            opacity: 1;
        }

        .scroll-fade-wrapper.can-scroll-right::after {
            opacity: 1;
        }

        /* Minimum 44px touch targets (Apple HIG) - Optimization #7 */
        button, .nav-item, .tab-btn, .pressable, .tf-chip {
            min-height: 44px;
            min-width: 44px;
        }

        /* Ensure inline-styled buttons also meet minimum */
        [onclick], [role="button"] {
            min-height: 44px !important;
            min-width: 44px !important;
        }

        /* Skeleton Loading Animation */
        @keyframes shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }

        .skeleton {
            background: linear-gradient(90deg,
                var(--bg-panel) 25%,
                rgba(255,255,255,0.08) 50%,
                var(--bg-panel) 75%
            );
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite ease-in-out;
            border-radius: 6px;
        }

        .skeleton-card {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: var(--bg-secondary);
            border-radius: 8px;
            margin-bottom: 8px;
        }

        .skeleton-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
        }

        .skeleton-text {
            height: 14px;
            flex: 1;
        }

        .skeleton-text-sm {
            height: 10px;
            width: 60%;
        }

        .skeleton-chart {
            height: 200px;
            width: 100%;
        }

        .skeleton-metric {
            height: 32px;
            width: 80px;
        }
        
        /* Hardware acceleration for smooth scrolling */
        html {
            -webkit-overflow-scrolling: touch;
        }
        
        /* Optimize font rendering */
        html, body {
            text-rendering: optimizeSpeed;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Inter', 'Segoe UI', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.5;
            min-height: 100vh;
            overflow-x: hidden;
            padding-top: var(--safe-area-top);
            padding-bottom: var(--safe-area-bottom);
            -webkit-font-smoothing: antialiased;
        }
        
        /* Monospace typography for data */
        .font-mono,
        .symbol-name,
        .score-value,
        .card-badge,
        .app-title,
        .signal-score,
        .metric-value {
            font-family: 'IBM Plex Mono', monospace;
        }

        /* Mobile Header with Glassmorphism */
        .mobile-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: calc(var(--mobile-header-height) + var(--safe-area-top));
            background: linear-gradient(
                180deg,
                rgba(10, 10, 12, 0.55) 0%,
                rgba(20, 20, 25, 0.45) 100%
            );
            backdrop-filter: blur(24px) saturate(180%);
            -webkit-backdrop-filter: blur(24px) saturate(180%);
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            display: flex;
            align-items: center;
            padding: 0 16px;
            padding-top: var(--safe-area-top);
            z-index: 1001;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.4);
        }

        /* Subtle bottom highlight for depth */
        .mobile-header::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(
                90deg,
                transparent 0%,
                rgba(255, 255, 255, 0.1) 20%,
                rgba(251, 191, 36, 0.12) 50%,
                rgba(255, 255, 255, 0.1) 80%,
                transparent 100%
            );
            pointer-events: none;
        }

        /* Price Ticker Bar - Glass Effect */
        .price-ticker {
            position: fixed;
            top: calc(var(--mobile-header-height) + var(--safe-area-top));
            left: 0;
            right: 0;
            height: 28px;
            background: rgba(15, 15, 18, 0.4);
            backdrop-filter: blur(20px) saturate(150%);
            -webkit-backdrop-filter: blur(20px) saturate(150%);
            border-bottom: 1px solid rgba(255, 255, 255, 0.06);
            z-index: 999;
            overflow: hidden;
            display: flex;
            align-items: center;
        }

        .ticker-track {
            display: flex;
            animation: ticker-scroll 30s linear infinite;
            will-change: transform;
        }

        .ticker-track:hover {
            animation-play-state: paused;
        }

        @keyframes ticker-scroll {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }

        /* Trending Coins Marquee Animation */
        .trending-scroll-wrapper {
            overflow: hidden;
            position: relative;
            mask-image: linear-gradient(to right, transparent, black 8%, black 92%, transparent);
            -webkit-mask-image: linear-gradient(to right, transparent, black 8%, black 92%, transparent);
        }

        .trending-scroll-track {
            display: flex;
            gap: 8px;
            animation: trending-scroll 20s linear infinite;
            width: fit-content;
        }

        .trending-scroll-track:hover {
            animation-play-state: paused;
        }

        @keyframes trending-scroll {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }

        .trending-pill {
            background: linear-gradient(135deg, rgba(251, 191, 36, 0.15) 0%, rgba(251, 191, 36, 0.05) 100%);
            border: 1px solid rgba(251, 191, 36, 0.3);
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 12px;
            font-weight: 600;
            color: var(--neon-amber);
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 4px;
            flex-shrink: 0;
        }

        .ticker-item {
            display: flex;
            align-items: center;
            padding: 0 16px;
            white-space: nowrap;
            font-size: 11px;
            font-family: 'SF Mono', 'Fira Code', monospace;
        }

        .ticker-symbol {
            color: rgba(255, 255, 255, 0.7);
            font-weight: 600;
            margin-right: 6px;
        }

        .ticker-price {
            color: rgba(255, 255, 255, 0.5);
            margin-right: 4px;
        }

        .ticker-change {
            font-weight: 500;
            font-size: 10px;
        }

        .ticker-change.positive {
            color: var(--accent-positive);
        }

        .ticker-change.negative {
            color: var(--accent-negative);
        }

        .ticker-separator {
            color: rgba(255, 255, 255, 0.15);
            margin: 0 4px;
        }

        /* News Ticker Bar - Glass Effect */
        .news-ticker {
            position: fixed;
            top: calc(var(--mobile-header-height) + var(--safe-area-top) + 28px);
            left: 0;
            right: 0;
            height: 24px;
            background: rgba(12, 12, 15, 0.35);
            backdrop-filter: blur(16px) saturate(140%);
            -webkit-backdrop-filter: blur(16px) saturate(140%);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            overflow: hidden;
            z-index: 998; /* Match header/price-ticker z-index level to prevent content bleeding */
            display: flex;
            align-items: center;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        .news-ticker.zen-hidden {
            transform: translateY(-100%);
            opacity: 0;
            pointer-events: none;
        }

        .news-ticker:not(.zen-hidden) {
            transform: translateY(0);
            opacity: 1;
        }

        .news-ticker-label {
            background: var(--neon-amber);
            color: var(--bg-primary);
            font-size: 9px;
            font-weight: 700;
            padding: 3px 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            flex-shrink: 0;
            position: relative;
            z-index: 3;
        }

        .news-track {
            display: flex;
            animation: news-scroll 120s linear infinite;
            will-change: transform;
            position: relative;
            z-index: 1;
        }

        .news-track:hover {
            animation-play-state: paused;
        }

        @keyframes news-scroll {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }

        .news-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 0 16px;
            font-size: 11px;
            white-space: nowrap;
            color: var(--text-secondary);
        }

        .news-item a {
            color: var(--text-secondary);
            text-decoration: none;
            transition: color 0.2s ease;
        }

        .news-item a:hover {
            color: var(--neon-amber);
        }

        .news-source {
            color: var(--text-muted);
            font-size: 9px;
            opacity: 0.7;
        }

        .news-separator {
            color: rgba(255, 255, 255, 0.15);
            margin: 0 4px;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }

        .app-title {
            font-size: 22px;
            font-weight: 700;
            color: var(--neon-amber);
            letter-spacing: 1.5px;
            text-shadow: 0 0 10px rgba(251, 191, 36, 0.3);
        }

        .header-actions {
            display: flex;
            gap: 16px;
        }

        .header-btn {
            background: transparent;
            border: 1px solid transparent;
            color: var(--text-primary);
            padding: 12px;
            cursor: pointer;
            border-radius: 12px;
            transition: all 0.3s ease;
            min-width: 44px;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .header-btn:hover {
            border-color: var(--neon-amber);
            box-shadow: 0 0 15px rgba(251, 191, 36, 0.2);
        }

        .header-btn:active {
            background: rgba(251, 191, 36, 0.1);
            box-shadow: 0 0 20px rgba(251, 191, 36, 0.3), inset 0 0 10px rgba(251, 191, 36, 0.1);
        }

        /* Glassmorphism Bottom Navigation - Edge-to-edge for iOS */
        .bottom-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: auto;
            background: linear-gradient(
                180deg,
                rgba(35, 35, 40, 0.95) 0%,
                rgba(25, 25, 30, 0.98) 50%,
                rgba(10, 10, 10, 1) 100%
            );
            backdrop-filter: blur(24px) saturate(180%);
            -webkit-backdrop-filter: blur(24px) saturate(180%);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px 12px;
            /* Safe area padding - critical for iOS home indicator */
            padding-bottom: calc(12px + env(safe-area-inset-bottom, 0px));
            z-index: 1000;
            box-shadow:
                0 -4px 20px rgba(0, 0, 0, 0.4),
                0 0 0 1px rgba(255, 255, 255, 0.05) inset,
                0 1px 0 rgba(255, 255, 255, 0.12) inset;
            /* Safari iOS fixed positioning fix - transform handled by JS scroll controller */
            -webkit-transform: translateZ(0);
            transform: translateZ(0);
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            /* REMOVED: will-change causes Safari fixed positioning bugs with backdrop-filter */
            /* will-change: transform; */
            isolation: isolate;
            /* Scroll hide/show transition */
            transition: transform 300ms cubic-bezier(0.4, 0, 0.2, 1);
            /* Safari-specific: Force new compositor layer without breaking fixed positioning */
            -webkit-transform-style: flat;
            transform-style: flat;
        }

        /* Reduced motion support - accessibility */
        @media (prefers-reduced-motion: reduce) {
            .bottom-nav {
                transition-duration: 0ms !important;
            }
        }

        /* Hidden state - applied by scroll controller */
        .bottom-nav[aria-hidden="true"] {
            pointer-events: none;
        }

        /* Subtle top highlight for depth */
        .bottom-nav::before {
            content: '';
            position: absolute;
            top: 0;
            left: 24px;
            right: 24px;
            height: 1px;
            background: linear-gradient(90deg,
                transparent 0%,
                rgba(255, 255, 255, 0.15) 30%,
                rgba(255, 255, 255, 0.2) 50%,
                rgba(255, 255, 255, 0.15) 70%,
                transparent 100%
            );
            border-radius: 1px;
        }

        .nav-item {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 8px 6px;
            cursor: pointer;
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            border: none;
            background: transparent;
            color: rgba(255, 255, 255, 0.45);
            text-decoration: none;
            position: relative;
            -webkit-tap-highlight-color: transparent;
            border-radius: 14px;
            margin: 0 3px;
            min-height: 44px;
        }

        .nav-item:hover {
            color: rgba(255, 255, 255, 0.85);
            background: rgba(255, 255, 255, 0.08);
        }

        .nav-item.active {
            color: #fff;
            background: linear-gradient(
                180deg,
                rgba(251, 191, 36, 0.22) 0%,
                rgba(251, 191, 36, 0.12) 100%
            );
            box-shadow:
                0 0 24px rgba(251, 191, 36, 0.2),
                0 0 0 1px rgba(251, 191, 36, 0.25) inset;
        }


        .nav-item:active {
            background: rgba(251, 191, 36, 0.15);
            transform: scale(0.92);
        }

        /* Notification Badge - positioned top-right of icon */
        .notification-badge {
            position: absolute;
            top: 2px;
            right: 50%;
            transform: translateX(20px);
            min-width: 16px;
            height: 16px;
            background: #ef4444;
            border-radius: 8px;
            font-size: 10px;
            font-weight: 700;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            animation: badgePulse 2s ease-in-out infinite;
            z-index: 10;
        }

        .notification-badge.hidden {
            display: none;
        }

        /* Fullscreen Chart Mode - Show only chart with minimal header */
        .fullscreen-chart {
            position: fixed !important;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100% !important;
            height: 100vh !important;
            margin: 0 !important;
            border-radius: 0 !important;
            z-index: 9999;
            overflow: hidden; /* Prevent scrolling to other content */
            background: var(--bg-primary);
            /* CRITICAL: Allow touch interactions for chart gestures */
            touch-action: pan-x pan-y pinch-zoom;
        }

        /* Ensure chart container propagates touch events properly */
        .fullscreen-chart #performanceChart {
            touch-action: pan-x pinch-zoom;
            position: relative;
            will-change: transform;
            pointer-events: auto;
        }

        /* Visual hint at top for swipe-down gesture */
        .fullscreen-chart::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(to bottom,
                rgba(251, 191, 36, 0.3) 0%,
                transparent 100%
            );
            pointer-events: none;
            z-index: 1;
        }

        .fullscreen-chart .card-header {
            position: sticky;
            top: 0;
            background: var(--bg-primary);
            z-index: 10;
            padding: 12px 16px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        /* Hide all sibling cards when one is fullscreen */
        .fullscreen-chart ~ .mobile-card {
            display: none !important;
        }

        /* Chart interaction hint (fades after 2s) */
        .fullscreen-chart-hint {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(251, 191, 36, 0.3);
            border-radius: 20px;
            color: #fbbf24;
            font-size: 11px;
            font-family: 'IBM Plex Mono', monospace;
            z-index: 10001;
            pointer-events: none;
            animation: hintFadeIn 0.3s ease, hintFadeOut 0.3s ease 2s forwards;
        }

        @keyframes hintFadeIn {
            from { opacity: 0; transform: translateX(-50%) translateY(10px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }

        @keyframes hintFadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        /* ========================================
           CURRENT PRICE HUD (Optimization #2)
           Always-visible price overlay in fullscreen
           ======================================== */
        .price-hud {
            position: absolute;
            top: 16px;
            left: 16px;
            z-index: 1000;
            padding: 12px 16px;
            border-radius: 12px;

            /* Glassmorphism effect */
            background: rgba(0, 0, 0, 0.75);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(251, 191, 36, 0.2);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);

            /* Typography */
            font-family: 'IBM Plex Mono', monospace;
            color: var(--text-primary);

            /* Smooth transitions */
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            opacity: 0;
            pointer-events: none;

            /* Prevent touch interference with chart */
            touch-action: none;
        }

        /* Show HUD only in fullscreen mode */
        .fullscreen-chart .price-hud {
            opacity: 1;
        }

        .price-hud-symbol {
            font-size: 11px;
            font-weight: 600;
            color: var(--neon-amber);
            margin-bottom: 4px;
            letter-spacing: 0.5px;
        }

        .price-hud-price {
            font-size: 18px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 2px;
            line-height: 1.2;
        }

        .price-hud-change {
            font-size: 12px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .price-hud-change.positive {
            color: var(--accent-positive);
        }

        .price-hud-change.negative {
            color: var(--accent-negative);
        }

        /* Compact HUD in landscape for more chart space */
        @media (orientation: landscape) {
            .price-hud {
                padding: 8px 12px;
                top: 12px;
                left: 12px;
            }

            .price-hud-symbol {
                font-size: 10px;
                margin-bottom: 2px;
            }

            .price-hud-price {
                font-size: 16px;
            }

            .price-hud-change {
                font-size: 11px;
            }
        }

        /* Animation for price updates */
        @keyframes priceUpdate {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .price-hud-price.updating {
            animation: priceUpdate 0.3s ease;
        }

        /* Portrait Mode (height > width) - header + compact chips */
        @media (orientation: portrait) {
            .fullscreen-chart #performanceChart {
                height: calc(100vh - 120px) !important; /* Header (60px) + Chips (60px) */
                min-height: 300px;
            }
        }

        /* Landscape Mode (width > height) - header + compact chips */
        @media (orientation: landscape) {
            /* CRITICAL: Ensure container doesn't interfere with chart touches in landscape */
            .fullscreen-chart {
                touch-action: pan-x pan-y pinch-zoom !important;
                overflow: hidden !important;
            }

            /* Chart gets precise sizing and full touch priority in landscape */
            .fullscreen-chart #performanceChart {
                height: calc(100vh - 110px) !important; /* Add 10px safety margin to prevent overflow */
                min-height: 200px;
                touch-action: pan-x pinch-zoom !important;
                z-index: 5;  /* Below header controls but above background */
                isolation: isolate;  /* Prevent touch event leakage */
            }

            /* Make timeframe controls more compact in landscape */
            .fullscreen-chart #timeframeSelector {
                grid-template-columns: repeat(7, 1fr) !important;
            }

            .fullscreen-chart #timeframeSelector button {
                padding: 6px 8px !important;
                font-size: 10px !important;
                min-height: 36px !important;
            }

            /* CRITICAL: Ensure header doesn't block chart touches in landscape */
            .fullscreen-chart .card-header {
                padding: 8px 12px;
                touch-action: auto;  /* Let touches pass through to chart below */
                pointer-events: none;  /* Header itself doesn't capture touches */
            }

            /* But keep buttons and controls interactive */
            .fullscreen-chart .card-header button,
            .fullscreen-chart .card-header .auto-refresh-container,
            .fullscreen-chart #timeframeSelector,
            .fullscreen-chart #timeframeSelector button {
                pointer-events: auto;  /* Restore button interactivity */
                touch-action: manipulation;  /* Standard button touch behavior */
            }
        }

        /* Short landscape screens - tighter fit */
        @media (orientation: landscape) and (max-height: 600px) {
            .fullscreen-chart #performanceChart {
                height: calc(100vh - 105px) !important;  /* Tighter fit for small screens */
                min-height: 180px;
            }
        }

        @keyframes badgePulse {
            0% { transform: translateX(20px) scale3d(1, 1, 1); }
            10% { transform: translateX(20px) scale3d(1.02, 1.02, 1); }
            20% { transform: translateX(20px) scale3d(1.04, 1.04, 1); }
            30% { transform: translateX(20px) scale3d(1.06, 1.06, 1); }
            40% { transform: translateX(20px) scale3d(1.08, 1.08, 1); }
            50% { transform: translateX(20px) scale3d(1.10, 1.10, 1); }
            60% { transform: translateX(20px) scale3d(1.08, 1.08, 1); }
            70% { transform: translateX(20px) scale3d(1.06, 1.06, 1); }
            80% { transform: translateX(20px) scale3d(1.04, 1.04, 1); }
            90% { transform: translateX(20px) scale3d(1.02, 1.02, 1); }
            100% { transform: translateX(20px) scale3d(1, 1, 1); }
        }

        .nav-icon {
            width: 20px;
            height: 20px;
            margin-bottom: 3px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            opacity: 0.9;
        }

        .nav-item.active .nav-icon {
            opacity: 1;
            filter: drop-shadow(0 0 4px rgba(251, 191, 36, 0.4));
        }

        .nav-item:hover .nav-icon {
            transform: translateY(-2px) scale(1.05);
        }

        .nav-label {
            font-size: 0.65rem;
            font-weight: 500;
            letter-spacing: 0.3px;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            text-transform: uppercase;
            opacity: 0.9;
            transition: all 0.3s ease;
        }

        .nav-item.active .nav-label {
            font-weight: 600;
            color: var(--neon-amber);
            text-shadow: 0 0 10px rgba(251, 191, 36, 0.3);
        }

        /* Main Content Area */
        .main-content {
            /* Header (70px) + price ticker (28px) + news ticker (24px) + safe area */
            padding-top: calc(var(--mobile-header-height) + var(--safe-area-top) + 52px);
            /* Edge-to-edge nav: nav height + safe area + breathing room */
            padding-bottom: calc(var(--mobile-nav-height) + env(safe-area-inset-bottom, 0px) + 24px);
            min-height: 100vh;
        }

        /* Dynamic Island Safe Area */
        @supports (padding: max(0px)) {
            .mobile-header {
                padding-top: max(var(--safe-area-top), 20px);
            }
            .main-content {
                /* Header + price ticker (28px) + news ticker (24px) + safe area */
                padding-top: calc(var(--mobile-header-height) + max(var(--safe-area-top), 20px) + 52px);
            }
        }

        /* Tab Content */
        .tab-content {
            display: none;
            padding: var(--content-padding);
            animation: fadeIn 0.3s ease;
            max-width: 430px;
            margin: 0 auto;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Mobile Cards with Neon Glow on Hover */
        .mobile-card {
            background: var(--bg-panel);
            border: 1px solid var(--border-light);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: var(--card-gap);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            transform: translate3d(0, 0, 0);
            contain: layout style paint;
        }
        
        .mobile-card:hover {
            border-color: var(--neon-amber);
            box-shadow: 0 0 20px rgba(251, 191, 36, 0.2);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .card-title {
            font-size: 18px;
            font-weight: 700;
            color: var(--text-accent);
            letter-spacing: 0.5px;
            font-family: 'IBM Plex Mono', monospace;
        }

        .card-badge {
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 12px;
            font-weight: 600;
            font-family: 'IBM Plex Mono', monospace;
            letter-spacing: 0.5px;
        }

        /* Alert Filter Pills */
        .alert-filter-pill {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            padding: 6px 12px;
            border-radius: 16px;
            border: 1px solid var(--border-light);
            background: var(--bg-secondary);
            color: var(--text-secondary);
            font-size: 11px;
            font-weight: 500;
            white-space: nowrap;
            cursor: pointer;
            transition: all 0.2s ease;
            min-height: 28px;
            line-height: 1;
        }

        .alert-filter-pill i,
        .alert-filter-pill svg {
            flex-shrink: 0;
            display: flex;
            align-items: center;
        }

        .alert-filter-pill span {
            display: inline-flex;
            align-items: center;
        }

        .alert-filter-pill:hover {
            border-color: var(--neon-amber);
            color: var(--text-primary);
        }

        .alert-filter-pill.active {
            background: rgba(251, 191, 36, 0.15);
            border-color: var(--neon-amber);
            color: var(--neon-amber);
            font-weight: 600;
        }

        /* Signal Cards */
        .signal-card {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid var(--border-light);
            transition: all 0.2s ease;
        }

        .signal-card:last-child {
            border-bottom: none;
        }

        .signal-card:hover {
            background: rgba(251, 191, 36, 0.05);
            margin: 0 -8px;
            padding: 12px 8px;
            border-radius: 8px;
        }

        /* MTF Rankings Cards - Override base .signal-card styles */
        #mtfRankingsList .signal-card {
            display: block;
            width: 100%;
            box-sizing: border-box;
            padding: 14px;
            border-bottom: none;
        }

        #mtfRankingsList .signal-card:hover {
            margin: 0;
            padding: 14px;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .signal-info {
            flex: 1;
        }

        .signal-symbol {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-accent);
            margin-bottom: 6px;
            font-family: 'IBM Plex Mono', monospace;
            letter-spacing: 0.5px;
        }

        .signal-details {
            font-size: 14px;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        .signal-score {
            font-size: 22px;
            font-weight: 700;
            padding: 10px 16px;
            border-radius: 12px;
            text-align: center;
            min-width: 75px;
            font-family: 'IBM Plex Mono', monospace;
        }

        .score-high {
            background: rgba(16, 185, 129, 0.2);
            color: var(--accent-positive);
            box-shadow: 0 0 10px rgba(16, 185, 129, 0.2);
        }

        .score-medium {
            background: rgba(245, 158, 11, 0.2);
            color: var(--accent-warning);
            box-shadow: 0 0 10px rgba(245, 158, 11, 0.2);
        }

        .score-low {
            background: rgba(239, 68, 68, 0.2);
            color: var(--accent-negative);
        }

        /* Symbols Grid */
        .symbols-grid {
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-height: 70vh;
            overflow-y: auto;
            position: relative;
        }

        /* Scroll indicator container */
        .scroll-indicator-container {
            position: relative;
        }

        .scroll-indicator-container::after {
            content: '';
            position: sticky;
            bottom: 0;
            left: 0;
            right: 0;
            height: 40px;
            background: linear-gradient(to top, var(--bg-primary) 0%, transparent 100%);
            pointer-events: none;
            display: block;
            margin-top: -40px;
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        .scroll-indicator-container.scrolled-bottom::after {
            opacity: 0;
        }

        /* Scroll hint badge */
        .scroll-hint {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 8px 16px;
            background: rgba(251, 191, 36, 0.15);
            border: 1px solid rgba(251, 191, 36, 0.3);
            border-radius: 20px;
            color: var(--neon-amber);
            font-size: 11px;
            font-weight: 500;
            margin-top: 8px;
            animation: bounce-subtle 2s infinite;
            transition: opacity 0.3s ease;
        }

        .scroll-hint.hidden {
            opacity: 0;
            pointer-events: none;
        }

        @keyframes bounce-subtle {
            0% { transform: translateY(0); }
            15% { transform: translateY(-0.75px); }
            30% { transform: translateY(-1.8px); }
            45% { transform: translateY(-2.7px); }
            50% { transform: translateY(-3px); }
            55% { transform: translateY(-2.7px); }
            70% { transform: translateY(-1.8px); }
            85% { transform: translateY(-0.75px); }
            100% { transform: translateY(0); }
        }

        .symbol-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border-light);
            cursor: pointer;
            transition: all 0.3s ease;
            transform: translate3d(0, 0, 0);
            backface-visibility: hidden;
            will-change: transform;
            contain: layout style;
        }

        .symbol-item:hover {
            border-color: var(--neon-amber);
            box-shadow: 0 0 15px rgba(251, 191, 36, 0.2);
        }

        .symbol-item:active {
            transform: scale(0.98);
            background: rgba(251, 191, 36, 0.1);
            box-shadow: 0 0 20px rgba(251, 191, 36, 0.3), inset 0 0 10px rgba(251, 191, 36, 0.1);
        }

        .symbol-info {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
        }

        .symbol-name {
            font-weight: 700;
            font-size: 16px;
            color: var(--text-accent);
            font-family: 'IBM Plex Mono', monospace;
            letter-spacing: 0.5px;
        }

        .symbol-price {
            font-size: 14px;
            color: var(--text-secondary);
            font-family: 'IBM Plex Mono', monospace;
        }

        .symbol-metrics {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .confluence-score {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 50px;
        }

        .score-value {
            font-size: 18px;
            font-weight: 700;
            font-family: 'IBM Plex Mono', monospace;
        }

        .score-label {
            font-size: 10px;
            color: var(--text-secondary);
            text-transform: uppercase;
            font-family: 'IBM Plex Mono', monospace;
            letter-spacing: 0.5px;
        }

        .symbol-change {
            font-size: 14px;
            font-weight: 700;
            padding: 4px 8px;
            border-radius: 4px;
            font-family: 'IBM Plex Mono', monospace;
        }

        .change-positive {
            color: var(--accent-positive);
            background: rgba(16, 185, 129, 0.1);
        }

        .change-negative {
            color: var(--accent-negative);
            background: rgba(239, 68, 68, 0.1);
        }

        .change-neutral {
            color: var(--text-secondary);
            background: rgba(251, 191, 36, 0.1);
        }

        /* Matrix View */
        .matrix-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin-bottom: 20px;
        }

        .matrix-item {
            background: var(--bg-panel);
            border: 1px solid var(--border-light);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 90px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .matrix-item:hover {
            border-color: var(--neon-amber);
            box-shadow: 0 0 20px rgba(251, 191, 36, 0.2);
        }

        .matrix-item:active {
            transform: scale(0.98);
            background: rgba(251, 191, 36, 0.1);
            box-shadow: 0 0 30px var(--neon-amber), inset 0 0 10px rgba(251, 191, 36, 0.2);
        }

        .matrix-symbol {
            font-size: 16px;
            font-weight: 700;
            color: var(--text-accent);
            margin-bottom: 10px;
            letter-spacing: 0.5px;
            font-family: 'IBM Plex Mono', monospace;
        }

        .matrix-value {
            font-size: 20px;
            font-weight: 700;
            font-family: 'IBM Plex Mono', monospace;
        }

        /* Opportunity List */
        .opportunity-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .opportunity-item {
            background: var(--bg-panel);
            border: 1px solid var(--border-light);
            border-radius: 12px;
            padding: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .opportunity-item:hover {
            border-color: var(--neon-amber);
            box-shadow: 0 0 20px rgba(251, 191, 36, 0.2);
        }

        .opportunity-item:active {
            transform: scale(0.98);
            background: rgba(251, 191, 36, 0.05);
            box-shadow: 0 0 30px var(--neon-amber), inset 0 0 10px rgba(251, 191, 36, 0.2);
        }

        .opportunity-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .opportunity-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .metric-item {
            text-align: center;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            border: 1px solid rgba(251, 191, 36, 0.1);
        }

        .metric-value {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-accent);
            font-family: 'IBM Plex Mono', monospace;
        }

        .metric-label {
            font-size: 8px;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-top: 2px;
            font-family: 'IBM Plex Mono', monospace;
            letter-spacing: 0.5px;
        }

        /* Action Buttons with Neon Glow */
        .action-buttons {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        .action-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'IBM Plex Mono', monospace;
        }

        .btn-primary {
            background: var(--neon-amber);
            color: #0a0a0a;
            border: 1px solid var(--neon-amber);
        }
        
        .btn-primary:hover {
            box-shadow: 0 0 30px var(--neon-amber), inset 0 0 10px rgba(251, 191, 36, 0.2);
        }

        .btn-secondary {
            background: rgba(251, 191, 36, 0.1);
            color: var(--text-accent);
            border: 1px solid var(--neon-amber);
        }
        
        .btn-secondary:hover {
            background: rgba(251, 191, 36, 0.2);
            box-shadow: 0 0 20px rgba(251, 191, 36, 0.3);
        }

        .action-btn:active {
            transform: scale(0.98);
        }

        /* Pull to Refresh */
        .pull-to-refresh {
            position: absolute;
            top: calc(var(--mobile-header-height) + var(--safe-area-top));
            left: 0;
            right: 0;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            font-size: 14px;
            transform: translateY(-60px);
            transition: transform 0.3s;
        }

        .pull-to-refresh.active {
            transform: translateY(0);
        }

        /* Loading States */
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 40px;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border-light);
            border-top-color: var(--neon-amber);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Empty States */
        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-secondary);
        }

        .empty-icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 16px;
            opacity: 0.5;
        }

        .empty-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text-primary);
        }

        .empty-text {
            font-size: 14px;
            line-height: 1.5;
        }

        /* Responsive Typography - Small Phones */
        @media (max-width: 375px) {
            .app-title { font-size: 18px; }
            .card-title { font-size: 16px; }
            .signal-symbol { font-size: 14px; }
            .signal-score { font-size: 18px; }
        }

        /* Tablet Portrait (iPad Mini, iPad) */
        @media (min-width: 768px) {
            :root {
                --content-padding: 24px;
                --card-gap: 20px;
            }

            .main-content {
                max-width: 900px;
                margin: 0 auto;
            }

            .mobile-card {
                padding: 20px;
            }

            .card-title {
                font-size: 18px;
            }

            /* 2-column grid for signal/symbol lists */
            #liveSignalsList,
            #confluenceScoresList,
            #alphaOpportunitiesList {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 12px;
            }

            /* Wider dominance bar labels */
            #btcDomBar, #ethDomBar, #stableDomBar, #altDomBar {
                min-width: 60px;
            }

            /* Better header spacing */
            .mobile-header {
                padding: 0 24px;
            }

            .header-content {
                max-width: 900px;
                margin: 0 auto;
            }

            /* Larger touch targets not needed on tablet */
            button, .nav-item, .tab-btn, .pressable {
                min-height: 40px;
                min-width: 40px;
            }

            /* Bottom nav wider spacing */
            .bottom-nav {
                max-width: 600px;
                margin: 0 auto;
                border-radius: 20px 20px 0 0;
            }
        }

        /* Tablet Landscape / Small Desktop */
        @media (min-width: 1024px) {
            :root {
                --content-padding: 32px;
                --card-gap: 24px;
            }

            .main-content {
                max-width: 1100px;
            }

            .header-content {
                max-width: 1100px;
            }

            .mobile-card {
                padding: 24px;
                border-radius: 16px;
            }

            .card-title {
                font-size: 20px;
            }

            /* 3-column for lists on large tablets */
            #liveSignalsList,
            #confluenceScoresList {
                grid-template-columns: repeat(3, 1fr);
            }

            /* Larger charts */
            #betaChartContainer {
                height: 350px !important;
            }

            .bottom-nav {
                max-width: 700px;
            }
        }

        /* Large Desktop (optional - if accessed on desktop) */
        @media (min-width: 1280px) {
            .main-content {
                max-width: 1200px;
            }

            .header-content {
                max-width: 1200px;
            }
        }

        /* Dark Mode Support (already dark) */
        @media (prefers-color-scheme: dark) {
            :root {
                --bg-primary: #0a0a0a;
                --bg-secondary: #111111;
            }
        }

        /* Landscape Adjustments */
        @media (orientation: landscape) and (max-height: 600px) {
            .mobile-header { height: 50px; }
            .bottom-nav {
                padding: 6px 16px;
                padding-bottom: calc(6px + env(safe-area-inset-bottom, 0px));
                /* Preserve scroll hide/show transition in landscape */
                transition: transform 300ms cubic-bezier(0.4, 0, 0.2, 1);
            }
            .nav-icon { width: 18px; height: 18px; }
            .nav-label { font-size: 9px; }
            .nav-item {
                padding: 6px 4px;
                min-height: 40px;
                border-radius: 12px;
            }
        }

        /* 
           LANDSCAPE MODE OPTIMIZATIONS (All Landscape Orientations)
           Card #202: Mobile Dashboard Landscape Mode Improvements
            */

        /* P0: Content width - use full landscape width instead of portrait max-width */
        @media (orientation: landscape) {
            .tab-content {
                max-width: min(90vw, 900px);
                padding-left: env(safe-area-inset-left, 16px);
                padding-right: env(safe-area-inset-right, 16px);
            }

            /* P0: Reduce header chrome to maximize content area */
            .mobile-header {
                height: 50px !important;
                --mobile-header-height: 50px;
            }

            /* Note: main-content padding adjusted in TICKER OPTIMIZATIONS block below */

            /* P1: Body safe areas for iPhone notch/Dynamic Island */
            body {
                padding-left: env(safe-area-inset-left);
                padding-right: env(safe-area-inset-right);
            }

            /* P1: Optimized bottom nav for landscape */
            .bottom-nav {
                height: 54px;
                padding: 8px 20px;
                padding-bottom: calc(8px + env(safe-area-inset-bottom, 0px));
                padding-left: calc(20px + env(safe-area-inset-left, 0px));
                padding-right: calc(20px + env(safe-area-inset-right, 0px));
            }

            .nav-item {
                padding: 8px 6px;
                min-height: 44px;
            }

            .nav-icon {
                width: 20px;
                height: 20px;
            }

            .nav-label {
                font-size: 10px;
                margin-top: 2px;
            }
        }

        /* 
           LANDSCAPE MODE: TICKER OPTIMIZATIONS
           Compact both tickers to maximize content area while keeping visible
            */
        @media (orientation: landscape) {
            /* Compact price ticker: reduce height from 28px to 20px */
            .price-ticker {
                height: 20px;
                top: calc(50px + var(--safe-area-top));
            }

            /* Compact news ticker: reduce height from 24px to 18px */
            .news-ticker {
                height: 18px;
                top: calc(50px + var(--safe-area-top) + 20px); /* header + price ticker */
            }

            /* Smaller ticker text for compact height */
            .ticker-item {
                font-size: 10px;
                padding: 0 10px;
            }

            .ticker-change {
                font-size: 9px;
            }

            /* Compact news ticker text */
            .news-ticker-label {
                font-size: 8px;
                padding: 2px 6px;
            }

            .news-track {
                font-size: 10px;
            }

            /* Adjust main content padding: header(50px) + price(20px) + news(18px) + gap(6px) = 94px */
            .main-content {
                padding-top: calc(50px + var(--safe-area-top) + 20px + 18px + 6px);
            }
        }

        /* P1: Two-column grid for wider landscape screens */
        @media (orientation: landscape) and (min-width: 600px) {
            .tab-content > .mobile-card:not(.fullscreen-chart):not(#betaChartCard) {
                display: inline-block;
                width: calc(50% - 8px);
                vertical-align: top;
                margin-right: 8px;
            }

            .tab-content > .mobile-card:not(.fullscreen-chart):not(#betaChartCard):nth-child(2n) {
                margin-right: 0;
            }

            /* Keep full-width for charts and important cards */
            #betaChartCard,
            .mobile-card.fullscreen-chart,
            .tab-content > .mobile-card:first-child {
                display: block;
                width: 100%;
                margin-right: 0;
            }
        }

        /* Neon Text Utility */
        .neon-text {
            color: var(--neon-amber);
            text-shadow: 0 0 10px var(--neon-amber);
        }
        
        /* Pulse Animation for Live Indicators */
        @keyframes pulse {
            0% { opacity: 1; }
            10% { opacity: 0.92; }
            20% { opacity: 0.82; }
            30% { opacity: 0.70; }
            40% { opacity: 0.58; }
            50% { opacity: 0.50; }
            60% { opacity: 0.58; }
            70% { opacity: 0.70; }
            80% { opacity: 0.82; }
            90% { opacity: 0.92; }
            100% { opacity: 1; }
        }
        
        .live-indicator {
            animation: pulse 2s infinite;
        }

        /* ============================================
           ZEN MODE - Hidden Easter Egg Feature
           Double-tap title to hide/show header actions
           ============================================ */

        /* Hide header actions with smooth animation */
        .header-actions.zen-hidden {
            transform: translateX(80px);
            opacity: 0;
            pointer-events: none;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Show state with smooth transition */
        .header-actions:not(.zen-hidden) {
            transform: translateX(0);
            opacity: 1;
            pointer-events: auto;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Zen mode: hide price ticker */
        .price-ticker.zen-hidden {
            transform: translateY(-100%);
            opacity: 0;
            pointer-events: none;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .price-ticker:not(.zen-hidden) {
            transform: translateY(0);
            opacity: 1;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Amber glow feedback animation on double-tap */
        @keyframes zen-tap-feedback {
            0% {
                text-shadow: 0 0 10px rgba(251, 191, 36, 0.3);
            }
            50% {
                text-shadow: 0 0 30px rgba(251, 191, 36, 0.8),
                            0 0 40px rgba(251, 191, 36, 0.6),
                            0 0 50px rgba(251, 191, 36, 0.4);
            }
            100% {
                text-shadow: 0 0 10px rgba(251, 191, 36, 0.3);
            }
        }

        .app-title.zen-tapped {
            animation: zen-tap-feedback 0.6s ease-out;
        }

        /* Prevent text selection during double-tap */
        .app-title.zen-interactive {
            user-select: none;
            -webkit-user-select: none;
            cursor: pointer;
        }

        /* 
           MOMENTUM WAVES MOBILE - Native widget optimized for mobile
            */

        .momentum-waves-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            padding: 12px;
        }

        .momentum-card-mobile {
            position: relative;
            background: var(--bg-secondary);
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid var(--border-light);
            transition: transform 0.15s ease, border-color 0.15s ease;
        }

        .momentum-card-mobile:active {
            transform: scale(0.98);
            border-color: rgba(255, 255, 255, 0.15);
        }

        .momentum-card-mobile.bullish {
            background: linear-gradient(135deg, var(--bg-secondary) 0%, rgba(16, 185, 129, 0.08) 100%);
        }

        .momentum-card-mobile.bearish {
            background: linear-gradient(135deg, var(--bg-secondary) 0%, rgba(239, 68, 68, 0.08) 100%);
        }

        .momentum-card-mobile.neutral {
            background: linear-gradient(135deg, var(--bg-secondary) 0%, rgba(156, 163, 175, 0.05) 100%);
        }

        .momentum-card-mobile.warming {
            background: linear-gradient(135deg, var(--bg-secondary) 0%, rgba(245, 158, 11, 0.08) 100%);
        }

        /* Card-level pill pulse animation */
        .card-pulse-ring-mobile {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 8px;
            border: 2px solid;
            opacity: 0;
            pointer-events: none;
            will-change: transform, opacity;
        }

        .momentum-card-mobile.bullish .card-pulse-ring-mobile {
            border-color: #10b981;
            animation: cardPulsePill var(--pulse-duration, 3s) ease-out infinite;
        }

        .momentum-card-mobile.bearish .card-pulse-ring-mobile {
            border-color: #ef4444;
            animation: cardPulsePill var(--pulse-duration, 3s) ease-out infinite;
        }

        .momentum-card-mobile.neutral .card-pulse-ring-mobile {
            /* No pulse animation for neutral cards - only circle pulses */
            display: none;
        }

        .momentum-card-mobile.warming .card-pulse-ring-mobile {
            border-color: #f59e0b;
            animation: cardPulsePill var(--pulse-duration, 3.5s) ease-out infinite;
        }

        @keyframes cardPulsePill {
            0% {
                transform: scaleX(1);
                opacity: 0;
            }
            5% {
                opacity: 0.25;
            }
            20% {
                transform: scaleX(1.03);
                opacity: 0.18;
            }
            50% {
                transform: scaleX(1.08);
                opacity: 0.08;
            }
            100% {
                transform: scaleX(1.12);
                opacity: 0;
            }
        }

        .momentum-card-inner-mobile {
            display: flex;
            flex-direction: column;
            padding: 10px;
            position: relative;
            z-index: 2;
        }

        .momentum-card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 8px;
        }

        .momentum-symbol-mobile {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 13px;
            font-weight: 700;
            color: var(--text-primary);
            letter-spacing: -0.02em;
        }

        .momentum-signal-badge-mobile {
            display: inline-flex;
            align-items: center;
            gap: 3px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 8px;
            font-weight: 600;
            padding: 2px 5px;
            border-radius: 3px;
            letter-spacing: 0.04em;
        }

        .momentum-signal-badge-mobile::before {
            content: '';
            width: 4px;
            height: 4px;
            border-radius: 50%;
            animation: momentumSignalPulseMobile 1.5s ease-in-out infinite;
        }

        @keyframes momentumSignalPulseMobile {
            0% { opacity: 1; transform: scale3d(1, 1, 1); }
            5% { opacity: 0.97; transform: scale3d(0.985, 0.985, 1); }
            10% { opacity: 0.94; transform: scale3d(0.97, 0.97, 1); }
            15% { opacity: 0.90; transform: scale3d(0.955, 0.955, 1); }
            20% { opacity: 0.86; transform: scale3d(0.94, 0.94, 1); }
            25% { opacity: 0.82; transform: scale3d(0.928, 0.928, 1); }
            30% { opacity: 0.78; transform: scale3d(0.918, 0.918, 1); }
            35% { opacity: 0.75; transform: scale3d(0.91, 0.91, 1); }
            40% { opacity: 0.73; transform: scale3d(0.905, 0.905, 1); }
            45% { opacity: 0.71; transform: scale3d(0.902, 0.902, 1); }
            50% { opacity: 0.70; transform: scale3d(0.90, 0.90, 1); }
            55% { opacity: 0.71; transform: scale3d(0.902, 0.902, 1); }
            60% { opacity: 0.73; transform: scale3d(0.905, 0.905, 1); }
            65% { opacity: 0.75; transform: scale3d(0.91, 0.91, 1); }
            70% { opacity: 0.78; transform: scale3d(0.918, 0.918, 1); }
            75% { opacity: 0.82; transform: scale3d(0.928, 0.928, 1); }
            80% { opacity: 0.86; transform: scale3d(0.94, 0.94, 1); }
            85% { opacity: 0.90; transform: scale3d(0.955, 0.955, 1); }
            90% { opacity: 0.94; transform: scale3d(0.97, 0.97, 1); }
            95% { opacity: 0.97; transform: scale3d(0.985, 0.985, 1); }
            100% { opacity: 1; transform: scale3d(1, 1, 1); }
        }

        .momentum-signal-badge-mobile.LONG {
            background: rgba(16, 185, 129, 0.15);
            color: #34d399;
            border: 1px solid rgba(16, 185, 129, 0.3);
        }
        .momentum-signal-badge-mobile.LONG::before { background: #10b981; }

        .momentum-signal-badge-mobile.SHORT {
            background: rgba(239, 68, 68, 0.15);
            color: #f87171;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }
        .momentum-signal-badge-mobile.SHORT::before { background: #ef4444; }

        .momentum-signal-badge-mobile.NEUTRAL {
            background: rgba(156, 163, 175, 0.12);
            color: #d1d5db;
            border: 1px solid rgba(156, 163, 175, 0.2);
        }
        .momentum-signal-badge-mobile.NEUTRAL::before {
            background: #9ca3af;
            animation: none;
        }

        .momentum-signal-badge-mobile.WARM {
            background: rgba(245, 158, 11, 0.15);
            color: #fbbf24;
            border: 1px solid rgba(245, 158, 11, 0.3);
        }
        .momentum-signal-badge-mobile.WARM::before { background: #f59e0b; }

        .momentum-signal-badge-mobile.COOL {
            background: rgba(245, 158, 11, 0.15);
            color: #fbbf24;
            border: 1px solid rgba(245, 158, 11, 0.3);
        }
        .momentum-signal-badge-mobile.COOL::before { background: #f59e0b; }

        .momentum-card-body {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .momentum-metrics-mobile {
            display: flex;
            flex-direction: column;
            gap: 4px; /* Increased from 2px for better touch targets */
        }

        .momentum-metric-mobile {
            display: flex;
            align-items: center;
            gap: 6px; /* Increased from 4px for visual breathing room */
            min-height: 18px; /* Ensures consistent row height */
        }

        .momentum-metric-label-mobile {
            font-size: 8px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.02em;
            width: 34px; /* Accommodates full words: PRICE, 24H, TREND */
            flex-shrink: 0; /* Prevents label from shrinking */
        }

        .momentum-metric-value-mobile {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 11px;
            font-weight: 500;
            color: var(--text-primary);
            white-space: nowrap; /* Prevents value wrapping */
        }

        .momentum-metric-value-mobile.positive { color: #34d399; }
        .momentum-metric-value-mobile.negative { color: #f87171; }

        .momentum-trend-arrow-mobile {
            display: inline-block;
            font-size: 0.65em;
            margin-left: 1px;
        }

        .momentum-score-container-mobile {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .momentum-sparkline-mobile {
            width: 55px;
            height: 20px;
            opacity: 0.9;
        }

        .sparkline-path-mobile {
            fill: none;
            stroke-width: 1.5;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .momentum-card-mobile.bullish .sparkline-path-mobile { stroke: #10b981; }
        .momentum-card-mobile.bearish .sparkline-path-mobile { stroke: #ef4444; }
        .momentum-card-mobile.neutral .sparkline-path-mobile { stroke: #9ca3af; }
        .momentum-card-mobile.warming .sparkline-path-mobile { stroke: #f59e0b; }

        .momentum-score-circle-mobile {
            position: relative;
            width: 36px;
            height: 36px;
            flex-shrink: 0;
        }

        .momentum-score-ring-mobile {
            transform: rotate(-90deg);
        }

        .momentum-score-ring-bg-mobile {
            fill: none;
            stroke: rgba(255, 255, 255, 0.06);
            stroke-width: 3;
        }

        .momentum-score-ring-progress-mobile {
            fill: none;
            stroke-width: 3;
            stroke-linecap: round;
            transition: stroke-dashoffset 0.5s ease;
        }

        .momentum-card-mobile.bullish .momentum-score-ring-progress-mobile {
            stroke: url(#momentumBullishGradientMobile);
            filter: drop-shadow(0 0 6px rgba(16, 185, 129, 0.4));
        }

        .momentum-card-mobile.bearish .momentum-score-ring-progress-mobile {
            stroke: url(#momentumBearishGradientMobile);
            filter: drop-shadow(0 0 6px rgba(239, 68, 68, 0.4));
        }

        .momentum-card-mobile.neutral .momentum-score-ring-progress-mobile {
            stroke: #9ca3af;
            filter: drop-shadow(0 0 4px rgba(156, 163, 175, 0.3));
        }

        .momentum-card-mobile.warming .momentum-score-ring-progress-mobile {
            stroke: #f59e0b;
            filter: drop-shadow(0 0 6px rgba(245, 158, 11, 0.4));
        }

        .momentum-score-inner-mobile {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }

        .momentum-score-value-mobile {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 11px;
            font-weight: 700;
            line-height: 1;
        }

        .momentum-card-mobile.bullish .momentum-score-value-mobile { color: #34d399; }
        .momentum-card-mobile.bearish .momentum-score-value-mobile { color: #f87171; }
        .momentum-card-mobile.neutral .momentum-score-value-mobile { color: #d1d5db; }
        .momentum-card-mobile.warming .momentum-score-value-mobile { color: #fbbf24; }

        .momentum-pulse-ring-mobile {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 2px solid;
            opacity: 0;
            will-change: transform, opacity;
        }

        .momentum-card-mobile.bullish .momentum-pulse-ring-mobile {
            border-color: #10b981;
            animation: momentumPulseGlowMobile var(--pulse-duration, 2.5s) cubic-bezier(0.4, 0, 0.2, 1) infinite;
        }

        .momentum-card-mobile.bearish .momentum-pulse-ring-mobile {
            border-color: #ef4444;
            animation: momentumPulseGlowMobile var(--pulse-duration, 2.5s) cubic-bezier(0.4, 0, 0.2, 1) infinite;
        }

        .momentum-card-mobile.neutral .momentum-pulse-ring-mobile {
            border-color: #6b7280;
            animation: momentumPulseGlowMobile var(--pulse-duration, 4s) cubic-bezier(0.4, 0, 0.2, 1) infinite;
            opacity: 0.3;
        }

        .momentum-card-mobile.warming .momentum-pulse-ring-mobile {
            border-color: #f59e0b;
            animation: momentumPulseGlowMobile var(--pulse-duration, 3s) cubic-bezier(0.4, 0, 0.2, 1) infinite;
        }

        @keyframes momentumPulseGlowMobile {
            0% { transform: translate(-50%, -50%) scale3d(1, 1, 1); opacity: 0; }
            2% { transform: translate(-50%, -50%) scale3d(1.005, 1.005, 1); opacity: 0.05; }
            4% { transform: translate(-50%, -50%) scale3d(1.012, 1.012, 1); opacity: 0.12; }
            6% { transform: translate(-50%, -50%) scale3d(1.02, 1.02, 1); opacity: 0.19; }
            8% { transform: translate(-50%, -50%) scale3d(1.03, 1.03, 1); opacity: 0.26; }
            10% { transform: translate(-50%, -50%) scale3d(1.04, 1.04, 1); opacity: 0.32; }
            12% { transform: translate(-50%, -50%) scale3d(1.052, 1.052, 1); opacity: 0.38; }
            15% { transform: translate(-50%, -50%) scale3d(1.07, 1.07, 1); opacity: 0.44; }
            18% { transform: translate(-50%, -50%) scale3d(1.09, 1.09, 1); opacity: 0.48; }
            22% { transform: translate(-50%, -50%) scale3d(1.115, 1.115, 1); opacity: 0.50; }
            26% { transform: translate(-50%, -50%) scale3d(1.14, 1.14, 1); opacity: 0.49; }
            30% { transform: translate(-50%, -50%) scale3d(1.17, 1.17, 1); opacity: 0.47; }
            35% { transform: translate(-50%, -50%) scale3d(1.205, 1.205, 1); opacity: 0.44; }
            40% { transform: translate(-50%, -50%) scale3d(1.24, 1.24, 1); opacity: 0.40; }
            45% { transform: translate(-50%, -50%) scale3d(1.275, 1.275, 1); opacity: 0.36; }
            50% { transform: translate(-50%, -50%) scale3d(1.31, 1.31, 1); opacity: 0.32; }
            55% { transform: translate(-50%, -50%) scale3d(1.345, 1.345, 1); opacity: 0.28; }
            60% { transform: translate(-50%, -50%) scale3d(1.38, 1.38, 1); opacity: 0.24; }
            65% { transform: translate(-50%, -50%) scale3d(1.415, 1.415, 1); opacity: 0.20; }
            70% { transform: translate(-50%, -50%) scale3d(1.45, 1.45, 1); opacity: 0.16; }
            75% { transform: translate(-50%, -50%) scale3d(1.485, 1.485, 1); opacity: 0.12; }
            80% { transform: translate(-50%, -50%) scale3d(1.52, 1.52, 1); opacity: 0.09; }
            85% { transform: translate(-50%, -50%) scale3d(1.55, 1.55, 1); opacity: 0.06; }
            90% { transform: translate(-50%, -50%) scale3d(1.575, 1.575, 1); opacity: 0.03; }
            95% { transform: translate(-50%, -50%) scale3d(1.59, 1.59, 1); opacity: 0.01; }
            100% { transform: translate(-50%, -50%) scale3d(1.6, 1.6, 1); opacity: 0; }
        }

        /* SVG definitions - hidden */
        .momentum-svg-defs-mobile {
            position: absolute;
            width: 0;
            height: 0;
            overflow: hidden;
        }

        /* ===================================
           SIGNAL PILLS (Phase 2 - Mobile)
           =================================== */

        .signal-pill-mobile {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            border: 1px solid transparent;
            transition: all 0.2s ease;
        }

        /* Signal Direction Colors */
        .signal-pill-mobile.bullish {
            background: rgba(0, 214, 143, 0.15);
            color: var(--accent-positive);
            border-color: rgba(0, 214, 143, 0.25);
        }

        .signal-pill-mobile.bearish {
            background: rgba(255, 82, 82, 0.15);
            color: var(--accent-negative);
            border-color: rgba(255, 82, 82, 0.25);
        }

        /* Signal Strength Intensity */
        .signal-pill-mobile.extreme {
            font-weight: 700;
            border-width: 1.5px;
        }

        .signal-pill-mobile.strong {
            opacity: 0.95;
        }

        .signal-pill-mobile.moderate {
            opacity: 0.85;
        }

        .signal-pill-mobile.weak {
            opacity: 0.7;
        }

        /* ===== Alert Quick Actions Bottom Sheet ===== */
        .alert-sheet-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            z-index: 9998;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .alert-sheet-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .alert-bottom-sheet {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--bg-secondary);
            border-radius: 20px 20px 0 0;
            border: 1px solid var(--border-light);
            border-bottom: none;
            z-index: 9999;
            transform: translateY(100%);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            max-height: 80vh;
            overflow-y: auto;
            padding-bottom: env(safe-area-inset-bottom, 20px);
        }

        .alert-bottom-sheet.active {
            transform: translateY(0);
        }

        .sheet-handle {
            width: 40px;
            height: 4px;
            background: var(--text-muted);
            border-radius: 2px;
            margin: 12px auto 16px;
        }

        .sheet-header {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 0 20px 16px;
            border-bottom: 1px solid var(--border-light);
        }

        .sheet-header-icon {
            width: 40px;
            height: 40px;
            border-radius: 10px;
            background: rgba(251, 191, 36, 0.15);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .sheet-header-icon i {
            color: var(--neon-amber);
        }

        .sheet-header-text h3 {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .sheet-header-text .sheet-subtitle {
            font-size: 12px;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 6px;
            margin-top: 2px;
        }

        .sheet-score-badge {
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
        }

        .sheet-score-badge.bullish {
            background: rgba(16, 185, 129, 0.15);
            color: var(--accent-positive);
        }

        .sheet-score-badge.bearish {
            background: rgba(239, 68, 68, 0.15);
            color: var(--accent-negative);
        }

        .sheet-options {
            padding: 16px;
        }

        .sheet-option {
            display: flex;
            align-items: center;
            gap: 14px;
            padding: 16px 14px;
            border-radius: 12px;
            margin-bottom: 8px;
            background: var(--bg-tertiary);
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }

        .sheet-option:hover, .sheet-option:active {
            background: rgba(251, 191, 36, 0.1);
            border-color: rgba(251, 191, 36, 0.2);
        }

        .sheet-option-icon {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .sheet-option-icon.amber {
            background: rgba(251, 191, 36, 0.15);
            color: var(--neon-amber);
        }

        .sheet-option-icon.green {
            background: rgba(16, 185, 129, 0.15);
            color: var(--accent-positive);
        }

        .sheet-option-icon.red {
            background: rgba(239, 68, 68, 0.15);
            color: var(--accent-negative);
        }

        .sheet-option-text {
            flex: 1;
        }

        .sheet-option-text h4 {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 2px;
        }

        .sheet-option-text p {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .sheet-option-value {
            font-size: 12px;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .sheet-option-value .count-badge {
            padding: 2px 8px;
            background: rgba(251, 191, 36, 0.15);
            border-radius: 10px;
            font-weight: 600;
            color: var(--neon-amber);
        }

        .sheet-option-toggle {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid var(--border-light);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .sheet-option-toggle.active {
            background: var(--accent-positive);
            border-color: var(--accent-positive);
        }

        .sheet-option-toggle.active i {
            color: white;
        }

        .sheet-divider {
            height: 1px;
            background: var(--border-light);
            margin: 8px 0 16px;
        }

        .sheet-section-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
            padding: 0 4px;
            margin-bottom: 12px;
        }

        /* Threshold Slider in Sheet */
        .threshold-config {
            padding: 16px;
            background: var(--bg-primary);
            border-radius: 12px;
            margin-bottom: 8px;
        }

        .threshold-config-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .threshold-config-header h5 {
            font-size: 13px;
            font-weight: 500;
            color: var(--text-primary);
        }

        .threshold-value-display {
            font-size: 18px;
            font-weight: 700;
            color: var(--neon-amber);
        }

        .threshold-slider-container {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .threshold-slider-container input[type="range"] {
            flex: 1;
            -webkit-appearance: none;
            height: 6px;
            border-radius: 3px;
            background: var(--bg-tertiary);
            outline: none;
        }

        .threshold-slider-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: var(--neon-amber);
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(251, 191, 36, 0.4);
        }

        .threshold-range-labels {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: var(--text-muted);
            margin-top: 6px;
        }

        .sheet-actions {
            display: flex;
            gap: 12px;
            padding: 16px 20px;
            border-top: 1px solid var(--border-light);
        }

        .sheet-btn {
            flex: 1;
            padding: 14px;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
        }

        .sheet-btn.secondary {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border: 1px solid var(--border-light);
        }

        .sheet-btn.primary {
            background: var(--neon-amber);
            color: var(--bg-primary);
        }

        .sheet-btn:active {
            transform: scale(0.98);
        }

        /* ============================================
           LIGHT MODE COMPONENT OVERRIDES
           ============================================ */

        /* Theme Transitions - Smooth color changes */
        html:not(.no-transition) body,
        html:not(.no-transition) .mobile-header,
        html:not(.no-transition) .bottom-nav,
        html:not(.no-transition) .mobile-card,
        html:not(.no-transition) .nav-item,
        html:not(.no-transition) .tf-chip,
        html:not(.no-transition) .price-ticker,
        html:not(.no-transition) .news-ticker {
            transition:
                background-color 0.3s ease,
                border-color 0.3s ease,
                box-shadow 0.3s ease,
                color 0.3s ease;
        }

        /* Disable all transitions during theme init */
        html.no-transition,
        html.no-transition * {
            transition: none !important;
        }

        /* Theme Toggle Group - Sun/Moon/System */
        .theme-toggle-group {
            display: flex;
            gap: 4px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-light);
            border-radius: 8px;
            padding: 3px;
        }

        .theme-toggle-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 28px;
            border: none;
            border-radius: 6px;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .theme-toggle-btn:hover {
            color: var(--text-primary);
            background: rgba(180, 83, 9, 0.1);
        }

        .theme-toggle-btn.active {
            background: var(--accent-primary);
            color: #fff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
        }

        /* Dark mode specific adjustments */
        :root .theme-toggle-btn:hover {
            background: rgba(255, 191, 0, 0.15);
        }

        :root .theme-toggle-btn.active {
            background: var(--neon-amber);
            color: #000;
        }

        /* Body */
        [data-theme="light"] body {
            background: var(--bg-primary);
            color: var(--text-primary);
        }

        /* Glassmorphism Header - Light Mode (Warm Cream) */
        [data-theme="light"] .mobile-header {
            background: linear-gradient(
                180deg,
                rgba(255, 248, 224, 0.95) 0%,
                rgba(255, 243, 204, 0.92) 100%
            );
            border-bottom: 1px solid var(--border-light);
            box-shadow: 0 2px 12px rgba(180, 83, 9, 0.06);
        }

        [data-theme="light"] .mobile-header::before {
            background: linear-gradient(
                90deg,
                transparent 0%,
                rgba(180, 83, 9, 0.03) 20%,
                rgba(180, 83, 9, 0.08) 50%,
                rgba(180, 83, 9, 0.03) 80%,
                transparent 100%
            );
        }

        /* Bottom Navigation - Light Mode (Warm Cream) */
        [data-theme="light"] .bottom-nav {
            background: linear-gradient(
                180deg,
                rgba(255, 253, 245, 0.98) 0%,
                rgba(255, 248, 224, 0.98) 100%
            );
            border-top: 1px solid var(--border-light);
            box-shadow: 0 -2px 12px rgba(180, 83, 9, 0.06);
        }

        [data-theme="light"] .bottom-nav::before {
            background: linear-gradient(90deg,
                transparent 0%,
                rgba(180, 83, 9, 0.04) 30%,
                rgba(180, 83, 9, 0.06) 50%,
                rgba(180, 83, 9, 0.04) 70%,
                transparent 100%
            );
        }

        /* Nav Items - Light Mode */
        [data-theme="light"] .nav-item {
            color: var(--text-secondary);
        }

        [data-theme="light"] .nav-item:hover {
            color: var(--text-primary);
            background: rgba(180, 83, 9, 0.06);
        }

        [data-theme="light"] .nav-item.active {
            color: var(--text-primary);
            background: linear-gradient(
                180deg,
                rgba(180, 83, 9, 0.15) 0%,
                rgba(180, 83, 9, 0.08) 100%
            );
            box-shadow: 0 0 12px rgba(180, 83, 9, 0.12);
        }

        [data-theme="light"] .nav-item.active .nav-label {
            color: var(--neon-amber);
        }

        /* Cards - Light Mode */
        [data-theme="light"] .mobile-card {
            background: var(--bg-panel);
            border: 1px solid var(--border-light);
            box-shadow: var(--shadow-card);
        }

        [data-theme="light"] .mobile-card:hover {
            border-color: rgba(180, 83, 9, 0.4);
            box-shadow: var(--shadow-elevated);
        }

        /* Price Ticker - Light Mode (Warm Cream) */
        [data-theme="light"] .price-ticker {
            background: rgba(255, 253, 245, 0.92);
            border-bottom: 1px solid var(--border-light);
        }

        [data-theme="light"] .ticker-symbol {
            color: var(--text-primary);
        }

        [data-theme="light"] .ticker-price {
            color: var(--text-secondary);
        }

        /* News Ticker - Light Mode (Warm Cream) */
        [data-theme="light"] .news-ticker {
            background: rgba(255, 243, 204, 0.92);
            border-bottom: 1px solid var(--border-light);
        }

        [data-theme="light"] .news-ticker-label {
            background: var(--neon-amber);
            color: #fff;
        }

        /* Timeframe Chips - Light Mode */
        [data-theme="light"] .tf-chip {
            background: rgba(180, 83, 9, 0.04);
            border: 1px solid var(--border-light);
            color: var(--text-secondary);
        }

        [data-theme="light"] .tf-chip-active,
        [data-theme="light"] .tf-chip.active {
            background: linear-gradient(135deg,
                rgba(180, 83, 9, 0.15) 0%,
                rgba(180, 83, 9, 0.08) 100%
            );
            border: 1px solid var(--neon-amber);
            color: var(--neon-amber);
        }

        /* Skeleton Loader - Light Mode (Warm Cream) */
        [data-theme="light"] .skeleton {
            background: linear-gradient(90deg,
                #fff3cc 25%,
                #ffe9a0 50%,
                #fff3cc 75%
            );
            background-size: 200% 100%;
        }

        /* Fullscreen Chart - Light Mode */
        [data-theme="light"] .fullscreen-chart {
            background: var(--bg-primary);
        }

        [data-theme="light"] .price-hud {
            background: rgba(255, 253, 245, 0.98);
            border: 1px solid rgba(180, 83, 9, 0.25);
            box-shadow: 0 4px 20px rgba(180, 83, 9, 0.1);
        }

        /* Settings Panel - Light Mode */
        [data-theme="light"] #settingsPanel {
            background: var(--bg-panel);
            border-left: 1px solid var(--border-light);
        }

        /* Header Buttons - Light Mode */
        [data-theme="light"] .header-btn {
            color: var(--text-primary);
        }

        [data-theme="light"] .header-btn:hover {
            border-color: var(--neon-amber);
            box-shadow: 0 0 12px rgba(180, 83, 9, 0.15);
        }

        [data-theme="light"] .header-btn:active {
            background: rgba(180, 83, 9, 0.1);
        }

        /* App Title - Light Mode */
        [data-theme="light"] .app-title {
            color: var(--neon-amber);
            text-shadow: none;
        }

        /* Tab Buttons - Light Mode */
        [data-theme="light"] .tab-btn {
            background: rgba(180, 83, 9, 0.04);
            border: 1px solid var(--border-light);
            color: var(--text-secondary);
        }

        [data-theme="light"] .tab-btn.active {
            background: linear-gradient(135deg,
                rgba(180, 83, 9, 0.15) 0%,
                rgba(180, 83, 9, 0.08) 100%
            );
            border-color: var(--neon-amber);
            color: var(--neon-amber);
        }

        /* Alert Filter Pills - Light Mode */
        [data-theme="light"] .alert-filter-pill {
            background: var(--bg-secondary);
            border: 1px solid var(--border-light);
            color: var(--text-secondary);
        }

        [data-theme="light"] .alert-filter-pill.active {
            background: linear-gradient(135deg,
                rgba(180, 83, 9, 0.15) 0%,
                rgba(180, 83, 9, 0.08) 100%
            );
            border-color: var(--neon-amber);
            color: var(--neon-amber);
        }

        /* Trending Pills - Light Mode */
        [data-theme="light"] .trending-pill {
            background: linear-gradient(135deg, rgba(180, 83, 9, 0.1) 0%, rgba(180, 83, 9, 0.05) 100%);
            border: 1px solid rgba(180, 83, 9, 0.25);
        }

        /* Card Headers - Light Mode */
        [data-theme="light"] .card-header {
            border-bottom-color: var(--border-light);
        }

        /* Card Titles - Navy accent for light mode */
        [data-theme="light"] .card-title,
        [data-theme="light"] .mobile-card h3,
        [data-theme="light"] .mobile-card h4 {
            color: var(--accent-navy);
        }

        /* LIVE Badge - Navy in light mode */
        [data-theme="light"] .live-badge {
            background: var(--accent-navy);
            color: #fff;
            border-color: var(--accent-navy);
        }

        /* Section Headers - Navy accent */
        [data-theme="light"] .section-title,
        [data-theme="light"] .settings-section h4 {
            color: var(--accent-navy);
        }

        /* Info/Neutral badges - Navy tint */
        [data-theme="light"] .badge-info,
        [data-theme="light"] .badge-neutral {
            background: rgba(30, 58, 95, 0.1);
            color: var(--accent-navy);
            border-color: rgba(30, 58, 95, 0.3);
        }

        /* Scroll Fade Wrappers - Light Mode */
        [data-theme="light"] .scroll-fade-wrapper::before {
            background: linear-gradient(to right, var(--bg-panel) 0%, transparent 100%);
        }

        [data-theme="light"] .scroll-fade-wrapper::after {
            background: linear-gradient(to left, var(--bg-panel) 0%, transparent 100%);
        }

        /* Empty State - Light Mode */
        [data-theme="light"] .empty-state {
            color: var(--text-secondary);
        }

        /* Notification Badge - Light Mode */
        [data-theme="light"] .notification-badge {
            box-shadow: 0 2px 6px rgba(180, 83, 9, 0.15);
        }

        /* Main Content - Light Mode */
        [data-theme="light"] .main-content {
            background: var(--bg-primary);
        }

        /* Sheet / Modal - Light Mode */
        [data-theme="light"] .settings-sheet,
        [data-theme="light"] .detail-sheet {
            background: var(--bg-panel);
        }

        [data-theme="light"] .sheet-btn {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        /* ===== COMPREHENSIVE LIGHT MODE OVERRIDES FOR INLINE STYLES ===== */

        /* NUCLEAR OPTION: Force ALL dark backgrounds to light in cards */
        [data-theme="light"] .mobile-card div[style*="background"] {
            background: var(--bg-secondary) !important;
        }

        /* Re-allow progress bars and colored elements */
        [data-theme="light"] .mobile-card div[style*="background: var(--accent"],
        [data-theme="light"] .mobile-card div[style*="background: linear-gradient"][style*="var(--accent"],
        [data-theme="light"] .mobile-card div[style*="background: #10b981"],
        [data-theme="light"] .mobile-card div[style*="background: #ef4444"],
        [data-theme="light"] .mobile-card div[style*="background: #f59e0b"],
        [data-theme="light"] .mobile-card div[style*="background:#10b981"],
        [data-theme="light"] .mobile-card div[style*="background:#ef4444"],
        [data-theme="light"] .mobile-card div[style*="background:#f59e0b"] {
            background: unset !important;
        }

        /* Specific card overrides by ID */
        [data-theme="light"] #perpsPulseCard div[style*="background"],
        [data-theme="light"] #marketIntelCard div[style*="background"],
        [data-theme="light"] #marketOverviewCard div[style*="background"],
        [data-theme="light"] #topMoversCard div[style*="background"] {
            background: var(--bg-secondary) !important;
            border-color: var(--border-light) !important;
        }

        /* Special gradient sections - make them lighter */
        [data-theme="light"] div[style*="linear-gradient"][style*="rgba(0,0,0"] {
            background: linear-gradient(135deg, rgba(180, 83, 9, 0.08) 0%, var(--bg-secondary) 100%) !important;
        }

        [data-theme="light"] div[style*="linear-gradient"][style*="rgba(6, 182, 212"] {
            background: linear-gradient(135deg, rgba(14, 116, 144, 0.12) 0%, var(--bg-secondary) 100%) !important;
            border-color: rgba(14, 116, 144, 0.25) !important;
        }

        [data-theme="light"] div[style*="linear-gradient"][style*="rgba(251, 191, 36"] {
            background: linear-gradient(135deg, rgba(180, 83, 9, 0.12) 0%, var(--bg-secondary) 100%) !important;
            border-color: rgba(180, 83, 9, 0.2) !important;
        }

        /* Progress bars - keep them visible but lighter */
        [data-theme="light"] div[style*="overflow: hidden"][style*="display: flex"] > div {
            /* Allow colored progress bars */
        }

        /* Specifically fix the stat boxes that have dark backgrounds */
        [data-theme="light"] div[style*="text-align: center"][style*="border-radius: 8px"],
        [data-theme="light"] div[style*="text-align: center"][style*="border-radius: 6px"] {
            background: var(--bg-secondary) !important;
            border: 1px solid var(--border-light) !important;
        }

        /* Alpha Pulse cards - force light backgrounds */
        [data-theme="light"] .alpha-card,
        [data-theme="light"] [class*="alpha-card"],
        [data-theme="light"] div[style*="border-radius: 12px"][style*="padding: 12px"] {
            background: var(--bg-secondary) !important;
            border: 1px solid var(--border-light) !important;
        }

        /* Card expanded sections */
        [data-theme="light"] [id*="_expanded"],
        [data-theme="light"] [id*="_buttons"],
        [data-theme="light"] [id*="Section"] {
            background: var(--bg-secondary) !important;
            border-color: var(--border-light) !important;
        }

        /* Settings overlay */
        [data-theme="light"] #settingsOverlay {
            background: rgba(0, 0, 0, 0.3) !important;
        }

        /* Loading states */
        [data-theme="light"] .loading-overlay {
            background: rgba(255, 255, 255, 0.9) !important;
            color: var(--text-primary) !important;
        }

        /* Quick actions and menus */
        [data-theme="light"] .quick-actions-menu {
            background: rgba(255, 255, 255, 0.95) !important;
            border: 1px solid var(--border-light) !important;
            box-shadow: var(--shadow-elevated) !important;
        }

        /* Select dropdowns */
        [data-theme="light"] select {
            background: var(--bg-panel) !important;
            color: var(--text-primary) !important;
            border-color: var(--border-light) !important;
        }

        /* Stat boxes text */
        [data-theme="light"] .mobile-card div[style*="text-align: center"] {
            color: var(--text-primary);
        }

        /* Force ALL text inside cards to be dark */
        [data-theme="light"] .mobile-card div,
        [data-theme="light"] .mobile-card span {
            color: var(--text-primary) !important;
        }

        /* Restore semantic colors */
        [data-theme="light"] .mobile-card [style*="color: var(--accent-positive)"],
        [data-theme="light"] .mobile-card [style*="color: #10b981"],
        [data-theme="light"] .mobile-card [style*="color:#10b981"] {
            color: #047857 !important;
        }

        [data-theme="light"] .mobile-card [style*="color: var(--accent-negative)"],
        [data-theme="light"] .mobile-card [style*="color: #ef4444"],
        [data-theme="light"] .mobile-card [style*="color:#ef4444"] {
            color: #b91c1c !important;
        }

        [data-theme="light"] .mobile-card [style*="color: var(--accent-warning)"],
        [data-theme="light"] .mobile-card [style*="color: var(--neon-amber)"],
        [data-theme="light"] .mobile-card [style*="color: #f59e0b"],
        [data-theme="light"] .mobile-card [style*="color:#f59e0b"],
        [data-theme="light"] .mobile-card [style*="color: #fbbf24"],
        [data-theme="light"] .mobile-card [style*="color:#fbbf24"],
        [data-theme="light"] .mobile-card [style*="color: #ffa500"],
        [data-theme="light"] .mobile-card [style*="color:#ffa500"] {
            color: #b45309 !important;
        }

        /* Secondary text should be readable but slightly muted */
        [data-theme="light"] .mobile-card [style*="color: var(--text-secondary)"] {
            color: #4b5563 !important;
        }

        /* ===== FORCE READABLE TEXT COLORS ===== */

        /* Override ALL light gray text colors */
        [data-theme="light"] [style*="color: #9ca3af"],
        [data-theme="light"] [style*="color:#9ca3af"],
        [data-theme="light"] [style*="color: rgb(156, 163, 175)"],
        [data-theme="light"] [style*="color: #6b7280"],
        [data-theme="light"] [style*="color:#6b7280"],
        [data-theme="light"] span[style*="color: var(--text-secondary)"] {
            color: #374151 !important;
        }

        /* Make all text in cards readable */
        [data-theme="light"] .mobile-card,
        [data-theme="light"] .mobile-card * {
            color: var(--text-primary);
        }

        /* Restore specific colored elements */
        [data-theme="light"] .mobile-card .card-title,
        [data-theme="light"] .mobile-card h2,
        [data-theme="light"] .mobile-card h3,
        [data-theme="light"] .mobile-card h4 {
            color: var(--accent-navy) !important;
        }

        /* Labels should be darker */
        [data-theme="light"] .mobile-card span,
        [data-theme="light"] .mobile-card label {
            color: #374151 !important;
        }

        /* Keep semantic colors for values */
        [data-theme="light"] [style*="color: #10b981"],
        [data-theme="light"] [style*="color:#10b981"],
        [data-theme="light"] [style*="color: var(--accent-positive)"] {
            color: #047857 !important;
        }

        [data-theme="light"] [style*="color: #ef4444"],
        [data-theme="light"] [style*="color:#ef4444"],
        [data-theme="light"] [style*="color: var(--accent-negative)"] {
            color: #b91c1c !important;
        }

        [data-theme="light"] [style*="color: #f59e0b"],
        [data-theme="light"] [style*="color:#f59e0b"],
        [data-theme="light"] [style*="color: var(--accent-warning)"],
        [data-theme="light"] [style*="color: var(--neon-amber)"] {
            color: #b45309 !important;
        }

        /* ===== SKELETON LOADERS - More visible ===== */
        [data-theme="light"] .skeleton {
            background: linear-gradient(90deg, #e8dfc0 25%, #d4c9a0 50%, #e8dfc0 75%) !important;
            background-size: 200% 100% !important;
        }

        /* Checkbox and input styling */
        [data-theme="light"] input[type="checkbox"] {
            accent-color: var(--accent-primary);
        }

        /* Chart containers */
        [data-theme="light"] .chart-container,
        [data-theme="light"] [style*="background: { color: '#0a0a0a'"] {
            background: var(--bg-panel) !important;
        }

        /* Border overrides */
        [data-theme="light"] [style*="border: 1px solid rgba(255,255,255"] {
            border-color: var(--border-light) !important;
        }

        /* Bottom nav text */
        [data-theme="light"] .nav-label {
            color: #52525b !important;
        }

        [data-theme="light"] .nav-item.active .nav-label {
            color: var(--text-primary) !important;
        }

        /* Header text */
        [data-theme="light"] .header-btn {
            color: #374151 !important;
        }
    </style>
</head>
<body>
    <!-- SVG Definitions for Alpha Pulse Mobile -->
    <svg class="momentum-svg-defs-mobile" aria-hidden="true">
        <defs>
            <linearGradient id="momentumBullishGradientMobile" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" style="stop-color:#10b981" />
                <stop offset="100%" style="stop-color:#34d399" />
            </linearGradient>
            <linearGradient id="momentumBearishGradientMobile" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" style="stop-color:#ef4444" />
                <stop offset="100%" style="stop-color:#f87171" />
            </linearGradient>
        </defs>
    </svg>

    <!-- Mobile Header -->
    <header class="mobile-header">
        <div class="header-content">
            <h1 id="appTitle" class="app-title zen-interactive" style="display: flex; align-items: center; position: relative;">
                <i data-lucide="trending-up" style="width: 24px; height: 24px; margin-right: 8px; color: var(--accent-warning);"></i>
                VIRTUOSO
            </h1>
            <div class="header-actions" id="headerActions">
                <button class="header-btn" onclick="refreshData()">
                    <i data-lucide="refresh-cw" class="header-icon"></i>
                </button>
                <button class="header-btn" onclick="toggleSettings()">
                    <i data-lucide="settings" class="header-icon"></i>
                </button>
            </div>
        </div>
    </header>

    <!-- Price Ticker Bar -->
    <div class="price-ticker" id="priceTicker">
        <div class="ticker-track" id="tickerTrack">
            <!-- Ticker items populated by JavaScript -->
        </div>
    </div>

    <!-- News Ticker Bar -->
    <div class="news-ticker" id="newsTicker">
        <div class="news-ticker-label">News</div>
        <div class="news-track" id="newsTrack">
            <!-- News items populated by JavaScript -->
        </div>
    </div>

    <!-- Pull to Refresh -->
    <div class="pull-to-refresh" id="pullToRefresh">
        <i data-lucide="refresh-cw" style="width: 16px; height: 16px; margin-right: 8px;"></i>
        <span>Pull to refresh</span>
    </div>

    <!-- Main Content -->
    <main class="main-content">
        <!-- Dashboard Tab -->
        <div class="tab-content active" id="dashboardTab">
            <!-- Market Overview -->
            <div class="mobile-card">
                <div class="card-header">
                    <h2 class="card-title">Market Overview</h2>
                    <span class="card-badge" style="background: rgba(76, 175, 80, 0.2); color: var(--accent-positive);">
                        LIVE
                    </span>
                </div>

                <!-- HERO: Market Regime (Primary Focus) -->
                <div style="background: linear-gradient(135deg, rgba(0,0,0,0.3) 0%, rgba(0,0,0,0.15) 100%); padding: 10px 12px; border-radius: 10px; margin-bottom: 12px; border: 1px solid rgba(255,255,255,0.05);">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <div style="font-size: 10px; color: var(--text-secondary); margin-bottom: 2px; text-transform: uppercase; letter-spacing: 0.5px;">Market Regime</div>
                            <div id="marketRegime" style="padding: 6px 10px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.08); max-width: 180px;">
                                <div id="regimeCategory" style="font-size: 14px; font-weight: 700; letter-spacing: 0.2px; color: var(--text-primary); line-height: 1.2;">Loading</div>
                                <div id="regimeLabel" style="font-size: 11px; font-weight: 500; color: var(--text-secondary); margin-top: 2px; line-height: 1.2;"></div>
                            </div>
                        </div>
                        <!-- Fear & Greed (Compact) -->
                        <div style="text-align: right;">
                            <div style="font-size: 10px; color: var(--text-secondary); margin-bottom: 2px; text-transform: uppercase;">Fear & Greed</div>
                            <div style="display: flex; align-items: center; gap: 6px; justify-content: flex-end;">
                                <div id="fearGreedValue" style="font-size: 22px; font-weight: 800; color: var(--accent-warning);">50</div>
                                <div id="fearGreedLabel" style="font-size: 10px; font-weight: 600; color: var(--text-secondary); max-width: 50px; line-height: 1.2;">Neutral</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Total Market Cap (Simplified - removed Vol/MCap per UX review) -->
                <div style="background: rgba(0,0,0,0.15); padding: 12px 14px; border-radius: 10px; margin-bottom: 14px;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <div style="font-size: 10px; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.3px;">Total Market Cap</div>
                            <div style="display: flex; align-items: baseline; gap: 8px; margin-top: 2px;">
                                <span id="totalMarketCap" style="font-size: 24px; font-weight: 700; color: var(--text-primary);">$0</span>
                                <span id="marketCapChange" style="font-size: 12px; font-weight: 600; padding: 2px 8px; border-radius: 4px; background: rgba(76, 175, 80, 0.2); color: var(--accent-positive);">+0%</span>
                            </div>
                        </div>
                        <div style="text-align: right;">
                            <div style="font-size: 10px; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.3px;">24H Volume</div>
                            <div id="totalVolume" style="font-size: 16px; font-weight: 600; color: var(--text-primary); margin-top: 2px;">$0</div>
                        </div>
                    </div>
                </div>

                <!-- Dominance Breakdown Bar (Enhanced per Frontend Dev) -->
                <div style="margin-bottom: 14px;">
                    <div style="font-size: 10px; color: var(--text-secondary); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.3px;">Market Dominance</div>
                    <div style="height: 28px; border-radius: 6px; overflow: hidden; display: flex; background: rgba(0,0,0,0.3); box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);">
                        <div id="btcDomBar" style="background: linear-gradient(180deg, #f7931a 0%, #e67b00 100%); height: 100%; display: flex; align-items: center; justify-content: center; transition: width 0.5s ease; min-width: 40px;">
                            <span style="font-size: 9px; font-weight: 700; color: white; text-shadow: 0 1px 2px rgba(0,0,0,0.3);">BTC</span>
                        </div>
                        <div id="ethDomBar" style="background: linear-gradient(180deg, #627eea 0%, #4a66d4 100%); height: 100%; display: flex; align-items: center; justify-content: center; transition: width 0.5s ease; min-width: 32px;">
                            <span style="font-size: 9px; font-weight: 700; color: white; text-shadow: 0 1px 2px rgba(0,0,0,0.3);">ETH</span>
                        </div>
                        <div id="stableDomBar" style="background: linear-gradient(180deg, #26a17b 0%, #1d8a68 100%); height: 100%; display: flex; align-items: center; justify-content: center; transition: width 0.5s ease; min-width: 38px;">
                            <span style="font-size: 9px; font-weight: 700; color: white; text-shadow: 0 1px 2px rgba(0,0,0,0.3);">STBL</span>
                        </div>
                        <div id="altDomBar" style="background: linear-gradient(180deg, #8b5cf6 0%, #7244e8 100%); height: 100%; display: flex; align-items: center; justify-content: center; transition: width 0.5s ease; flex: 1; min-width: 36px;">
                            <span style="font-size: 9px; font-weight: 700; color: white; text-shadow: 0 1px 2px rgba(0,0,0,0.3);">ALTS</span>
                        </div>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-top: 6px; font-size: 11px;">
                        <span style="color: #f7931a;"><span id="btcDominance" style="font-weight: 700;">57.2%</span> BTC</span>
                        <span style="color: #627eea;"><span id="ethDominance" style="font-weight: 700;">11.4%</span> ETH</span>
                        <span style="color: #26a17b;"><span id="stableDominance" style="font-weight: 700;">8.3%</span> Stable</span>
                        <span style="color: #8b5cf6;"><span id="altDominance" style="font-weight: 700;">23.1%</span> Alts</span>
                    </div>
                </div>

                <!-- Trend & Volatility Row -->
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; margin-bottom: 12px;">
                    <!-- Trend Strength -->
                    <div class="overview-metric">
                        <div style="font-size: 10px; color: var(--text-secondary); margin-bottom: 4px; text-transform: uppercase;">Trend Strength</div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <div id="trendStrength" style="font-size: 18px; font-weight: 700;">0</div>
                            <div style="flex: 1; height: 8px; background: rgba(255, 255, 255, 0.1); border-radius: 4px; overflow: hidden;">
                                <div id="trendStrengthBar" style="height: 100%; width: 0%; background: var(--accent-primary); transition: width 0.3s ease;"></div>
                            </div>
                        </div>
                    </div>

                    <!-- Market Volatility -->
                    <div class="overview-metric">
                        <div style="font-size: 10px; color: var(--text-secondary); margin-bottom: 4px; text-transform: uppercase;">Volatility</div>
                        <div style="font-size: 14px;">
                            <span id="currentVolatility" style="font-weight: 700; color: var(--text-primary);">0%</span>
                            <span style="color: var(--text-secondary); font-size: 11px;"> vs </span>
                            <span id="avgVolatility" style="color: var(--text-secondary); font-size: 12px;">0%</span>
                        </div>
                        <div style="font-size: 10px; margin-top: 2px;">
                            <span id="volatilityDescriptor" style="font-weight: 600; text-transform: uppercase;">-</span>
                        </div>
                    </div>
                </div>

                <!-- Market L/S Positioning (Real Exchange Data) -->
                <div class="breadth-visual" style="padding-top: 12px; border-top: 1px solid var(--border-light);">
                    <div class="breadth-title" style="font-size: 10px; color: var(--text-secondary); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px; display: flex; align-items: center; justify-content: space-between;">
                        <span>L/S Positioning <span class="live-indicator" style="display: inline-block; width: 6px; height: 6px; background: var(--accent-positive); border-radius: 50%; margin-left: 6px; animation: pulse 2s infinite;"></span></span>
                        <span id="lsExchangeBadge" style="font-size: 9px; padding: 2px 6px; background: rgba(139, 92, 246, 0.2); color: #a78bfa; border-radius: 4px;">4 Exchanges</span>
                    </div>
                    <div class="breadth-main" style="display: flex; align-items: center; gap: 12px; margin-bottom: 8px;">
                        <div class="market-icon" id="marketIcon" style="width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; transition: all 0.3s ease; background: rgba(76, 175, 80, 0.2); color: var(--accent-positive);">
                            <i data-lucide="trending-up" style="width: 24px; height: 24px;"></i>
                        </div>
                        <div class="breadth-details" style="flex: 1;">
                            <div class="breadth-label" id="marketLabel" style="font-size: 14px; font-weight: 600; margin-bottom: 4px;">Loading...</div>
                            <div class="breadth-bar-container" style="height: 24px; background: #0a1018; border-radius: 12px; overflow: hidden; position: relative; margin-bottom: 6px;">
                                <div class="breadth-bar-fill" style="height: 100%; display: flex; align-items: center; transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);">
                                    <div class="bull-section" id="bullSection" style="background: var(--accent-positive); height: 100%; display: flex; align-items: center; justify-content: center; color: white; font-size: 11px; font-weight: 700; transition: width 0.5s ease; width: 50%;">50%</div>
                                    <div class="bear-section" id="bearSection" style="background: var(--accent-negative); height: 100%; display: flex; align-items: center; justify-content: center; color: white; font-size: 11px; font-weight: 700; transition: width 0.5s ease; width: 50%;">50%</div>
                                </div>
                            </div>
                            <div class="breadth-stats" style="display: flex; justify-content: space-between; font-size: 12px; color: var(--text-muted);">
                                <span class="stat-item" style="display: flex; align-items: center; gap: 4px;">
                                    <i data-lucide="arrow-up" style="width: 12px; height: 12px; color: var(--accent-positive);"></i>
                                    <span class="stat-value" id="upCount" style="font-weight: 600; color: var(--text-primary);">0%</span>
                                    <span>LONG</span>
                                </span>
                                <span class="stat-item" style="display: flex; align-items: center; gap: 4px;">
                                    <i data-lucide="arrow-down" style="width: 12px; height: 12px; color: var(--accent-negative);"></i>
                                    <span class="stat-value" id="downCount" style="font-weight: 600; color: var(--text-primary);">0%</span>
                                    <span>SHORT</span>
                                </span>
                            </div>
                        </div>
                    </div>
                    <!-- Per-symbol breakdown -->
                    <div id="lsSymbolBreakdown" style="display: flex; gap: 8px; justify-content: center; margin-top: 6px;">
                        <span class="ls-symbol-chip" style="font-size: 10px; padding: 2px 8px; background: rgba(255,255,255,0.05); border-radius: 4px;"><span style="color: var(--text-secondary);">BTC:</span> <span id="lsBtc" style="color: var(--accent-positive);">--</span></span>
                        <span class="ls-symbol-chip" style="font-size: 10px; padding: 2px 8px; background: rgba(255,255,255,0.05); border-radius: 4px;"><span style="color: var(--text-secondary);">ETH:</span> <span id="lsEth" style="color: var(--accent-positive);">--</span></span>
                        <span class="ls-symbol-chip" style="font-size: 10px; padding: 2px 8px; background: rgba(255,255,255,0.05); border-radius: 4px;"><span style="color: var(--text-secondary);">SOL:</span> <span id="lsSol" style="color: var(--accent-positive);">--</span></span>
                    </div>
                </div>

                <!-- Altcoin Season Indicator (Tertiary) -->
                <div style="display: flex; justify-content: flex-end; margin-top: 8px;">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span style="font-size: 10px; color: var(--text-secondary); text-transform: uppercase;">Altcoin Season</span>
                        <div id="altcoinSeason" style="font-size: 12px; font-weight: 700; padding: 4px 12px; border-radius: 12px; background: rgba(139, 92, 246, 0.2); color: #a78bfa;">
                            Dormant
                        </div>
                    </div>
                </div>
            </div>

            <!-- Perpetuals Pulse (Derivatives Intelligence) -->
            <div class="mobile-card" id="perpsPulseCard">
                <div class="card-header">
                    <h2 class="card-title">Perpetuals Pulse</h2>
                    <span class="card-badge" id="perpsExchangeCount" style="background: rgba(255, 165, 0, 0.2); color: #ffa500;">
                        8 CEX/DEX
                    </span>
                </div>

                <!-- Row 1: Funding Rate + Long/Short + Basis -->
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-bottom: 12px;">
                    <!-- Funding Rate -->
                    <div style="background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px; text-align: center;">
                        <div style="font-size: 10px; color: var(--text-secondary); margin-bottom: 4px; text-transform: uppercase;">Funding Rate</div>
                        <div id="perpsFundingRate" style="font-size: 18px; font-weight: 800; color: var(--text-primary);">0.000%</div>
                        <div id="perpsFundingSentiment" style="font-size: 10px; font-weight: 600; color: var(--text-secondary); margin-top: 2px;">NEUTRAL</div>
                    </div>

                    <!-- Long/Short Ratio -->
                    <div style="background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px; text-align: center;">
                        <div style="font-size: 10px; color: var(--text-secondary); margin-bottom: 4px; text-transform: uppercase;">Long / Short</div>
                        <div style="display: flex; justify-content: center; gap: 4px; align-items: baseline;">
                            <span id="perpsLongPct" style="font-size: 16px; font-weight: 700; color: var(--accent-positive);">50%</span>
                            <span style="color: var(--text-secondary); font-size: 12px;">/</span>
                            <span id="perpsShortPct" style="font-size: 16px; font-weight: 700; color: var(--accent-negative);">50%</span>
                        </div>
                        <div id="perpsLSLabel" style="font-size: 10px; font-weight: 600; color: var(--text-secondary); margin-top: 2px;">BALANCED</div>
                    </div>

                    <!-- Basis Status -->
                    <div style="background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px; text-align: center;">
                        <div style="font-size: 10px; color: var(--text-secondary); margin-bottom: 4px; text-transform: uppercase;">Basis</div>
                        <div id="perpsBasisPct" style="font-size: 16px; font-weight: 700; color: var(--text-primary);">+0.00%</div>
                        <div id="perpsBasisStatus" style="font-size: 10px; font-weight: 600; color: var(--text-secondary); margin-top: 2px;">NEUTRAL</div>
                    </div>
                </div>

                <!-- Row 2: Open Interest + CEX/DEX Bar -->
                <div style="background: rgba(0,0,0,0.15); padding: 12px; border-radius: 10px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <div>
                            <div style="font-size: 10px; color: var(--text-secondary); text-transform: uppercase;">Open Interest</div>
                            <div id="perpsOpenInterest" style="font-size: 20px; font-weight: 700; color: var(--text-primary);">$0B</div>
                        </div>
                        <div style="text-align: right;">
                            <div style="font-size: 10px; color: var(--text-secondary); text-transform: uppercase;">24H Volume</div>
                            <div id="perpsVolume" style="font-size: 16px; font-weight: 600; color: var(--text-secondary);">$0B</div>
                        </div>
                    </div>

                    <!-- CEX/DEX Distribution Bar -->
                    <div style="margin-top: 8px;">
                        <div style="font-size: 10px; color: var(--text-secondary); margin-bottom: 4px; text-transform: uppercase;">CEX vs DEX Distribution</div>
                        <div style="height: 20px; border-radius: 6px; overflow: hidden; display: flex; background: rgba(0,0,0,0.3);">
                            <div id="perpsCexBar" style="background: linear-gradient(180deg, #ffa500 0%, #e67b00 100%); height: 100%; display: flex; align-items: center; justify-content: center; transition: width 0.5s ease; width: 90%;">
                                <span style="font-size: 10px; font-weight: 700; color: white;">CEX 90%</span>
                            </div>
                            <div id="perpsDexBar" style="background: linear-gradient(180deg, #8b5cf6 0%, #7244e8 100%); height: 100%; display: flex; align-items: center; justify-content: center; transition: width 0.5s ease; flex: 1;">
                                <span style="font-size: 10px; font-weight: 700; color: white;">DEX</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Row 3: Advanced Metrics (Phase 2) -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 12px; margin-bottom: 12px;">
                    <!-- Funding Z-Score -->
                    <div style="background: rgba(0,0,0,0.15); padding: 10px; border-radius: 8px; display: flex; align-items: center; justify-content: space-between;">
                        <div style="font-size: 10px; color: var(--text-secondary); text-transform: uppercase;">Funding </div>
                        <div id="perpsFundingZScore" style="font-size: 16px; font-weight: 700; color: var(--text-secondary);">+0.00</div>
                    </div>
                    <!-- L/S Entropy (Health Indicator) -->
                    <div style="background: rgba(0,0,0,0.15); padding: 10px; border-radius: 8px; display: flex; align-items: center; justify-content: space-between;">
                        <div style="font-size: 10px; color: var(--text-secondary); text-transform: uppercase;">L/S Health</div>
                        <div id="perpsLSEntropy" style="font-size: 16px; font-weight: 700; color: var(--text-secondary);">50%</div>
                    </div>
                </div>

                <!-- Row 4: Active Signals (Phase 2) -->
                <div id="perpsSignalsContainer" style="display: none; background: rgba(0,0,0,0.15); padding: 12px; border-radius: 10px; margin-bottom: 12px;">
                    <div style="font-size: 11px; color: var(--text-secondary); text-transform: uppercase; margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
                        <span style="font-size: 16px;"></span>
                        <span>Active Signals</span>
                    </div>
                    <div id="perpsSignalsList" style="display: flex; flex-wrap: wrap; gap: 6px;">
                        <!-- Signal pills will be dynamically inserted here -->
                    </div>
                </div>

                <!-- Row 5: CoinGecko Global Derivatives (Cross-Exchange) -->
                <div style="background: linear-gradient(135deg, rgba(6, 182, 212, 0.1) 0%, rgba(0,0,0,0.2) 100%); padding: 12px; border-radius: 10px; margin-bottom: 12px; border: 1px solid rgba(6, 182, 212, 0.2);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <div style="font-size: 10px; color: var(--neon-cyan); text-transform: uppercase; display: flex; align-items: center; gap: 6px;">
                            <span></span>
                            <span>Global Derivatives (CoinGecko)</span>
                        </div>
                        <div style="font-size: 9px; color: var(--text-secondary);">Cross-Exchange</div>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 10px;">
                        <div>
                            <div style="font-size: 10px; color: var(--text-secondary); margin-bottom: 2px;">Total Open Interest</div>
                            <div id="globalDerivativesOI" style="font-size: 20px; font-weight: 700; color: var(--text-primary);">--</div>
                        </div>
                        <div style="text-align: right;">
                            <div style="font-size: 10px; color: var(--text-secondary); margin-bottom: 2px;">Arb Opportunities</div>
                            <div style="font-size: 20px; font-weight: 700; color: var(--neon-cyan);"><span id="arbOpportunities">0</span></div>
                        </div>
                    </div>
                    <!-- OI Distribution by Exchange -->
                    <div style="padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.05); margin-bottom: 10px;">
                        <div style="font-size: 10px; color: var(--text-secondary); text-transform: uppercase; margin-bottom: 8px; letter-spacing: 0.3px;"> OI by Exchange</div>
                        <div id="oiDistributionContainer" style="display: flex; gap: 6px; overflow-x: auto; padding-bottom: 4px; scrollbar-width: none; -ms-overflow-style: none;">
                            <div class="skeleton" style="min-width: 80px; height: 44px;"></div>
                            <div class="skeleton" style="min-width: 80px; height: 44px;"></div>
                            <div class="skeleton" style="min-width: 80px; height: 44px;"></div>
                        </div>
                    </div>
                    <!-- Top Funding Spreads (Arb Opportunities) -->
                    <div style="padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.05);">
                        <div style="font-size: 10px; color: var(--text-secondary); text-transform: uppercase; margin-bottom: 8px; letter-spacing: 0.3px;"> Top Funding Spreads</div>
                        <div id="fundingSpreadsContainer" style="display: flex; gap: 8px; overflow-x: auto; padding-bottom: 4px; scrollbar-width: none; -ms-overflow-style: none;">
                            <div class="skeleton" style="min-width: 100px; height: 48px;"></div>
                            <div class="skeleton" style="min-width: 100px; height: 48px;"></div>
                            <div class="skeleton" style="min-width: 100px; height: 48px;"></div>
                        </div>
                    </div>
                </div>

                <!-- Loading/Error State -->
                <div id="perpsLoadingState" style="display: none; text-align: center; padding: 20px; color: var(--text-secondary);">
                    <div class="spinner" style="width: 24px; height: 24px; margin: 0 auto 8px;"></div>
                    Loading perpetuals data...
                </div>
            </div>

            <!-- Winners & Losers Section -->
            <div class="mobile-card">
                <div class="card-header">
                    <h2 class="card-title">Top Movers</h2>
                    <span class="card-badge" style="background: rgba(255, 191, 0, 0.2); color: var(--text-primary);">
                        24H
                    </span>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 14px;">
                    <!-- Winners Column -->
                    <div>
                        <h4 style="font-size: 13px; font-weight: 600; color: var(--accent-positive); margin-bottom: 12px; text-transform: uppercase; letter-spacing: 0.5px;">
                             TOP GAINERS
                        </h4>
                        <div id="topGainersList" style="display: flex; flex-direction: column; gap: 8px;">
                            <!-- Winners will be populated here - skeleton loaders -->
                            <div class="skeleton-card"><div class="skeleton skeleton-avatar"></div><div style="flex:1"><div class="skeleton skeleton-text" style="margin-bottom:6px"></div><div class="skeleton skeleton-text-sm"></div></div></div>
                            <div class="skeleton-card"><div class="skeleton skeleton-avatar"></div><div style="flex:1"><div class="skeleton skeleton-text" style="margin-bottom:6px"></div><div class="skeleton skeleton-text-sm"></div></div></div>
                            <div class="skeleton-card"><div class="skeleton skeleton-avatar"></div><div style="flex:1"><div class="skeleton skeleton-text" style="margin-bottom:6px"></div><div class="skeleton skeleton-text-sm"></div></div></div>
                        </div>
                    </div>

                    <!-- Losers Column -->
                    <div>
                        <h4 style="font-size: 13px; font-weight: 600; color: var(--accent-negative); margin-bottom: 12px; text-transform: uppercase; letter-spacing: 0.5px;">
                             TOP LOSERS
                        </h4>
                        <div id="topLosersList" style="display: flex; flex-direction: column; gap: 8px;">
                            <!-- Losers will be populated here - skeleton loaders -->
                            <div class="skeleton-card"><div class="skeleton skeleton-avatar"></div><div style="flex:1"><div class="skeleton skeleton-text" style="margin-bottom:6px"></div><div class="skeleton skeleton-text-sm"></div></div></div>
                            <div class="skeleton-card"><div class="skeleton skeleton-avatar"></div><div style="flex:1"><div class="skeleton skeleton-text" style="margin-bottom:6px"></div><div class="skeleton skeleton-text-sm"></div></div></div>
                            <div class="skeleton-card"><div class="skeleton skeleton-avatar"></div><div style="flex:1"><div class="skeleton skeleton-text" style="margin-bottom:6px"></div><div class="skeleton skeleton-text-sm"></div></div></div>
                        </div>
                    </div>
                </div>

                <!-- Trending Coins (Horizontal Scroll) - at bottom -->
                <div style="padding-top: 12px; border-top: 1px solid rgba(255,255,255,0.05);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <div style="display: flex; align-items: center; gap: 6px;">
                            <span style="font-size: 10px; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.3px;"> Trending on CoinGecko</span>
                        </div>
                        <span id="trendingUpdateTime" style="font-size: 9px; color: var(--text-secondary);">--</span>
                    </div>
                    <div id="trendingCoinsWrapper" class="trending-scroll-wrapper">
                        <div id="trendingCoinsContainer" class="trending-scroll-track">
                            <div class="skeleton" style="min-width: 70px; height: 32px;"></div>
                            <div class="skeleton" style="min-width: 70px; height: 32px;"></div>
                            <div class="skeleton" style="min-width: 70px; height: 32px;"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Market Intelligence (CoinGecko Extended Data) -->
            <div class="mobile-card" id="marketIntelCard">
                <div class="card-header">
                    <h2 class="card-title">Market Intelligence</h2>
                    <span class="card-badge" id="marketIntelBadge" style="background: rgba(6, 182, 212, 0.2); color: var(--neon-cyan);">
                        LIVE
                    </span>
                </div>

                <!-- Market Breadth Gauge -->
                <div style="background: rgba(0,0,0,0.2); padding: 12px; border-radius: 10px; margin-bottom: 14px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <div style="font-size: 10px; color: var(--text-secondary); text-transform: uppercase;">Market Breadth</div>
                        <div id="breadthLabel" style="font-size: 11px; font-weight: 600; color: var(--text-secondary);">--</div>
                    </div>
                    <!-- Breadth Bar -->
                    <div style="position: relative; height: 24px; border-radius: 6px; overflow: hidden; background: rgba(0,0,0,0.3);">
                        <div id="breadthBarAdvancing" style="position: absolute; left: 0; top: 0; height: 100%; background: linear-gradient(90deg, var(--accent-positive) 0%, rgba(16, 185, 129, 0.7) 100%); width: 50%; display: flex; align-items: center; justify-content: flex-end; padding-right: 6px; transition: width 0.5s ease;">
                            <span id="breadthAdvancingPct" style="font-size: 10px; font-weight: 700; color: white;">50%</span>
                        </div>
                        <div id="breadthBarDeclining" style="position: absolute; right: 0; top: 0; height: 100%; background: linear-gradient(90deg, rgba(239, 68, 68, 0.7) 0%, var(--accent-negative) 100%); width: 50%; display: flex; align-items: center; justify-content: flex-start; padding-left: 6px; transition: width 0.5s ease;">
                            <span id="breadthDecliningPct" style="font-size: 10px; font-weight: 700; color: white;">50%</span>
                        </div>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-top: 6px;">
                        <div style="font-size: 10px; color: var(--accent-positive);"> <span id="breadthAdvancingCount">0</span> Advancing</div>
                        <div style="font-size: 10px; color: var(--accent-negative);"><span id="breadthDecliningCount">0</span> Declining </div>
                    </div>
                </div>

                <!-- Sector Rotation Signal -->
                <div style="background: linear-gradient(135deg, rgba(0,0,0,0.3) 0%, rgba(0,0,0,0.15) 100%); padding: 12px; border-radius: 10px; margin-bottom: 14px; border: 1px solid rgba(255,255,255,0.05);">
                    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                        <div>
                            <div style="font-size: 10px; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.3px; margin-bottom: 4px;">Sector Rotation</div>
                            <div id="rotationSignal" style="font-size: 13px; font-weight: 700; color: var(--text-primary); padding: 4px 10px; border-radius: 6px; background: rgba(251, 191, 36, 0.15); border: 1px solid rgba(251, 191, 36, 0.3); display: inline-block;">
                                Loading...
                            </div>
                        </div>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                        <div>
                            <div style="font-size: 9px; color: var(--accent-positive); text-transform: uppercase; margin-bottom: 4px;"> Top Sectors</div>
                            <div id="topSectors" style="font-size: 11px; color: var(--text-primary); line-height: 1.5;">
                                <div class="skeleton" style="height: 14px; margin-bottom: 4px;"></div>
                                <div class="skeleton" style="height: 14px; width: 80%;"></div>
                            </div>
                        </div>
                        <div>
                            <div style="font-size: 9px; color: var(--accent-negative); text-transform: uppercase; margin-bottom: 4px;"> Bottom Sectors</div>
                            <div id="bottomSectors" style="font-size: 11px; color: var(--text-primary); line-height: 1.5;">
                                <div class="skeleton" style="height: 14px; margin-bottom: 4px;"></div>
                                <div class="skeleton" style="height: 14px; width: 80%;"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Market Cycle Phase -->
                <div id="cyclePhaseSection" style="background: linear-gradient(135deg, rgba(251, 191, 36, 0.08) 0%, rgba(0,0,0,0.2) 100%); padding: 12px; border-radius: 10px; margin-bottom: 14px; border: 1px solid rgba(251, 191, 36, 0.15);">
                    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                        <div>
                            <div style="font-size: 10px; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.3px; margin-bottom: 4px;">Market Cycle Phase</div>
                            <div id="cyclePhaseLabel" style="font-size: 14px; font-weight: 700; color: var(--neon-amber);">
                                Loading...
                            </div>
                        </div>
                        <div id="cyclePhaseRiskBadge" style="font-size: 9px; font-weight: 700; padding: 4px 8px; border-radius: 4px; background: rgba(251, 191, 36, 0.2); color: var(--neon-amber); text-transform: uppercase;">
                            --
                        </div>
                    </div>
                    <!-- Phase Progress Bar -->
                    <div style="margin-bottom: 10px;">
                        <div style="display: flex; justify-content: space-between; font-size: 8px; color: var(--text-secondary); margin-bottom: 4px;">
                            <span>BTC Dom</span>
                            <span>Infra</span>
                            <span>Alt</span>
                            <span>Spec</span>
                            <span>Peak</span>
                        </div>
                        <div style="position: relative; height: 6px; background: rgba(0,0,0,0.3); border-radius: 3px; overflow: hidden;">
                            <div id="cyclePhaseProgress" style="position: absolute; left: 0; top: 0; height: 100%; width: 50%; background: linear-gradient(90deg, var(--accent-positive), var(--neon-amber), var(--accent-negative)); border-radius: 3px; transition: width 0.5s ease;"></div>
                            <div id="cyclePhaseMarker" style="position: absolute; top: -2px; width: 10px; height: 10px; background: white; border-radius: 50%; box-shadow: 0 0 6px rgba(251,191,36,0.8); left: 50%; transform: translateX(-50%); transition: left 0.5s ease;"></div>
                        </div>
                    </div>
                    <!-- Key Indicators -->
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px;">
                        <div style="text-align: center; background: rgba(0,0,0,0.2); padding: 6px; border-radius: 6px;">
                            <div style="font-size: 8px; color: var(--text-secondary); text-transform: uppercase;">Spec Ratio</div>
                            <div id="cycleSpecRatio" style="font-size: 13px; font-weight: 700; color: var(--text-primary);">--</div>
                        </div>
                        <div style="text-align: center; background: rgba(0,0,0,0.2); padding: 6px; border-radius: 6px;">
                            <div style="font-size: 8px; color: var(--text-secondary); text-transform: uppercase;">Phase Score</div>
                            <div id="cyclePhaseScore" style="font-size: 13px; font-weight: 700; color: var(--text-primary);">--</div>
                        </div>
                        <div style="text-align: center; background: rgba(0,0,0,0.2); padding: 6px; border-radius: 6px;">
                            <div style="font-size: 8px; color: var(--text-secondary); text-transform: uppercase;">Confidence</div>
                            <div id="cycleConfidence" style="font-size: 13px; font-weight: 700; color: var(--text-primary);">--</div>
                        </div>
                    </div>
                </div>

                <!-- Sector Rotation (Bybit-only during migration to multi-exchange) -->
                <!-- MIGRATION NOTE: Multi-exchange version (8 exchanges, 91.7% coverage) available in crypto-perps-tracker -->
                <div id="bybitSectorSection" style="background: linear-gradient(135deg, rgba(6, 182, 212, 0.08) 0%, rgba(0,0,0,0.2) 100%); padding: 12px; border-radius: 10px; margin-bottom: 14px; border: 1px solid rgba(6, 182, 212, 0.15);">
                    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                        <div>
                            <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;">
                                <span style="font-size: 10px; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.3px;">Perps Sector Rotation</span>
                                <span style="font-size: 7px; padding: 2px 5px; background: rgba(251, 191, 36, 0.15); color: var(--neon-amber); border-radius: 3px; font-weight: 600;">BYBIT</span>
                            </div>
                            <div id="bybitSectorStatus" style="font-size: 11px; color: var(--neon-cyan);">
                                Loading...
                            </div>
                        </div>
                        <div id="bybitSectorTimeframe" style="font-size: 9px; font-weight: 600; padding: 4px 8px; border-radius: 4px; background: rgba(6, 182, 212, 0.2); color: var(--neon-cyan); text-transform: uppercase;">
                            4H
                        </div>
                    </div>
                    <!-- Top/Bottom Sectors Grid -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">
                        <div>
                            <div style="font-size: 9px; color: var(--accent-positive); text-transform: uppercase; margin-bottom: 4px;"> Top Inflow</div>
                            <div id="bybitTopSectors" style="font-size: 11px; color: var(--text-primary); line-height: 1.6;">
                                <div style="color: var(--text-secondary);">--</div>
                            </div>
                        </div>
                        <div>
                            <div style="font-size: 9px; color: var(--accent-negative); text-transform: uppercase; margin-bottom: 4px;"> Top Outflow</div>
                            <div id="bybitBottomSectors" style="font-size: 11px; color: var(--text-primary); line-height: 1.6;">
                                <div style="color: var(--text-secondary);">--</div>
                            </div>
                        </div>
                    </div>
                    <!-- Active Signals Count -->
                    <div style="display: flex; justify-content: space-between; align-items: center; background: rgba(0,0,0,0.2); padding: 8px; border-radius: 6px; margin-bottom: 10px;">
                        <div style="font-size: 9px; color: var(--text-secondary); text-transform: uppercase;">Active Signals</div>
                        <div style="display: flex; gap: 12px;">
                            <div style="text-align: center;">
                                <div id="bybitActiveSignals" style="font-size: 14px; font-weight: 700; color: var(--neon-cyan);">0</div>
                                <div style="font-size: 8px; color: var(--text-secondary);">Total</div>
                            </div>
                            <div style="text-align: center;">
                                <div id="bybitConfirmedSignals" style="font-size: 14px; font-weight: 700; color: var(--accent-positive);">0</div>
                                <div style="font-size: 8px; color: var(--text-secondary);">Confirmed</div>
                            </div>
                        </div>
                    </div>
                    <!-- CEX vs DEX Flow -->
                    <div style="background: rgba(0,0,0,0.2); padding: 8px; border-radius: 6px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <div style="font-size: 9px; color: var(--text-secondary); text-transform: uppercase;">CEX vs DEX Flow</div>
                            <div id="cexDexFlowDirection" style="font-size: 8px; padding: 2px 6px; border-radius: 3px; background: rgba(251, 191, 36, 0.2); color: var(--neon-amber); font-weight: 600;">--</div>
                        </div>
                        <div id="cexDexFlowList" style="font-size: 10px; color: var(--text-primary); line-height: 1.6;">
                            <div style="color: var(--text-secondary);">Loading...</div>
                        </div>
                    </div>
                </div>

                <!-- Exchange Concentration -->
                <div style="background: rgba(0,0,0,0.2); padding: 12px; border-radius: 10px;">
                    <div style="font-size: 10px; color: var(--text-secondary); text-transform: uppercase; margin-bottom: 6px;">Exchange Concentration</div>
                    <div style="display: flex; align-items: baseline; gap: 4px; margin-bottom: 4px;">
                        <span id="exchangeTop3Share" style="font-size: 20px; font-weight: 700; color: var(--text-primary);">--</span>
                        <span style="font-size: 11px; color: var(--text-secondary);">Top 3 Share</span>
                    </div>
                    <div id="topExchangesList" style="font-size: 10px; color: var(--text-secondary); line-height: 1.4;">
                        Loading...
                    </div>
                </div>
            </div>
        </div>

        <!-- Signals Tab -->
        <div class="tab-content" id="signalsTab">
            <!-- Signal Overview -->
            <div class="mobile-card" style="margin-bottom: 12px;">
                <div class="card-header" style="margin-bottom: 12px;">
                    <h2 class="card-title">Signal Overview</h2>
                    <span class="card-badge" id="signalCount" style="background: rgba(255, 191, 0, 0.2); color: var(--text-primary);">
                        0
                    </span>
                </div>
                <!-- Performance Stats Row -->
                <div id="signalSummary" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px;">
                    <div style="background: rgba(0,0,0,0.2); padding: 8px; border-radius: 6px; text-align: center;">
                        <div style="font-size: 9px; color: var(--text-secondary); text-transform: uppercase; margin-bottom: 2px;">Long</div>
                        <div id="longCount" style="font-size: 16px; font-weight: 700; color: var(--accent-positive);">0</div>
                    </div>
                    <div style="background: rgba(0,0,0,0.2); padding: 8px; border-radius: 6px; text-align: center;">
                        <div style="font-size: 9px; color: var(--text-secondary); text-transform: uppercase; margin-bottom: 2px;">Short</div>
                        <div id="shortCount" style="font-size: 16px; font-weight: 700; color: var(--accent-negative);">0</div>
                    </div>
                    <div style="background: rgba(0,0,0,0.2); padding: 8px; border-radius: 6px; text-align: center;">
                        <div style="font-size: 9px; color: var(--text-secondary); text-transform: uppercase; margin-bottom: 2px;">Win Rate</div>
                        <div id="winRate" style="font-size: 16px; font-weight: 700; color: var(--neon-amber);">--</div>
                    </div>
                    <div style="background: rgba(0,0,0,0.2); padding: 8px; border-radius: 6px; text-align: center;">
                        <div style="font-size: 9px; color: var(--text-secondary); text-transform: uppercase; margin-bottom: 2px;">24h W/L</div>
                        <div id="winLoss" style="font-size: 16px; font-weight: 700; color: var(--text-primary);">0/0</div>
                    </div>
                </div>
                <!-- Risk Parameters -->
                <div style="margin-top: 10px; padding: 8px 10px; background: rgba(251, 191, 36, 0.08); border-radius: 6px; display: flex; justify-content: space-between; align-items: center;">
                    <span style="font-size: 11px; color: var(--text-secondary);">Risk: <span style="color: var(--text-primary); font-weight: 500;">3.5% SL</span></span>
                    <span style="font-size: 11px; color: var(--text-secondary);">R:R <span style="color: var(--neon-amber); font-weight: 500;">2:1</span></span>
                    <span style="font-size: 11px; color: var(--text-secondary);">Expiry: <span style="color: var(--text-primary); font-weight: 500;">24h</span></span>
                </div>
            </div>
            <!-- Alerted Trade Signals Section - Thanks to Mike Reyes for the UX feedback that led to this feature -->
            <!-- These are high-conviction signals that get pushed to Discord -->
            <div class="mobile-card" id="alertedSignalsCard" style="margin-bottom: 12px;">
                <div class="card-header">
                    <h2 class="card-title" style="font-size: 14px; display: flex; align-items: center; gap: 8px;">
                        <i data-lucide="bell-ring" style="width: 16px; height: 16px; color: var(--accent-positive);"></i>
                        Alerted Trade Signals
                    </h2>
                    <span class="card-badge" id="alertedSignalCount" style="background: rgba(16, 185, 129, 0.2); color: var(--accent-positive);">
                        0
                    </span>
                </div>
                <div style="font-size: 10px; color: var(--text-secondary); margin-bottom: 10px; padding: 0 2px;">
                    High-conviction signals that crossed the alert threshold
                </div>
                <div id="alertedSignalsList">
                    <!-- Alerted signals will be populated here -->
                </div>
            </div>
            <!-- Trade Ideas -->
            <div class="mobile-card">
                <div class="card-header">
                    <h2 class="card-title" style="font-size: 14px;">Trade Ideas</h2>
                </div>
                <div id="signalsList">
                    <!-- Signals will be populated here -->
                </div>
            </div>
        </div>

        <!-- Alpha Tab -->
        <div class="tab-content" id="alphaTab">
            <!-- Alpha Pulse Native Widget -->
            <div class="mobile-card" style="padding: 0; overflow: hidden;">
                <div class="card-header" style="padding: 12px 16px; border-bottom: 1px solid var(--border-light);">
                    <h2 class="card-title" style="display: flex; align-items: center; gap: 8px;">
                        <i data-lucide="activity" style="width: 18px; height: 18px; color: var(--neon-amber);"></i>
                        Alpha Pulse
                    </h2>
                    <span id="momentumWavesCount" class="card-badge" style="background: rgba(255, 191, 0, 0.15); color: var(--neon-amber);">
                        0
                    </span>
                </div>
                <div id="momentumWavesContainer" class="momentum-waves-container">
                    <!-- Momentum cards will be populated here by JavaScript -->
                    <div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: var(--text-muted);">
                        <div class="spinner" style="width: 24px; height: 24px; margin: 0 auto 12px;"></div>
                        <div style="font-size: 12px;">Loading momentum data...</div>
                    </div>
                </div>
            </div>

            <!-- Alpha Scores - COMMENTED OUT (Legacy: Confluence Scores)
            <div class="mobile-card">
                <div class="card-header">
                    <h2 class="card-title">Alpha Scores</h2>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span class="card-badge" id="symbolsCount" style="background: rgba(255, 191, 0, 0.2); color: var(--text-primary);">
                            0
                        </span>
                        <select id="sortSelector" style="background: var(--bg-secondary); border: 1px solid var(--border-light); border-radius: 6px; padding: 6px 12px; color: var(--text-primary); font-size: 12px;" onchange="sortSymbols()">
                            <option value="score">Sort by Score</option>
                            <option value="change">Sort by Change</option>
                            <option value="volume">Sort by Volume</option>
                            <option value="symbol">Sort by Symbol</option>
                        </select>
                    </div>
                </div>

                <div class="symbols-grid scroll-indicator-container" id="confluenceScrollContainer" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(170px, 1fr)); gap: 16px; padding: 4px;">
                    <div id="analyzedSymbolsList">
                        <div class="loading" style="text-align: center; padding: 40px; grid-column: 1 / -1;">
                            <div class="spinner" style="width: 32px; height: 32px; margin: 0 auto;"></div>
                        </div>
                    </div>
                </div>
                <div class="scroll-hint" id="confluenceScrollHint">
                    <i data-lucide="chevrons-down" style="width: 14px; height: 14px;"></i>
                    <span>Scroll for more</span>
                </div>
            </div>
            END Alpha Scores -->

            <!-- Alpha Opportunities - COMMENTED OUT
            <div class="mobile-card">
                <div class="card-header">
                    <h2 class="card-title">Alpha Opportunities</h2>
                    <span class="card-badge" style="background: rgba(76, 175, 80, 0.2); color: var(--accent-positive);">
                        ALPHA
                    </span>
                </div>
                <div id="alphaList">
                </div>
            </div>
            END Alpha Opportunities -->
        </div>

        <!-- Alerts Tab -->
        <div class="tab-content" id="alertsTab">
            <div class="mobile-card">
                <div class="card-header">
                    <h2 class="card-title">Recent Alerts</h2>
                    <span class="card-badge" id="alertCount" style="background: rgba(244, 67, 54, 0.2); color: var(--accent-negative);">
                        0
                    </span>
                </div>
                <!-- Alert Filter Pills -->
                <div id="alertFilters" style="display: flex; gap: 8px; padding: 0 0 12px 0; overflow-x: auto; -webkit-overflow-scrolling: touch; align-items: center;">
                    <button class="alert-filter-pill active" data-filter="all" onclick="filterAlerts('all')">
                        <i data-lucide="layers" style="width: 12px; height: 12px; flex-shrink: 0;"></i>
                        <span>All</span>
                    </button>
                    <button class="alert-filter-pill" data-filter="whale_trade" onclick="filterAlerts('whale_trade')">
                        <i data-lucide="fish" style="width: 12px; height: 12px; flex-shrink: 0;"></i>
                        <span>Whales</span>
                    </button>
                    <button class="alert-filter-pill" data-filter="liquidation_cascade" onclick="filterAlerts('liquidation_cascade')">
                        <i data-lucide="droplets" style="width: 12px; height: 12px; flex-shrink: 0;"></i>
                        <span>Liqs</span>
                    </button>
                    <button class="alert-filter-pill" data-filter="signal" onclick="filterAlerts('signal')">
                        <i data-lucide="target" style="width: 12px; height: 12px; flex-shrink: 0;"></i>
                        <span>Signals</span>
                    </button>
                    <button class="alert-filter-pill" data-filter="regime_change" onclick="filterAlerts('regime_change')">
                        <i data-lucide="activity" style="width: 12px; height: 12px; flex-shrink: 0;"></i>
                        <span>Regime</span>
                    </button>
                </div>
                <div id="alertsList">
                    <!-- Alerts will be populated here -->
                </div>
            </div>
        </div>

        <!-- Crypto Performance Tracker Tab -->
        <div class="tab-content" id="performanceTab">
            <!-- Performance Controls -->
            <!-- Bitcoin Beta Chart with Timeframe Controls -->
            <div class="mobile-card" id="betaChartCard">
                <div class="card-header" style="display: flex; justify-content: space-between; align-items: center;">
                    <h2 class="card-title"><span id="chartTimeframeLabel">4H</span> Bitcoin Beta</h2>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <button id="fullscreenBtn" onclick="toggleChartFullscreen()" style="
                            padding: 8px;
                            background: rgba(251, 191, 36, 0.15);
                            border: 1px solid rgba(251, 191, 36, 0.4);
                            border-radius: 6px;
                            color: #fbbf24;
                            cursor: pointer;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            transition: all 0.2s ease;
                            min-width: 40px;
                            min-height: 40px;
                        " onmouseover="this.style.background='rgba(251, 191, 36, 0.25)'" onmouseout="this.style.background='rgba(251, 191, 36, 0.15)'">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
                            </svg>
                        </button>
                    </div>
                </div>

                <!-- Timeframe & Auto-Refresh Controls -->
                <div id="timeframeControlsWrapper" style="padding: 12px 0; border-bottom: 1px solid rgba(255,255,255,0.05);">
                    <!-- Horizontal Timeframe Chips (Perfect Grid Alignment) -->
                    <div id="timeframeScroller" style="
                        display: flex;
                        gap: 4px;
                        justify-content: space-between;
                        padding: 0 0 12px 0;
                        margin-bottom: 12px;
                        align-items: center;
                    ">
                        <button onclick="selectTimeframe(this, 0.0833)" class="tf-chip" data-tf="0.0833">5m</button>
                        <button onclick="selectTimeframe(this, 0.25)" class="tf-chip" data-tf="0.25">15m</button>
                        <button onclick="selectTimeframe(this, 0.5)" class="tf-chip" data-tf="0.5">30m</button>
                        <button onclick="selectTimeframe(this, 1)" class="tf-chip" data-tf="1">1H</button>
                        <button onclick="selectTimeframe(this, 4)" class="tf-chip tf-chip-active" data-tf="4">4H</button>
                        <button onclick="selectTimeframe(this, 12)" class="tf-chip" data-tf="12">12H</button>
                        <button onclick="selectTimeframe(this, 24)" class="tf-chip" data-tf="24">24H</button>
                    </div>

                    <!-- Auto-Refresh Status Row (Perfect Alignment) -->
                    <div style="
                        display: flex;
                        align-items: center;
                        justify-content: space-between;
                        gap: 12px;
                        height: 28px;
                    ">
                        <div style="
                            display: flex;
                            align-items: center;
                            gap: 8px;
                            flex-grow: 1;
                            min-width: 0;
                        ">
                            <span id="refreshIndicator" style="
                                width: 6px;
                                height: 6px;
                                border-radius: 50%;
                                background: var(--accent-positive);
                                animation: pulse 2s infinite;
                                flex-shrink: 0;
                            "></span>
                            <span style="
                                font-size: 10px;
                                color: var(--text-secondary);
                                font-family: 'IBM Plex Mono', monospace;
                                white-space: nowrap;
                                overflow: hidden;
                                text-overflow: ellipsis;
                                line-height: 1.4;
                            ">
                                <span id="refreshStatus" style="color: var(--accent-positive); font-weight: 600;">ON</span>
                                <span style="opacity: 0.6;">  2m  </span>
                                <span id="lastUpdated" style="color: var(--text-accent); font-weight: 500;">--:--</span>
                            </span>
                        </div>
                        <button onclick="toggleAutoRefresh()" id="refreshToggle" style="
                            padding: 6px 16px;
                            font-size: 10px;
                            font-family: 'IBM Plex Mono', monospace;
                            background: rgba(16, 185, 129, 0.15);
                            border: 1px solid var(--accent-positive);
                            border-radius: 6px;
                            color: var(--accent-positive);
                            cursor: pointer;
                            font-weight: 600;
                            min-height: 28px;
                            flex-shrink: 0;
                            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
                            line-height: 1;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                        ">ON</button>
                    </div>
                </div>
                <style>
                    /* ========================================
                       TIMEFRAME CHIP ANIMATION
                       ======================================== */
                    @keyframes pulse {
                        0%, 100% { opacity: 1; }
                        50% { opacity: 0.4; }
                    }

                    @keyframes glow-pulse {
                        0%, 100% {
                            box-shadow: 0 0 12px rgba(251, 191, 36, 0.3),
                                        0 0 4px rgba(251, 191, 36, 0.2) inset;
                        }
                        50% {
                            box-shadow: 0 0 16px rgba(251, 191, 36, 0.5),
                                        0 0 6px rgba(251, 191, 36, 0.3) inset;
                        }
                    }

                    /* ========================================
                       TIMEFRAME CHIP STYLES
                       Pixel-perfect alignment for all 7 chips
                       ======================================== */
                    .tf-chip {
                        /* Layout & Sizing - 44px min for Apple HIG touch targets */
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        padding: 0 10px;
                        min-height: 44px;
                        min-width: 44px;
                        flex: 1 1 0; /* Equal width distribution */

                        /* Typography */
                        font-size: 10px;
                        font-family: 'IBM Plex Mono', monospace;
                        font-weight: 600;
                        letter-spacing: 0.3px;
                        line-height: 1;
                        white-space: nowrap;

                        /* Visual Design */
                        background: rgba(255, 255, 255, 0.05);
                        border: 1px solid rgba(255, 255, 255, 0.1);
                        border-radius: 14px;
                        color: var(--text-secondary);

                        /* Behavior */
                        cursor: pointer;
                        user-select: none;
                        -webkit-tap-highlight-color: transparent;

                        /* Transitions */
                        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
                    }

                    /* Active State - Amber Glow */
                    .tf-chip-active {
                        background: linear-gradient(135deg,
                            rgba(251, 191, 36, 0.25) 0%,
                            rgba(251, 191, 36, 0.15) 100%
                        );
                        border: 1px solid #fbbf24;
                        color: #fbbf24;
                        font-weight: 700;
                        animation: glow-pulse 2s ease-in-out infinite;
                    }

                    /* Hover State (Desktop) */
                    @media (hover: hover) {
                        .tf-chip:not(.tf-chip-active):hover {
                            background: rgba(255, 255, 255, 0.08);
                            border-color: rgba(251, 191, 36, 0.4);
                            color: rgba(251, 191, 36, 0.9);
                            transform: translateY(-1px);
                        }
                    }

                    /* Touch Feedback */
                    .tf-chip:active {
                        transform: scale(0.95);
                    }

                    .tf-chip-active:active {
                        transform: scale(0.97);
                    }

                    /* Hide scrollbar (fallback for overflow) */
                    #timeframeScroller::-webkit-scrollbar {
                        display: none;
                    }

                    #timeframeScroller {
                        -ms-overflow-style: none;
                        scrollbar-width: none;
                    }

                    /* ========================================
                       FULLSCREEN TIMEFRAME CONTROLS
                       Compact chips below header
                       ======================================== */
                    .fullscreen-chart #timeframeControlsWrapper {
                        padding: 8px 16px 12px;
                        border-bottom: 1px solid rgba(255,255,255,0.05);
                        background: var(--bg-primary);
                    }

                    /* Hide auto-refresh status in fullscreen to save space */
                    .fullscreen-chart #timeframeControlsWrapper > div:last-child {
                        display: none !important;
                    }

                    /* Fullscreen chips - maintain 44px height for touch, compact width */
                    .fullscreen-chart .tf-chip {
                        min-height: 44px;
                        padding: 0 8px;
                        font-size: 9px;
                        min-width: 40px;
                    }

                    /* ========================================
                       RESPONSIVE ADJUSTMENTS
                       ======================================== */
                    @media (max-width: 360px) {
                        /* Tighter spacing for very small screens - maintain 44px height */
                        #timeframeScroller {
                            gap: 3px;
                        }

                        .tf-chip {
                            padding: 0 6px;
                            min-width: 40px;
                            min-height: 44px; /* Apple HIG compliance */
                            font-size: 9px;
                        }
                    }

                    @media (min-width: 768px) {
                        /* More comfortable spacing on tablets */
                        #timeframeScroller {
                            gap: 8px;
                        }

                        .tf-chip {
                            padding: 0 12px;
                            min-width: 48px;
                            font-size: 11px;
                        }
                    }
                </style>
                <div id="performanceChart" style="width: 100%; height: 350px; position: relative;">
                    <!-- Current Price HUD (Optimization #2) - Shows in fullscreen only -->
                    <div class="price-hud" id="priceHud">
                        <div class="price-hud-symbol" id="hudSymbol">BTC</div>
                        <div class="price-hud-price" id="hudPrice">$86,710</div>
                        <div class="price-hud-change" id="hudChange">
                            <span id="hudChangeValue">-2.50%</span>
                            <span id="hudChangeArrow"></span>
                        </div>
                    </div>
                    <!-- Chart will be rendered here - skeleton loader -->
                    <div class="skeleton skeleton-chart" style="margin: 10px 0;"></div>
                </div>
                <!-- Chart Label Controls -->
                <div id="chartLabelControls" style="display: flex; gap: 8px; margin-top: 10px; justify-content: flex-end;">
                    <button id="toggleLabelsBtn" onclick="toggleChartLabels()" style="
                        padding: 6px 12px;
                        background: rgba(251, 191, 36, 0.15);
                        border: 1px solid rgba(251, 191, 36, 0.4);
                        border-radius: 6px;
                        color: #fbbf24;
                        font-family: 'IBM Plex Mono', monospace;
                        font-size: 10px;
                        cursor: pointer;
                        transition: all 0.2s ease;
                    " onmouseover="this.style.background='rgba(251, 191, 36, 0.25)'" onmouseout="this.style.background='rgba(251, 191, 36, 0.15)'">
                        <span id="toggleLabelsIcon"></span> LABELS: ON
                    </button>
                    <button id="toggleTopBottomBtn" onclick="toggleTopBottomOnly()" style="
                        padding: 6px 12px;
                        background: rgba(6, 182, 212, 0.15);
                        border: 1px solid rgba(6, 182, 212, 0.4);
                        border-radius: 6px;
                        color: #06b6d4;
                        font-family: 'IBM Plex Mono', monospace;
                        font-size: 10px;
                        cursor: pointer;
                        transition: all 0.2s ease;
                    " onmouseover="this.style.background='rgba(6, 182, 212, 0.25)'" onmouseout="this.style.background='rgba(6, 182, 212, 0.15)'">
                        TOP/BOTTOM 5: OFF
                    </button>
                </div>
                <!-- Collapsible Legend -->
                <div id="performanceChartLegend" style="margin-top: 12px;">
                    <!-- Legend will be rendered here -->
                </div>
            </div>

            <!-- Beta Rankings -->
            <div class="mobile-card">
                <div class="card-header">
                    <h2 class="card-title">Beta Rankings</h2>
                    <select id="mtfClusterSelector" style="background: var(--bg-secondary); border: 1px solid var(--border-light); border-radius: 6px; padding: 6px 12px; color: var(--text-primary); font-size: 12px;" onchange="loadMTFRankings()">
                        <option value="day_trading">Day Trading</option>
                        <option value="scalping">Scalping</option>
                        <option value="swing_trading">Swing Trading</option>
                        <option value="comprehensive">Comprehensive</option>
                    </select>
                </div>
                <div id="mtfRankingsList" style="display: flex; flex-direction: column; gap: 8px;">
                    <!-- Beta rankings will be populated here -->
                    <div class="loading" style="text-align: center; padding: 40px;">
                        <div class="spinner" style="width: 32px; height: 32px; margin: 0 auto;"></div>
                    </div>
                </div>
            </div>

            <!-- Beta Performance (Combined Overview + Beta Analysis) -->
            <div class="mobile-card">
                <div class="card-header">
                    <h2 class="card-title">Beta Performance</h2>
                    <div style="display: flex; gap: 6px;">
                        <span id="timeframeBadge" class="card-badge" style="background: rgba(251, 191, 36, 0.2); color: var(--accent-warning);">
                            4H
                        </span>
                        <span class="card-badge" style="background: rgba(255, 191, 0, 0.2); color: var(--accent-warning);">
                            
                        </span>
                    </div>
                </div>

                <!-- Performance Metrics -->
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; margin-bottom: 16px;">
                    <div class="overview-metric">
                        <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">BTC <span id="btcTimeframeLabel">4H</span> CHANGE</div>
                        <div id="perfBtcChange" style="font-size: 20px; font-weight: 700; color: var(--text-primary);">--</div>
                    </div>
                    <div class="overview-metric">
                        <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">SYMBOLS TRACKED</div>
                        <div id="perfSymbolCount" style="font-size: 20px; font-weight: 700; color: var(--text-primary);">--</div>
                    </div>
                    <div class="overview-metric">
                        <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">OUTPERFORMERS</div>
                        <div id="perfOutperformers" style="font-size: 20px; font-weight: 700; color: var(--accent-positive);">--</div>
                    </div>
                    <div class="overview-metric">
                        <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">UNDERPERFORMERS</div>
                        <div id="perfUnderperformers" style="font-size: 20px; font-weight: 700; color: var(--accent-negative);">--</div>
                    </div>
                </div>

                <!-- Divider -->
                <div style="height: 1px; background: linear-gradient(90deg, transparent, var(--border-light), transparent); margin: 16px 0;"></div>

                <!-- Beta Statistics -->
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; margin-bottom: 16px;">
                    <div class="overview-metric">
                        <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">BETA COEFFICIENT</div>
                        <div id="betaCoefficient" style="font-size: 20px; font-weight: 700; color: var(--text-primary);">--</div>
                    </div>
                    <div class="overview-metric">
                        <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">CORRELATION</div>
                        <div id="btcCorrelation" style="font-size: 20px; font-weight: 700; color: var(--text-primary);">--</div>
                    </div>
                    <div class="overview-metric">
                        <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">MARKET REGIME</div>
                        <div id="betaMarketRegime" style="font-size: 14px; font-weight: 600; padding: 4px 8px; border-radius: 6px; text-align: center; background: rgba(255, 191, 0, 0.1); color: var(--text-primary);">--</div>
                    </div>
                    <div class="overview-metric">
                        <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">VOLATILITY RATIO</div>
                        <div id="volatilityRatio" style="font-size: 20px; font-weight: 700; color: var(--text-primary);">--</div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Bottom Navigation -->
    <nav class="bottom-nav" role="navigation" aria-label="Main navigation" aria-hidden="false">
        <button class="nav-item active" onclick="switchTab('dashboard')" aria-label="Market Dashboard" aria-current="page">
            <i data-lucide="bar-chart-2" class="nav-icon"></i>
            <span class="nav-label">Market</span>
        </button>
        <button class="nav-item" onclick="switchTab('alpha')" aria-label="Alpha Pulse">
            <i data-lucide="trending-up" class="nav-icon"></i>
            <span class="nav-label">Alpha</span>
        </button>
        <button class="nav-item" onclick="switchTab('performance')" aria-label="Bitcoin Beta Tracker">
            <span class="nav-icon" style="font-size: 20px; font-weight: 700;"></span>
            <span class="nav-label">Beta</span>
        </button>
        <button class="nav-item" onclick="switchTab('signals')" aria-label="Trading Signals">
            <i data-lucide="activity" class="nav-icon"></i>
            <span class="nav-label">Signals</span>
        </button>
        <button class="nav-item" onclick="switchTab('alerts')" id="alertsNavBtn" aria-label="Alerts">
            <i data-lucide="bell" class="nav-icon"></i>
            <span class="nav-label">Alerts</span>
            <span id="alertsBadge" class="notification-badge hidden">0</span>
        </button>
    </nav>

    <!-- Settings Panel -->
    <div id="settingsPanel" class="settings-panel" style="position: fixed; top: 0; right: -100%; width: 320px; height: 100vh; background: var(--bg-primary); border-left: 1px solid var(--border-light); z-index: 1000; transition: right 0.3s ease; overflow-y: auto;">
        <div class="settings-header" style="padding: 20px; border-bottom: 1px solid var(--border-light); display: flex; justify-content: space-between; align-items: center;">
            <h3 style="color: var(--text-primary); font-size: 18px; font-weight: 700; margin: 0;">Settings</h3>
            <button onclick="toggleSettings()" style="background: none; border: none; cursor: pointer;">
                <i data-lucide="x" style="width: 20px; height: 20px; color: var(--text-secondary);"></i>
            </button>
        </div>
        
        <div class="settings-content" style="padding: 20px;">
            <!-- Display Preferences -->
            <div class="settings-section" style="margin-bottom: 24px;">
                <h4 style="color: var(--text-primary); font-size: 14px; font-weight: 600; margin-bottom: 12px; text-transform: uppercase; letter-spacing: 0.5px;">Display</h4>
                
                <div class="setting-item" style="margin-bottom: 12px;">
                    <label style="display: flex; justify-content: space-between; align-items: center; color: var(--text-secondary); font-size: 13px;">
                        Auto Refresh
                        <select id="refreshRate" style="background: var(--bg-secondary); border: 1px solid var(--border-light); border-radius: 4px; padding: 4px 8px; color: var(--text-primary); font-size: 12px;" onchange="updateRefreshRate()">
                            <option value="0">Manual</option>
                            <option value="30000">30 seconds</option>
                            <option value="60000" selected>1 minute</option>
                            <option value="120000">2 minutes</option>
                            <option value="300000">5 minutes</option>
                        </select>
                    </label>
                </div>
                
                <div class="setting-item" style="margin-bottom: 12px;">
                    <label style="display: flex; justify-content: space-between; align-items: center; color: var(--text-secondary); font-size: 13px;">
                        Default Sort
                        <select id="defaultSort" style="background: var(--bg-secondary); border: 1px solid var(--border-light); border-radius: 4px; padding: 4px 8px; color: var(--text-primary); font-size: 12px;" onchange="updateDefaultSort()">
                            <option value="score" selected>Alpha Score</option>
                            <option value="change">Price Change</option>
                            <option value="symbol">Symbol Name</option>
                        </select>
                    </label>
                </div>
                
                <div class="setting-item" style="margin-bottom: 12px;">
                    <label style="display: flex; justify-content: space-between; align-items: center; color: var(--text-secondary); font-size: 13px;">
                        Symbols Limit
                        <select id="symbolsLimit" style="background: var(--bg-secondary); border: 1px solid var(--border-light); border-radius: 4px; padding: 4px 8px; color: var(--text-primary); font-size: 12px;" onchange="updateSymbolsLimit()">
                            <option value="10">10 symbols</option>
                            <option value="20" selected>20 symbols</option>
                            <option value="50">50 symbols</option>
                            <option value="100">All symbols</option>
                        </select>
                    </label>
                </div>

                <div class="setting-item" style="margin-bottom: 12px;">
                    <label style="display: flex; justify-content: space-between; align-items: center; color: var(--text-secondary); font-size: 13px;">
                        Show News Ticker
                        <input type="checkbox" id="showNewsTicker" checked style="accent-color: var(--accent-primary);" onchange="toggleNewsTicker()">
                    </label>
                </div>

                <div class="setting-item" style="margin-bottom: 12px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; color: var(--text-secondary); font-size: 13px;">
                        <span>Theme</span>
                        <div id="themeToggle" class="theme-toggle-group">
                            <button type="button" class="theme-toggle-btn" data-theme="dark" onclick="handleThemeSelect('dark')" aria-label="Dark mode">
                                <i data-lucide="moon" style="width: 16px; height: 16px;"></i>
                            </button>
                            <button type="button" class="theme-toggle-btn active" data-theme="system" onclick="handleThemeSelect('system')" aria-label="System preference">
                                <i data-lucide="monitor" style="width: 16px; height: 16px;"></i>
                            </button>
                            <button type="button" class="theme-toggle-btn" data-theme="light" onclick="handleThemeSelect('light')" aria-label="Light mode">
                                <i data-lucide="sun" style="width: 16px; height: 16px;"></i>
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Alert Settings -->
            <div class="settings-section" style="margin-bottom: 24px;">
                <h4 style="color: var(--text-primary); font-size: 14px; font-weight: 600; margin-bottom: 12px; text-transform: uppercase; letter-spacing: 0.5px;">Alerts</h4>
                
                <div class="setting-item" style="margin-bottom: 12px;">
                    <label style="display: flex; justify-content: space-between; align-items: center; color: var(--text-secondary); font-size: 13px;">
                        Min Alpha Score
                        <select id="minConfluence" style="background: var(--bg-secondary); border: 1px solid var(--border-light); border-radius: 4px; padding: 4px 8px; color: var(--text-primary); font-size: 12px;" onchange="updateMinConfluence()">
                            <option value="50">50+</option>
                            <option value="60">60+</option>
                            <option value="70" selected>70+</option>
                            <option value="80">80+</option>
                        </select>
                    </label>
                </div>
                
                <div class="setting-item" style="margin-bottom: 12px;">
                    <label style="display: flex; justify-content: space-between; align-items: center; color: var(--text-secondary); font-size: 13px;">
                        Sound Alerts
                        <input type="checkbox" id="soundAlerts" style="accent-color: var(--accent-primary);" onchange="updateSoundAlerts()">
                    </label>
                </div>
            </div>
            
            <!-- Dashboard Cards -->
            <div class="settings-section" style="margin-bottom: 24px;">
                <h4 style="color: var(--text-primary); font-size: 14px; font-weight: 600; margin-bottom: 12px; text-transform: uppercase; letter-spacing: 0.5px;">Visible Cards</h4>
                
                <div class="setting-item" style="margin-bottom: 8px;">
                    <label style="display: flex; justify-content: space-between; align-items: center; color: var(--text-secondary); font-size: 13px;">
                        Market Overview
                        <input type="checkbox" id="showMarketOverview" checked style="accent-color: var(--accent-primary);" onchange="toggleCard('marketOverview')">
                    </label>
                </div>
                
                <div class="setting-item" style="margin-bottom: 8px;">
                    <label style="display: flex; justify-content: space-between; align-items: center; color: var(--text-secondary); font-size: 13px;">
                        Top Movers
                        <input type="checkbox" id="showTopMovers" checked style="accent-color: var(--accent-primary);" onchange="toggleCard('topMovers')">
                    </label>
                </div>
            </div>

            <!-- Actions -->
            <div class="settings-section">
                <button onclick="resetSettings()" style="width: 100%; background: var(--bg-secondary); border: 1px solid var(--border-light); border-radius: 8px; padding: 12px; color: var(--text-primary); font-size: 13px; cursor: pointer; margin-bottom: 12px;">
                    Reset to Defaults
                </button>
                <button onclick="exportSettings()" style="width: 100%; background: var(--accent-primary); border: none; border-radius: 8px; padding: 12px; color: white; font-size: 13px; cursor: pointer;">
                    Export Settings
                </button>
            </div>

            <!-- Help Link -->
            <div class="settings-section" style="margin-top: 24px; padding-top: 16px; border-top: 1px solid var(--border-light);">
                <a href="https://virtuosocrypto.com/academy/dash101" target="_blank" rel="noopener noreferrer" style="display: flex; align-items: center; justify-content: center; gap: 8px; color: var(--accent-warning); text-decoration: none; font-size: 13px; font-weight: 600; padding: 10px; border-radius: 8px; transition: all 0.2s ease; background: rgba(251, 191, 36, 0.08);" onmouseover="this.style.background='rgba(251, 191, 36, 0.15)'" onmouseout="this.style.background='rgba(251, 191, 36, 0.08)'">
                    <i data-lucide="book-open" style="width: 16px; height: 16px;"></i>
                    Dashboard Guide
                    <i data-lucide="external-link" style="width: 14px; height: 14px; opacity: 0.7;"></i>
                </a>
            </div>
        </div>
    </div>
    
    <!-- Settings Overlay -->
    <div id="settingsOverlay" class="settings-overlay" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.5); z-index: 999; opacity: 0; visibility: hidden; transition: all 0.3s ease;" onclick="toggleSettings()"></div>

    <script>
        // Initialize Lucide icons - wrapped in try-catch to prevent breaking the app if CDN fails
        try {
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            } else {
                console.warn('Lucide not loaded yet, icons will be initialized later');
            }
        } catch (e) {
            console.warn('Lucide icon initialization failed:', e);
        }

        // ========================================
        // THEME MANAGEMENT SYSTEM
        // ========================================
        const THEME_STORAGE_KEY = 'virtuoso-theme';

        // Forward declarations to avoid TDZ errors (these are reassigned later)
        var lwChart = null;
        var lwChartVisibleRange = null;

        function initTheme() {
            // Priority: localStorage > system preference > dark default
            const savedTheme = localStorage.getItem(THEME_STORAGE_KEY);

            if (savedTheme) {
                setTheme(savedTheme, false); // false = no transition on initial load
            } else if (window.matchMedia('(prefers-color-scheme: light)').matches) {
                setTheme('light', false);
            } else {
                setTheme('dark', false);
            }

            // Listen for system preference changes (only if no saved preference)
            window.matchMedia('(prefers-color-scheme: light)').addEventListener('change', (e) => {
                if (!localStorage.getItem(THEME_STORAGE_KEY)) {
                    setTheme(e.matches ? 'light' : 'dark', true);
                    syncThemeSelect();
                }
            });

            // Sync dropdown after DOM is ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', syncThemeSelect);
            } else {
                syncThemeSelect();
            }
        }

        function setTheme(theme, animate = true) {
            // Disable transitions on initial load to prevent flash
            if (!animate) {
                document.documentElement.classList.add('no-transition');
            }

            document.documentElement.setAttribute('data-theme', theme);

            // Update meta theme-color for browser chrome (warm cream for light mode)
            const themeColor = theme === 'light' ? '#fff8e0' : '#000000';
            const metaThemeColor = document.querySelector('meta[name="theme-color"]');
            if (metaThemeColor) {
                metaThemeColor.setAttribute('content', themeColor);
            }

            // Update charts if they exist
            updateChartsTheme(theme);

            // Re-enable transitions
            if (!animate) {
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        document.documentElement.classList.remove('no-transition');
                    });
                });
            } else {
                // Haptic feedback on user-initiated theme change
                if (typeof hapticFeedback === 'function') {
                    hapticFeedback('light');
                }
            }
        }

        function handleThemeSelect(value) {
            if (value === 'system') {
                localStorage.removeItem(THEME_STORAGE_KEY);
                const systemTheme = window.matchMedia('(prefers-color-scheme: light)').matches ? 'light' : 'dark';
                setTheme(systemTheme, true);
            } else {
                setTheme(value, true);
                localStorage.setItem(THEME_STORAGE_KEY, value);
            }
            syncThemeToggle(value);
            if (typeof hapticFeedback === 'function') hapticFeedback('light');
        }

        function syncThemeToggle(activeValue) {
            const buttons = document.querySelectorAll('.theme-toggle-btn');
            if (!buttons.length) return;

            const value = activeValue || localStorage.getItem(THEME_STORAGE_KEY) || 'system';

            buttons.forEach(btn => {
                if (btn.dataset.theme === value) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }

        // Alias for backwards compatibility
        function syncThemeSelect() {
            syncThemeToggle();
        }

        function updateChartsTheme(theme) {
            // Update LightweightCharts colors if chart exists
            if (typeof lwChart !== 'undefined' && lwChart) {
                const chartColors = theme === 'light' ? {
                    layout: {
                        background: { color: '#fff8e0' },
                        textColor: '#4a5568'
                    },
                    grid: {
                        vertLines: { color: 'rgba(180, 83, 9, 0.08)' },
                        horzLines: { color: 'rgba(180, 83, 9, 0.08)' }
                    },
                    crosshair: {
                        vertLine: { color: 'rgba(180, 83, 9, 0.5)', labelBackgroundColor: '#b45309' },
                        horzLine: { color: 'rgba(180, 83, 9, 0.5)', labelBackgroundColor: '#fff3cc' }
                    },
                    rightPriceScale: { borderColor: 'rgba(180, 83, 9, 0.2)' },
                    timeScale: { borderColor: 'rgba(180, 83, 9, 0.2)' }
                } : {
                    layout: {
                        background: { color: '#0a0a0a' },
                        textColor: '#9ca3af'
                    },
                    grid: {
                        vertLines: { color: 'rgba(255, 191, 0, 0.06)' },
                        horzLines: { color: 'rgba(255, 191, 0, 0.06)' }
                    },
                    crosshair: {
                        vertLine: { color: 'rgba(251, 191, 36, 0.4)', labelBackgroundColor: '#fbbf24' },
                        horzLine: { color: 'rgba(251, 191, 36, 0.4)', labelBackgroundColor: '#333' }
                    },
                    rightPriceScale: { borderColor: 'rgba(255, 191, 0, 0.15)' },
                    timeScale: { borderColor: 'rgba(255, 191, 0, 0.15)' }
                };

                try {
                    lwChart.applyOptions(chartColors);
                } catch (e) {
                    console.debug('Chart theme update skipped:', e.message);
                }
            }
        }

        // Initialize theme immediately
        initTheme();

        // ========================================
        // HAPTIC FEEDBACK SYSTEM (Optimization #3)
        // ========================================
        function hapticFeedback(type = 'light') {
            // Check if Vibration API is available
            if (!navigator.vibrate) return;

            try {
                switch(type) {
                    case 'light':
                        // Light tap for buttons, selections (10ms)
                        navigator.vibrate(10);
                        break;
                    case 'medium':
                        // Medium bump for important actions (20ms)
                        navigator.vibrate(20);
                        break;
                    case 'success':
                        // Double tap for success confirmations
                        navigator.vibrate([10, 50, 10]);
                        break;
                    case 'error':
                        // Triple tap for errors
                        navigator.vibrate([10, 50, 10, 50, 10]);
                        break;
                    default:
                        navigator.vibrate(10);
                }
            } catch (e) {
                // Silently fail if vibration not supported
                console.debug('Haptic feedback not available');
            }
        }

        // Tab switching
        function switchTab(tabName) {
            hapticFeedback('light'); // Haptic feedback on tab switch

            // Force show bottom nav on tab switch
            if (window.bottomNavController) {
                window.bottomNavController.forceShow();
            }

            // Update nav items
            document.querySelectorAll('.nav-item').forEach(item => {
                item.classList.remove('active');
            });

            // Find and activate the clicked nav item
            const navItems = document.querySelectorAll('.nav-item');
            navItems.forEach(item => {
                const onclick = item.getAttribute('onclick');
                if (onclick && onclick.includes(`'${tabName}'`)) {
                    item.classList.add('active');
                    item.setAttribute('aria-current', 'page');
                } else {
                    item.removeAttribute('aria-current');
                }
            });

            // Update content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(tabName + 'Tab').classList.add('active');

            // Clear alert badge when viewing alerts tab
            if (tabName === 'alerts') {
                // Mark current time as last seen to clear badge
                lastSeenAlertTimestamp = Math.floor(Date.now() / 1000);
                localStorage.setItem('lastSeenAlertTimestamp', lastSeenAlertTimestamp.toString());
                updateAlertBadge(0);
            }

            // Load tab-specific data
            loadTabData(tabName);
        }

        // Navigate to Alerted Signals section in Signals tab
        function navigateToAlertedSignals() {
            // Switch to Signals tab
            switchTab('signals');

            // Scroll to the Alerted Signals card after a brief delay for tab switch
            setTimeout(() => {
                const alertedCard = document.getElementById('alertedSignalsCard');
                if (alertedCard && alertedCard.style.display !== 'none') {
                    alertedCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    // Add a brief highlight effect
                    alertedCard.style.boxShadow = '0 0 0 2px var(--accent-positive)';
                    setTimeout(() => {
                        alertedCard.style.boxShadow = '';
                    }, 1500);
                }
            }, 100);
        }

        // Load tab data
        function loadTabData(tabName) {
            switch(tabName) {
                case 'dashboard':
                    loadDashboardData();
                    break;
                case 'signals':
                    loadSignalsData();
                    break;
                case 'alpha':
                    loadAlphaData();
                    break;
                case 'alerts':
                    loadAlertsData();
                    break;
                case 'performance':
                    loadPerformanceData();
                    loadBetaData();
                    loadMTFRankings();
                    break;
            }
        }

        // Performance-optimized pull to refresh
        let startY = 0;
        let isPulling = false;
        let rafId = null;
        const pullToRefresh = document.getElementById('pullToRefresh');
        const mainContent = document.querySelector('.main-content');

        // Use passive event listeners for better performance
        mainContent.addEventListener('touchstart', (e) => {
            if (window.scrollY === 0) {
                startY = e.touches[0].pageY;
                isPulling = true;
            }
        }, { passive: true });

        mainContent.addEventListener('touchmove', (e) => {
            if (!isPulling) return;
            
            // Cancel previous animation frame
            if (rafId) {
                cancelAnimationFrame(rafId);
            }
            
            rafId = requestAnimationFrame(() => {
                const currentY = e.touches[0].pageY;
                const pullDistance = currentY - startY;

                // Lowered threshold for better touch response (70px vs 100px)
                if (pullDistance > 0 && pullDistance < 70) {
                    pullToRefresh.classList.add('active');
                    // Use transform for better performance (appear after 40px pull)
                    pullToRefresh.style.transform = `translate3d(0, ${Math.min(pullDistance - 40, 0)}px, 0)`;
                }
            });
        }, { passive: true });

        mainContent.addEventListener('touchend', () => {
            if (rafId) {
                cancelAnimationFrame(rafId);
                rafId = null;
            }
            if (isPulling && pullToRefresh.classList.contains('active')) {
                refreshData();
            }
            isPulling = false;
            pullToRefresh.classList.remove('active');
            pullToRefresh.style.transform = '';
        }, { passive: true });

        // Data validation helper functions
        function safeExtractValue(data, fallback = '', debug = false) {
            if (debug) console.log('Extracting value from:', data);
            
            if (data === null || data === undefined) return fallback;
            
            // If it's already a primitive value
            if (typeof data === 'string' || typeof data === 'number' || typeof data === 'boolean') {
                return String(data).replace(/[{}",]/g, '').trim();
            }
            
            // If it's an object, try to extract meaningful value
            if (typeof data === 'object') {
                // Try common property names for regime/status
                if (data.regime) return String(data.regime).replace(/[{}",]/g, '').trim();
                if (data.status) return String(data.status).replace(/[{}",]/g, '').trim();
                if (data.value) return String(data.value).replace(/[{}",]/g, '').trim();
                
                // Get first non-null value from object
                const values = Object.values(data).filter(v => v !== null && v !== undefined);
                if (values.length > 0) {
                    return String(values[0]).replace(/[{}",]/g, '').trim();
                }
            }
            
            return fallback;
        }

        // Perpetuals Pulse - Fetch and Update from crypto-perps-tracker
        async function fetchPerpetualsPulse() {
            try {
                // Proxy through Virtuoso API to avoid CORS issues
                // The API endpoint proxies to perps-tracker on port 8050
                const response = await fetch('/api/dashboard/perpetuals-pulse');

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const data = await response.json();
                console.log('[PERPS] Received data:', data);

                if (data.status === 'success') {
                    updatePerpetualsPulse(data);
                } else {
                    console.warn('[PERPS] API returned non-success:', data);
                }
            } catch (error) {
                console.error('[PERPS] Failed to fetch perpetuals pulse:', error);
                // Show error state but don't hide the card
                document.getElementById('perpsLoadingState').style.display = 'none';
            }
        }

        function updatePerpetualsPulse(data) {
            // === FUNDING RATE ===
            const fundingRate = data.funding_rate || 0;
            const fundingEl = document.getElementById('perpsFundingRate');
            const fundingSentimentEl = document.getElementById('perpsFundingSentiment');

            fundingEl.textContent = (fundingRate >= 0 ? '+' : '') + fundingRate.toFixed(4) + '%';

            // Color based on sentiment
            if (fundingRate > 0.02) {
                fundingEl.style.color = 'var(--accent-positive)';
            } else if (fundingRate < -0.02) {
                fundingEl.style.color = 'var(--accent-negative)';
            } else {
                fundingEl.style.color = 'var(--text-primary)';
            }

            fundingSentimentEl.textContent = data.funding_sentiment || 'NEUTRAL';
            if (data.funding_strength && data.funding_strength !== 'WEAK') {
                fundingSentimentEl.textContent += ' (' + data.funding_strength + ')';
            }

            // === LONG/SHORT RATIO ===
            const longPct = data.long_pct || 50;
            const shortPct = data.short_pct || 50;

            document.getElementById('perpsLongPct').textContent = longPct.toFixed(1) + '%';
            document.getElementById('perpsShortPct').textContent = shortPct.toFixed(1) + '%';

            const lsLabelEl = document.getElementById('perpsLSLabel');
            if (longPct > 55) {
                lsLabelEl.textContent = 'LONGS HEAVY';
                lsLabelEl.style.color = 'var(--accent-positive)';
            } else if (shortPct > 55) {
                lsLabelEl.textContent = 'SHORTS HEAVY';
                lsLabelEl.style.color = 'var(--accent-negative)';
            } else {
                lsLabelEl.textContent = 'BALANCED';
                lsLabelEl.style.color = 'var(--text-secondary)';
            }

            // === BASIS STATUS ===
            const basisStatus = data.basis_status || 'NEUTRAL';
            const basisPct = data.basis_pct || 0;
            const basisStatusEl = document.getElementById('perpsBasisStatus');
            const basisPctEl = document.getElementById('perpsBasisPct');

            basisStatusEl.textContent = basisStatus;
            basisPctEl.textContent = (basisPct >= 0 ? '+' : '') + basisPct.toFixed(3) + '%';

            if (basisStatus === 'CONTANGO') {
                basisStatusEl.style.background = 'rgba(76, 175, 80, 0.2)';
                basisStatusEl.style.color = 'var(--accent-positive)';
            } else if (basisStatus === 'BACKWARDATION') {
                basisStatusEl.style.background = 'rgba(244, 67, 54, 0.2)';
                basisStatusEl.style.color = 'var(--accent-negative)';
            } else {
                basisStatusEl.style.background = 'rgba(255, 191, 0, 0.15)';
                basisStatusEl.style.color = 'var(--text-primary)';
            }

            // === OPEN INTEREST & VOLUME ===
            const oi = data.total_open_interest || 0;
            const vol = data.total_volume_24h || 0;

            document.getElementById('perpsOpenInterest').textContent = formatMarketCap(oi);
            document.getElementById('perpsVolume').textContent = formatMarketCap(vol);

            // === CEX/DEX DISTRIBUTION ===
            const cexPct = data.cex_pct || 90;
            const dexPct = data.dex_pct || 10;

            const cexBar = document.getElementById('perpsCexBar');
            const dexBar = document.getElementById('perpsDexBar');

            cexBar.style.width = cexPct + '%';
            cexBar.querySelector('span').textContent = 'CEX ' + cexPct.toFixed(0) + '%';
            dexBar.querySelector('span').textContent = dexPct.toFixed(0) + '%';

            // === EXCHANGE COUNT ===
            const exchangeCount = data.exchange_count || 8;
            document.getElementById('perpsExchangeCount').textContent = exchangeCount + ' CEX/DEX';

            // === PHASE 2: ADVANCED METRICS ===
            // Funding Z-Score
            const fundingZScore = data.funding_zscore || 0;
            const fundingZScoreEl = document.getElementById('perpsFundingZScore');
            fundingZScoreEl.textContent = (fundingZScore > 0 ? '+' : '') + fundingZScore.toFixed(2) + '';

            if (fundingZScore > 0) {
                fundingZScoreEl.style.color = 'var(--accent-negative)';
            } else if (fundingZScore < 0) {
                fundingZScoreEl.style.color = 'var(--accent-positive)';
            } else {
                fundingZScoreEl.style.color = 'var(--text-secondary)';
            }

            // L/S Entropy (Health)
            const lsEntropy = data.ls_entropy || 0.5;
            const lsEntropyEl = document.getElementById('perpsLSEntropy');
            lsEntropyEl.textContent = (lsEntropy * 100).toFixed(0) + '%';

            if (lsEntropy >= 0.7) {
                lsEntropyEl.style.color = 'var(--accent-positive)';
            } else if (lsEntropy < 0.4) {
                lsEntropyEl.style.color = 'var(--accent-negative)';
            } else {
                lsEntropyEl.style.color = 'var(--text-secondary)';
            }

            // === PHASE 2: ACTIVE SIGNALS ===
            const signals = data.signals || [];
            const signalCount = data.signal_count || 0;
            const signalsContainer = document.getElementById('perpsSignalsContainer');
            const signalsList = document.getElementById('perpsSignalsList');

            if (signalCount > 0 && signals.length > 0) {
                signalsContainer.style.display = 'block';
                signalsList.innerHTML = '';

                signals.forEach(signal => {
                    const pill = document.createElement('div');
                    pill.className = `signal-pill-mobile ${signal.direction} ${signal.strength}`;

                    const signalTypeMap = {
                        'funding_divergence': 'Funding Div',
                        'ls_extreme': 'L/S Extreme',
                        'liquidation_risk': 'Liq Risk',
                        'momentum': 'Momentum'
                    };

                    const label = signalTypeMap[signal.signal_type] || signal.signal_type.replace(/_/g, ' ');
                    const strengthBadge = signal.strength.charAt(0).toUpperCase();

                    pill.innerHTML = `<span>${label}</span><span style="opacity: 0.7; font-size: 10px;">${strengthBadge}</span>`;
                    pill.title = `${signal.description} (confidence: ${(signal.confidence * 100).toFixed(0)}%)`;

                    signalsList.appendChild(pill);
                });
            } else {
                signalsContainer.style.display = 'none';
            }

            console.log('[PERPS] UI updated successfully with Phase 2 data');
        }

        // Fetch real L/S positioning from crypto-perps-tracker API
        async function fetchMarketLSR() {
            try {
                const response = await fetch('http://' + window.location.hostname + ':8888/api/aggregated/market-lsr');
                if (!response.ok) throw new Error('LSR API error');
                const data = await response.json();

                // Update the widget with real L/S data
                updateMarketLSR(data);
                console.log('[LSR] Real L/S positioning updated:', data.market_long_pct + '% long');
                return data;
            } catch (error) {
                console.warn('[LSR] Failed to fetch real L/S data, falling back to breadth:', error);
                return null;
            }
        }

        // Update L/S Positioning widget with real exchange data
        function updateMarketLSR(data) {
            const longPct = data.market_long_pct || 50;
            const shortPct = data.market_short_pct || 50;
            const crowdSide = data.crowd_side || 'balanced';

            // Update visual elements
            document.getElementById('bullSection').style.width = longPct + '%';
            document.getElementById('bullSection').textContent = Math.round(longPct) + '%';
            document.getElementById('bearSection').style.width = shortPct + '%';
            document.getElementById('bearSection').textContent = Math.round(shortPct) + '%';
            document.getElementById('upCount').textContent = longPct.toFixed(1) + '%';
            document.getElementById('downCount').textContent = shortPct.toFixed(1) + '%';

            // Update icon and label based on positioning
            const iconContainer = document.getElementById('marketIcon');
            const label = document.getElementById('marketLabel');

            if (crowdSide === 'long' || longPct > 65) {
                iconContainer.innerHTML = '<i data-lucide="trending-up" style="width: 24px; height: 24px;"></i>';
                iconContainer.style.background = 'rgba(76, 175, 80, 0.2)';
                iconContainer.style.color = 'var(--accent-positive)';
                label.textContent = 'Longs Crowded';
                label.style.color = 'var(--accent-positive)';
            } else if (crowdSide === 'short' || shortPct > 65) {
                iconContainer.innerHTML = '<i data-lucide="trending-down" style="width: 24px; height: 24px;"></i>';
                iconContainer.style.background = 'rgba(244, 67, 54, 0.2)';
                iconContainer.style.color = 'var(--accent-negative)';
                label.textContent = 'Shorts Crowded';
                label.style.color = 'var(--accent-negative)';
            } else if (crowdSide === 'lean_long') {
                iconContainer.innerHTML = '<i data-lucide="arrow-up-right" style="width: 24px; height: 24px;"></i>';
                iconContainer.style.background = 'rgba(76, 175, 80, 0.15)';
                iconContainer.style.color = 'var(--accent-positive)';
                label.textContent = 'Leaning Long';
                label.style.color = 'var(--text-primary)';
            } else if (crowdSide === 'lean_short') {
                iconContainer.innerHTML = '<i data-lucide="arrow-down-right" style="width: 24px; height: 24px;"></i>';
                iconContainer.style.background = 'rgba(244, 67, 54, 0.15)';
                iconContainer.style.color = 'var(--accent-negative)';
                label.textContent = 'Leaning Short';
                label.style.color = 'var(--text-primary)';
            } else {
                iconContainer.innerHTML = '<i data-lucide="minus" style="width: 24px; height: 24px;"></i>';
                iconContainer.style.background = 'rgba(255, 191, 0, 0.1)';
                iconContainer.style.color = 'var(--text-primary)';
                label.textContent = 'Balanced';
                label.style.color = 'var(--text-primary)';
            }

            // Update per-symbol breakdown
            if (data.symbols) {
                const btcData = data.symbols.BTCUSDT;
                const ethData = data.symbols.ETHUSDT;
                const solData = data.symbols.SOLUSDT;

                if (btcData && !btcData.error) {
                    const btcEl = document.getElementById('lsBtc');
                    btcEl.textContent = btcData.long_pct.toFixed(0) + '%L';
                    btcEl.style.color = btcData.long_pct > 60 ? 'var(--accent-positive)' : btcData.long_pct < 40 ? 'var(--accent-negative)' : 'var(--text-primary)';
                }
                if (ethData && !ethData.error) {
                    const ethEl = document.getElementById('lsEth');
                    ethEl.textContent = ethData.long_pct.toFixed(0) + '%L';
                    ethEl.style.color = ethData.long_pct > 60 ? 'var(--accent-positive)' : ethData.long_pct < 40 ? 'var(--accent-negative)' : 'var(--text-primary)';
                }
                if (solData && !solData.error) {
                    const solEl = document.getElementById('lsSol');
                    solEl.textContent = solData.long_pct.toFixed(0) + '%L';
                    solEl.style.color = solData.long_pct > 60 ? 'var(--accent-positive)' : solData.long_pct < 40 ? 'var(--accent-negative)' : 'var(--text-primary)';
                }
            }

            // Update exchange badge
            if (data.sources) {
                const badge = document.getElementById('lsExchangeBadge');
                if (badge) {
                    badge.textContent = data.sources.exchanges_available + ' Exchanges';
                }
            }

            // Re-initialize Lucide icons
            try { if (typeof lucide !== 'undefined') lucide.createIcons(); } catch(e) {}
        }

        // Market breadth update function (fallback)
        function updateMarketBreadth(upCount, downCount) {
            const total = upCount + downCount;
            
            // Handle case when no data available
            if (total === 0) {
                document.getElementById('marketLabel').textContent = 'No Data';
                document.getElementById('upCount').textContent = '0';
                document.getElementById('downCount').textContent = '0';
                document.getElementById('bullSection').style.width = '50%';
                document.getElementById('bullSection').textContent = '50%';
                document.getElementById('bearSection').style.width = '50%';
                document.getElementById('bearSection').textContent = '50%';
                return;
            }
            
            const bullPercent = Math.round((upCount / total) * 100);
            const bearPercent = 100 - bullPercent;
            
            // Update visual elements
            document.getElementById('bullSection').style.width = bullPercent + '%';
            document.getElementById('bullSection').textContent = bullPercent + '%';
            document.getElementById('bearSection').style.width = bearPercent + '%';
            document.getElementById('bearSection').textContent = bearPercent + '%';
            document.getElementById('upCount').textContent = upCount;
            document.getElementById('downCount').textContent = downCount;
            
            // Update icon and label based on sentiment
            const iconContainer = document.getElementById('marketIcon');
            const label = document.getElementById('marketLabel');
            
            if (bullPercent > 60) {
                iconContainer.className = 'market-icon bullish';
                iconContainer.innerHTML = '<i data-lucide="trending-up" style="width: 24px; height: 24px;"></i>';
                iconContainer.style.background = 'rgba(76, 175, 80, 0.2)';
                iconContainer.style.color = 'var(--accent-positive)';
                label.textContent = 'Bulls Leading';
            } else if (bullPercent < 40) {
                iconContainer.className = 'market-icon bearish';
                iconContainer.innerHTML = '<i data-lucide="trending-down" style="width: 24px; height: 24px;"></i>';
                iconContainer.style.background = 'rgba(244, 67, 54, 0.2)';
                iconContainer.style.color = 'var(--accent-negative)';
                label.textContent = 'Bears Leading';
            } else {
                iconContainer.className = 'market-icon neutral';
                iconContainer.innerHTML = '<i data-lucide="minus" style="width: 24px; height: 24px;"></i>';
                iconContainer.style.background = 'rgba(255, 191, 0, 0.1)';
                iconContainer.style.color = 'var(--text-primary)';
                label.textContent = 'Market Balanced';
            }
            
            // Re-initialize Lucide icons for the new elements
            try { if (typeof lucide !== 'undefined') lucide.createIcons(); } catch(e) {}
        }

        // Update dashboard with overview data (signals, opportunities)
        function updateDashboard(data) {
            console.log('[DEBUG] updateDashboard called with keys:', Object.keys(data || {}));

            // Update signals if available
            if (data.signals && Array.isArray(data.signals)) {
                updateSignals({ signals: data.signals });
            }

        }

        // Update Market Intelligence card with CoinGecko Extended data
        function updateMarketIntelligence(data) {
            console.log('[DEBUG] updateMarketIntelligence called with:', data);

            // === TRENDING COINS ===
            const trendingContainer = document.getElementById('trendingCoinsContainer');
            const trendingTime = document.getElementById('trendingUpdateTime');

            if (data.trending && data.trending.available && trendingContainer) {
                const coins = data.trending.top_coins || [];
                if (coins.length > 0) {
                    // Create pill HTML for each coin
                    const pillHTML = symbol => `
                        <div class="trending-pill">
                            <span style="font-size: 10px;"></span>
                            ${symbol}
                        </div>
                    `;

                    // Duplicate coins for seamless infinite scroll (marquee effect)
                    const allCoins = [...coins, ...coins];
                    trendingContainer.innerHTML = allCoins.map(pillHTML).join('');
                } else {
                    trendingContainer.innerHTML = '<span style="color: var(--text-secondary); font-size: 11px;">No trending data</span>';
                    trendingContainer.style.animation = 'none';
                }

                if (trendingTime && data.trending.updated_at) {
                    const date = new Date(data.trending.updated_at);
                    trendingTime.textContent = date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                }
            }

            // === SECTOR ROTATION ===
            const rotationSignal = document.getElementById('rotationSignal');
            const topSectors = document.getElementById('topSectors');
            const bottomSectors = document.getElementById('bottomSectors');

            if (data.categories && data.categories.available) {
                // Update rotation signal
                if (rotationSignal) {
                    const signal = data.categories.rotation_signal || 'NEUTRAL';
                    let bgColor, textColor, borderColor;

                    if (signal.includes('RISK_ON')) {
                        bgColor = 'rgba(16, 185, 129, 0.15)';
                        borderColor = 'rgba(16, 185, 129, 0.3)';
                        textColor = 'var(--accent-positive)';
                    } else if (signal.includes('RISK_OFF')) {
                        bgColor = 'rgba(239, 68, 68, 0.15)';
                        borderColor = 'rgba(239, 68, 68, 0.3)';
                        textColor = 'var(--accent-negative)';
                    } else if (signal.includes('DEFI')) {
                        bgColor = 'rgba(6, 182, 212, 0.15)';
                        borderColor = 'rgba(6, 182, 212, 0.3)';
                        textColor = 'var(--neon-cyan)';
                    } else {
                        bgColor = 'rgba(251, 191, 36, 0.15)';
                        borderColor = 'rgba(251, 191, 36, 0.3)';
                        textColor = 'var(--neon-amber)';
                    }

                    // Extract just the signal type (e.g., "NEUTRAL" from "NEUTRAL: No clear rotation signal")
                    const signalType = signal.split(':')[0].trim();
                    rotationSignal.textContent = signalType;
                    rotationSignal.style.background = bgColor;
                    rotationSignal.style.borderColor = borderColor;
                    rotationSignal.style.color = textColor;
                }

                // Update top performers
                if (topSectors) {
                    const performers = data.categories.top_performers || [];
                    if (performers.length > 0) {
                        topSectors.innerHTML = performers.slice(0, 3).map(p =>
                            `<div style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${p}</div>`
                        ).join('');
                    } else {
                        topSectors.innerHTML = '<span style="color: var(--text-secondary);">--</span>';
                    }
                }

                // Fetch bottom performers from full categories endpoint
                if (bottomSectors) {
                    // Fetch full categories data for bottom performers
                    fetch('/api/market/categories')
                        .then(res => res.json())
                        .then(catData => {
                            if (catData.status === 'success' && catData.data?.bottom_performers) {
                                const bottomPerformers = catData.data.bottom_performers;
                                if (bottomPerformers.length > 0) {
                                    bottomSectors.innerHTML = bottomPerformers.slice(0, 3).map(p =>
                                        `<div style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${p}</div>`
                                    ).join('');
                                } else {
                                    bottomSectors.innerHTML = '<span style="color: var(--text-secondary);">--</span>';
                                }
                            } else {
                                bottomSectors.innerHTML = '<span style="color: var(--text-secondary);">--</span>';
                            }
                        })
                        .catch(() => {
                            bottomSectors.innerHTML = '<span style="color: var(--text-secondary);">--</span>';
                        });
                }
            }

            // === EXCHANGE CONCENTRATION ===
            fetchExchangeConcentration();

            // === DERIVATIVES OI & ARB ===
            const derivativesOI = document.getElementById('globalDerivativesOI');
            const arbCount = document.getElementById('arbOpportunities');
            const spreadsContainer = document.getElementById('fundingSpreadsContainer');

            if (data.derivatives && data.derivatives.available) {
                if (derivativesOI) {
                    const oi = data.derivatives.total_open_interest || 0;
                    if (oi >= 1e12) {
                        derivativesOI.textContent = '$' + (oi / 1e12).toFixed(2) + 'T';
                    } else if (oi >= 1e9) {
                        derivativesOI.textContent = '$' + (oi / 1e9).toFixed(1) + 'B';
                    } else {
                        derivativesOI.textContent = '$' + (oi / 1e6).toFixed(0) + 'M';
                    }
                }
                if (arbCount) {
                    arbCount.textContent = data.derivatives.arb_opportunities || 0;
                }

                // Fetch full derivatives data for funding spreads and OI distribution
                fetchFundingSpreads();
                fetchOIDistribution();
            }

            // === MARKET CYCLE PHASE ===
            fetchMarketCyclePhase();

            // === BYBIT SECTOR ROTATION ===
            fetchBybitSectorRotation();

            // === CEX VS DEX FLOW ===
            fetchCexDexFlow();

            console.log('[DEBUG] Market Intelligence updated successfully');
        }

        // Fetch Exchange Concentration data
        function fetchExchangeConcentration() {
            const exchangeTop3 = document.getElementById('exchangeTop3Share');
            const exchangesList = document.getElementById('topExchangesList');
            
            fetch('/api/market/exchanges/concentration')
                .then(res => res.json())
                .then(response => {
                    if (response.status === 'success' && response.data) {
                        const data = response.data;
                        if (exchangeTop3 && data.concentration) {
                            const share = data.concentration.top_3_share || 0;
                            exchangeTop3.textContent = share.toFixed(1) + '%';
                        }
                        if (exchangesList && data.top_exchanges) {
                            const names = data.top_exchanges.slice(0, 3).map(e => e.name).join(', ');
                            exchangesList.innerHTML = names;
                        }
                    }
                })
                .catch(err => console.warn('[WARN] Failed to fetch exchange concentration:', err));
        }

        // Fetch and update Market Cycle Phase
        function fetchMarketCyclePhase() {
            fetch('/api/market/cycle-phase')
                .then(res => res.json())
                .then(data => {
                    if (data.status === 'success' && data.data) {
                        updateMarketCyclePhase(data.data);
                    }
                })
                .catch(err => console.warn('[WARN] Failed to fetch cycle phase:', err));
        }

        // Update Market Cycle Phase UI
        function updateMarketCyclePhase(data) {
            const phaseLabel = document.getElementById('cyclePhaseLabel');
            const riskBadge = document.getElementById('cyclePhaseRiskBadge');
            const phaseProgress = document.getElementById('cyclePhaseProgress');
            const phaseMarker = document.getElementById('cyclePhaseMarker');
            const specRatio = document.getElementById('cycleSpecRatio');
            const phaseScore = document.getElementById('cyclePhaseScore');
            const confidence = document.getElementById('cycleConfidence');

            if (!phaseLabel) return;

            // Update phase name
            const phaseName = data.phase?.name || 'Unknown';
            phaseLabel.textContent = phaseName;

            // Update risk badge with color coding
            const riskLevel = data.phase?.risk_level || 'MODERATE';
            if (riskBadge) {
                riskBadge.textContent = riskLevel;
                if (riskLevel === 'LOW') {
                    riskBadge.style.background = 'rgba(16, 185, 129, 0.2)';
                    riskBadge.style.color = 'var(--accent-positive)';
                } else if (riskLevel === 'MODERATE') {
                    riskBadge.style.background = 'rgba(251, 191, 36, 0.2)';
                    riskBadge.style.color = 'var(--neon-amber)';
                } else if (riskLevel === 'HIGH') {
                    riskBadge.style.background = 'rgba(249, 115, 22, 0.2)';
                    riskBadge.style.color = '#f97316';
                } else if (riskLevel === 'EXTREME') {
                    riskBadge.style.background = 'rgba(239, 68, 68, 0.2)';
                    riskBadge.style.color = 'var(--accent-negative)';
                }
            }

            // Update phase progress bar (0-100 based on phase_score)
            const score = data.phase_score || 50;
            if (phaseProgress) {
                phaseProgress.style.width = score + '%';
            }
            if (phaseMarker) {
                phaseMarker.style.left = score + '%';
            }

            // Update indicators
            if (specRatio && data.indicators) {
                const ratio = data.indicators.speculative_ratio || 0;
                specRatio.textContent = ratio.toFixed(2) + 'x';
                // Color based on ratio threshold
                if (ratio > 1.5) {
                    specRatio.style.color = 'var(--accent-negative)';
                } else if (ratio > 1.0) {
                    specRatio.style.color = 'var(--neon-amber)';
                } else {
                    specRatio.style.color = 'var(--accent-positive)';
                }
            }

            if (phaseScore) {
                phaseScore.textContent = Math.round(score);
            }

            if (confidence && data.confidence !== undefined) {
                const confPct = Math.round(data.confidence * 100);
                confidence.textContent = confPct + '%';
            }

            console.log('[DEBUG] Market Cycle Phase updated:', phaseName, 'Score:', score);
        }

        // Sector Rotation API - crypto-perps-tracker multi-exchange API (8 exchanges, 91.7% market coverage)
        // Direct connection to derivatives-signals-api on port 8888
        const SECTOR_ROTATION_API = 'http://' + window.location.hostname + ':8888';

        // Fetch and update Sector Rotation data (multi-exchange: Binance, OKX, Bybit, Gate.io, Bitget, HyperLiquid, AsterDEX, dYdX)
        // API is running on port 8888 with CORS enabled
        const SECTOR_ROTATION_ENABLED = true;  // Enabled - API deployed on port 8888

        function fetchBybitSectorRotation() {
            if (!SECTOR_ROTATION_ENABLED) return;  // Skip if API not available

            // Fetch rankings for top/bottom sectors
            fetch(`${SECTOR_ROTATION_API}/sector-rotation/rankings?timeframe=4h`)
                .then(res => {
                    if (!res.ok) return null;  // Silently skip 404/5xx errors
                    return res.json();
                })
                .then(data => {
                    if (data) updateBybitSectorRankings(data);
                })
                .catch(() => {});  // Silently fail - API not deployed yet

            // Fetch summary for signal counts
            fetch(`${SECTOR_ROTATION_API}/sector-rotation/summary`)
                .then(res => {
                    if (!res.ok) return null;
                    return res.json();
                })
                .then(data => {
                    if (data) updateBybitSectorSummary(data);
                })
                .catch(() => {});
        }

        // Update Bybit Sector Rankings (top/bottom sectors)
        function updateBybitSectorRankings(data) {
            const topSectors = document.getElementById('bybitTopSectors');
            const bottomSectors = document.getElementById('bybitBottomSectors');
            const statusLabel = document.getElementById('bybitSectorStatus');
            const timeframeBadge = document.getElementById('bybitSectorTimeframe');

            if (!topSectors || !bottomSectors) return;

            const rankings = data.rankings || [];
            const timeframe = data.timeframe_label || '4 Hours';

            if (timeframeBadge) {
                timeframeBadge.textContent = data.timeframe || '4H';
            }

            if (rankings.length === 0) {
                if (statusLabel) {
                    statusLabel.textContent = 'Awaiting data collection...';
                    statusLabel.style.color = 'var(--text-secondary)';
                }
                topSectors.innerHTML = '<div style="color: var(--text-secondary);">--</div>';
                bottomSectors.innerHTML = '<div style="color: var(--text-secondary);">--</div>';
                return;
            }

            if (statusLabel) {
                statusLabel.textContent = `${rankings.length} sectors tracked`;
                statusLabel.style.color = 'var(--neon-cyan)';
            }

            // Get top 3 (highest rotation score) and bottom 3 (lowest rotation score)
            const sortedByScore = [...rankings].sort((a, b) =>
                (b.rotation_score || 50) - (a.rotation_score || 50)
            );

            const top3 = sortedByScore.slice(0, 3);
            const bottom3 = sortedByScore.slice(-3).reverse();

            // Helper to get signal badge color and icon
            const getSignalBadge = (signalType) => {
                const badges = {
                    'bullish': { color: 'var(--accent-positive)', bg: 'rgba(16, 185, 129, 0.2)', text: '' },
                    'bearish': { color: 'var(--accent-negative)', bg: 'rgba(239, 68, 68, 0.2)', text: '' },
                    'neutral': { color: 'var(--neon-amber)', bg: 'rgba(251, 191, 36, 0.2)', text: '' }
                };
                return badges[signalType] || badges['neutral'];
            };

            // Render top sectors with signal badges
            topSectors.innerHTML = top3.map(s => {
                const score = (s.rotation_score || 50).toFixed(1);
                const badge = getSignalBadge(s.signal_type);
                return `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 2px;">
                    <span style="display: flex; align-items: center; gap: 4px;">
                        <span>${s.emoji || ''}</span>
                        <span>${s.sector_code || s.sector}</span>
                    </span>
                    <span style="display: flex; align-items: center; gap: 6px;">
                        <span style="font-size: 8px; padding: 2px 4px; border-radius: 3px; background: ${badge.bg}; color: ${badge.color}; font-weight: 600;">${badge.text}</span>
                        <span style="color: var(--neon-cyan); font-weight: 600; min-width: 32px; text-align: right;">${score}</span>
                    </span>
                </div>`;
            }).join('');

            // Render bottom sectors with signal badges
            bottomSectors.innerHTML = bottom3.map(s => {
                const score = (s.rotation_score || 50).toFixed(1);
                const badge = getSignalBadge(s.signal_type);
                return `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 2px;">
                    <span style="display: flex; align-items: center; gap: 4px;">
                        <span>${s.emoji || ''}</span>
                        <span>${s.sector_code || s.sector}</span>
                    </span>
                    <span style="display: flex; align-items: center; gap: 6px;">
                        <span style="font-size: 8px; padding: 2px 4px; border-radius: 3px; background: ${badge.bg}; color: ${badge.color}; font-weight: 600;">${badge.text}</span>
                        <span style="color: var(--accent-negative); font-weight: 600; min-width: 32px; text-align: right;">${score}</span>
                    </span>
                </div>`;
            }).join('');

            console.log('[DEBUG] Sector Rankings updated (Bybit):', rankings.length, 'sectors');
        }

        // Update Sector Summary (signal counts)
        function updateBybitSectorSummary(data) {
            const activeSignals = document.getElementById('bybitActiveSignals');
            const confirmedSignals = document.getElementById('bybitConfirmedSignals');

            if (activeSignals) {
                activeSignals.textContent = data.active_signals || 0;
            }
            if (confirmedSignals) {
                confirmedSignals.textContent = data.confirmed_signals || 0;
            }

            console.log('[DEBUG] Sector Summary updated (Bybit):', data.active_signals || 0, 'active signals');
        }

        // Fetch and update CEX vs DEX Flow data
        function fetchCexDexFlow() {
            if (!SECTOR_ROTATION_ENABLED) return;  // Skip if API not available

            fetch(`${SECTOR_ROTATION_API}/sector-rotation/cex-vs-dex`)
                .then(res => {
                    if (!res.ok) return null;
                    return res.json();
                })
                .then(data => {
                    if (data) updateCexDexFlow(data);
                })
                .catch(() => {});  // Silently fail - API not deployed yet
        }

        // Update CEX vs DEX Flow display
        function updateCexDexFlow(data) {
            const flowList = document.getElementById('cexDexFlowList');
            const flowDirection = document.getElementById('cexDexFlowDirection');

            if (!flowList) return;

            const flows = data.flows || [];

            if (flows.length === 0) {
                flowList.innerHTML = '<div style="color: var(--text-secondary);">No data</div>';
                return;
            }

            // Count CEX vs DEX dominant sectors
            const cexCount = flows.filter(f => f.flow_direction === 'CEX').length;
            const dexCount = flows.filter(f => f.flow_direction === 'DEX').length;

            // Update overall direction badge
            if (flowDirection) {
                const dominant = cexCount > dexCount ? 'CEX' : dexCount > cexCount ? 'DEX' : 'BALANCED';
                const colors = {
                    'CEX': { bg: 'rgba(251, 191, 36, 0.2)', color: 'var(--neon-amber)' },
                    'DEX': { bg: 'rgba(6, 182, 212, 0.2)', color: 'var(--neon-cyan)' },
                    'BALANCED': { bg: 'rgba(255, 255, 255, 0.1)', color: 'var(--text-secondary)' }
                };
                flowDirection.textContent = `${dominant} ${cexCount}/${dexCount}`;
                flowDirection.style.background = colors[dominant].bg;
                flowDirection.style.color = colors[dominant].color;
            }

            // Show top 3 sectors with highest DEX activity (institutional flow indicator)
            const sortedByDex = [...flows].sort((a, b) => (b.dex_volume_share || 0) - (a.dex_volume_share || 0));
            const topDex = sortedByDex.slice(0, 3);

            flowList.innerHTML = topDex.map(f => {
                const dexPct = (f.dex_volume_share || 0).toFixed(1);
                const cexPct = (f.cex_volume_share || 0).toFixed(1);
                const flowColor = f.flow_direction === 'DEX' ? 'var(--neon-cyan)' : 'var(--neon-amber)';
                return `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 2px;">
                    <span>${f.sector_name || f.sector_code}</span>
                    <span style="display: flex; gap: 8px; font-size: 9px;">
                        <span style="color: var(--neon-amber);">CEX ${cexPct}%</span>
                        <span style="color: var(--neon-cyan);">DEX ${dexPct}%</span>
                    </span>
                </div>`;
            }).join('');

            console.log('[DEBUG] CEX vs DEX Flow updated:', flows.length, 'sectors');
        }

        // Update Market Intelligence breadth gauge (separate from Market Overview breadth)
        function updateMarketIntelBreadth(advancing, declining) {
            const total = advancing + declining;
            if (total === 0) {
                document.getElementById('breadthLabel').textContent = 'No Data';
                document.getElementById('breadthAdvancingCount').textContent = '0';
                document.getElementById('breadthDecliningCount').textContent = '0';
                document.getElementById('breadthBarAdvancing').style.width = '50%';
                document.getElementById('breadthAdvancingPct').textContent = '50%';
                document.getElementById('breadthBarDeclining').style.width = '50%';
                document.getElementById('breadthDecliningPct').textContent = '50%';
                return;
            }

            const advPct = Math.round((advancing / total) * 100);
            const decPct = 100 - advPct;

            // Update counts
            document.getElementById('breadthAdvancingCount').textContent = advancing;
            document.getElementById('breadthDecliningCount').textContent = declining;

            // Update bar widths and percentages
            document.getElementById('breadthBarAdvancing').style.width = advPct + '%';
            document.getElementById('breadthAdvancingPct').textContent = advPct + '%';
            document.getElementById('breadthBarDeclining').style.width = decPct + '%';
            document.getElementById('breadthDecliningPct').textContent = decPct + '%';

            // Update label based on sentiment
            let label, color;
            if (advPct >= 70) {
                label = 'Strong Bullish';
                color = 'var(--accent-positive)';
            } else if (advPct >= 55) {
                label = 'Bullish';
                color = 'var(--accent-positive)';
            } else if (advPct <= 30) {
                label = 'Strong Bearish';
                color = 'var(--accent-negative)';
            } else if (advPct <= 45) {
                label = 'Bearish';
                color = 'var(--accent-negative)';
            } else {
                label = 'Neutral';
                color = 'var(--neon-amber)';
            }
            document.getElementById('breadthLabel').textContent = label;
            document.getElementById('breadthLabel').style.color = color;
        }

        // Fetch funding spreads for arbitrage display
        async function fetchFundingSpreads() {
            try {
                const response = await fetch('/api/market/derivatives/funding-spreads');
                const data = await response.json();

                if (data.status === 'success' && data.data && data.data.spreads) {
                    const spreadsContainer = document.getElementById('fundingSpreadsContainer');
                    if (!spreadsContainer) return;

                    const spreads = Object.entries(data.data.spreads).slice(0, 5);

                    if (spreads.length > 0) {
                        spreadsContainer.innerHTML = spreads.map(([symbol, info]) => {
                            const spreadBps = info.spread_bps || 0;
                            const spreadColor = spreadBps > 100 ? 'var(--accent-positive)' :
                                               spreadBps > 50 ? 'var(--neon-amber)' : 'var(--text-secondary)';

                            return `
                                <div style="
                                    background: rgba(0,0,0,0.3);
                                    border: 1px solid rgba(255,255,255,0.05);
                                    padding: 8px 12px;
                                    border-radius: 8px;
                                    min-width: 100px;
                                    flex-shrink: 0;
                                ">
                                    <div style="font-size: 12px; font-weight: 600; color: var(--text-primary); margin-bottom: 2px;">${symbol}</div>
                                    <div style="font-size: 14px; font-weight: 700; color: ${spreadColor};">${spreadBps.toFixed(0)} bps</div>
                                </div>
                            `;
                        }).join('');
                    } else {
                        spreadsContainer.innerHTML = '<span style="color: var(--text-secondary); font-size: 11px;">No arb opportunities</span>';
                    }
                }
            } catch (error) {
                console.warn('[DEBUG] Failed to fetch funding spreads:', error);
            }
        }

        // Fetch OI distribution by exchange from CoinGecko derivatives data
        async function fetchOIDistribution() {
            try {
                const response = await fetch('/api/market/derivatives');
                const data = await response.json();

                if (data.status === 'success' && data.data && data.data.contracts) {
                    const container = document.getElementById('oiDistributionContainer');
                    if (!container) return;

                    // Aggregate OI by exchange
                    const exchangeOI = {};
                    data.data.contracts.forEach(contract => {
                        const market = contract.market || 'Unknown';
                        // Clean exchange name: "Binance (Futures)" -> "Binance"
                        const exchange = market.replace(/\s*\(.*\)\s*/g, '').trim();
                        const oi = parseFloat(contract.open_interest) || 0;
                        exchangeOI[exchange] = (exchangeOI[exchange] || 0) + oi;
                    });

                    // Sort by OI descending, take top 5
                    const sorted = Object.entries(exchangeOI)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 5);

                    if (sorted.length > 0) {
                        // Calculate total for percentage
                        const totalOI = sorted.reduce((sum, [_, oi]) => sum + oi, 0);

                        container.innerHTML = sorted.map(([exchange, oi], idx) => {
                            const pct = totalOI > 0 ? ((oi / totalOI) * 100).toFixed(1) : 0;
                            const formatted = oi >= 1e9 ? (oi / 1e9).toFixed(1) + 'B' : (oi / 1e6).toFixed(0) + 'M';
                            // Color gradient based on rank
                            const colors = ['var(--neon-cyan)', 'var(--accent-positive)', 'var(--neon-amber)', 'var(--text-secondary)', 'var(--text-secondary)'];
                            return `
                                <div style="
                                    background: rgba(0,0,0,0.3);
                                    border: 1px solid ${idx === 0 ? 'rgba(6, 182, 212, 0.3)' : 'rgba(255,255,255,0.05)'};
                                    padding: 6px 10px;
                                    border-radius: 8px;
                                    min-width: 75px;
                                    flex-shrink: 0;
                                    text-align: center;
                                ">
                                    <div style="font-size: 10px; font-weight: 600; color: ${colors[idx]}; margin-bottom: 2px;">${exchange}</div>
                                    <div style="font-size: 13px; font-weight: 700; color: var(--text-primary);">$${formatted}</div>
                                    <div style="font-size: 9px; color: var(--text-secondary);">${pct}%</div>
                                </div>
                            `;
                        }).join('');
                    } else {
                        container.innerHTML = '<span style="color: var(--text-secondary); font-size: 11px;">No OI data</span>';
                    }
                }
            } catch (error) {
                console.warn('[DEBUG] Failed to fetch OI distribution:', error);
            }
        }

        // Data loading functions
        async function loadDashboardData() {
            console.log('[DEBUG] loadDashboardData() called at', new Date().toISOString());
            try {
                console.log('[DEBUG] Starting individual fetches...');

                // Fetch each endpoint individually with logging and error resilience
                const fetchWithLog = async (url) => {
                    const start = Date.now();
                    console.log('[DEBUG] Fetching:', url);
                    try {
                        const resp = await fetch(url);
                        console.log('[DEBUG] ', url, '- Status:', resp.status, 'Time:', Date.now() - start, 'ms');
                        if (!resp.ok) {
                            console.warn('[DEBUG] Non-OK response for', url, '- Status:', resp.status);
                            return null;
                        }
                        return await resp.json();
                    } catch (e) {
                        console.error('[DEBUG] ', url, '- Error:', e.message);
                        return null; // Return null instead of throwing to allow partial loading
                    }
                };

                // Load data with resilience - use Promise.allSettled to handle partial failures
                // NOTE: Removed /api/dashboard/market-overview (redundant - mobile-data includes market_overview)
                const results = await Promise.allSettled([
                    fetchWithLog('/api/dashboard/overview'),
                    fetchWithLog('/api/dashboard/symbols'),
                    fetchWithLog('/api/dashboard/mobile-data'),
                    fetchWithLog('/api/market/summary')
                ]);

                // Extract values, using null for failures
                const summaryData = results[0].status === 'fulfilled' ? results[0].value : null;
                const symbolsData = results[1].status === 'fulfilled' ? results[1].value : null;
                const mobileData = results[2].status === 'fulfilled' ? results[2].value : null;
                const coinGeckoData = results[3].status === 'fulfilled' ? results[3].value : null;

                // Count successful fetches
                const successCount = results.filter(r => r.status === 'fulfilled' && r.value !== null).length;
                console.log('[DEBUG] Fetches completed:', successCount, '/ 4 successful');

                // If all fetches failed, show error but don't throw
                if (successCount === 0) {
                    console.error('[DEBUG] All API fetches failed');
                    const errDiv = document.createElement('div');
                    errDiv.style.cssText = 'position:fixed;top:0;left:0;right:0;background:rgba(239,68,68,0.9);color:white;padding:8px 12px;z-index:9999;font-size:11px;text-align:center;';
                    errDiv.textContent = 'Network error - retrying...';
                    errDiv.id = 'networkErrorBanner';
                    document.body.prepend(errDiv);
                    // Auto-retry after 5 seconds
                    setTimeout(() => {
                        const banner = document.getElementById('networkErrorBanner');
                        if (banner) banner.remove();
                        loadDashboardData();
                    }, 5000);
                    return;
                }

                console.log('[DEBUG] Data parsing successful');
                if (mobileData) {
                    console.log('[DEBUG] mobileData.market_overview:', JSON.stringify(mobileData.market_overview || {}).substring(0, 200));
                }

                // DEBUG: Log all data sources (with null safety)
                console.log('[DEBUG] ====== DATA SOURCES ======');
                console.log('[DEBUG] summaryData:', summaryData ? 'loaded' : 'failed');
                console.log('[DEBUG] symbolsData:', symbolsData ? 'loaded' : 'failed');
                console.log('[DEBUG] mobileData:', mobileData ? 'loaded' : 'failed');
                console.log('[DEBUG] coinGeckoData:', coinGeckoData ? 'loaded' : 'failed');
                console.log('[DEBUG] ============================');

                // Process available data with null safety
                if (summaryData) {
                    updateDashboard(summaryData);
                }
                if (symbolsData) {
                    updateSymbols(symbolsData);
                }

                // FIX: Check if mobile-data has REAL data (not cache warmer zeros)
                // Use mobileData.market_overview as primary source, fallback to summaryData
                const mo = mobileData?.market_overview || {};
                const hasRealMobileData = mobileData?.status === 'success' &&
                    mo &&
                    (mo.trend_strength > 0 || mo.gainers > 0 || mo.losers > 0 || mo.total_market_cap > 0);

                console.log('[DEBUG] Mobile data check:', { hasRealMobileData, mo_trend: mo.trend_strength, mo_gainers: mo.gainers, mo_regime: mo.market_regime });

                if (hasRealMobileData) {
                    console.log('[DEBUG] Using mobile-data market_overview');
                    updateMarketOverview(mo);
                } else if (summaryData?.market_overview) {
                    console.log('[DEBUG] Using summaryData.market_overview as fallback');
                    updateMarketOverview(summaryData.market_overview);
                } else {
                    console.warn('[DEBUG] No market overview data available');
                }

                // Use our new mobile-data endpoint for top movers
                if (mobileData?.status === 'success') {
                    updateTopMovers(mobileData.top_movers);

                    // Update Market Intelligence breadth gauge with ACTUAL breadth data
                    // FIX: Previously used movers array length (always 5/5), now uses real breadth counts
                    if (mobileData.market_breadth) {
                        const breadth = mobileData.market_breadth;
                        updateMarketIntelBreadth(breadth.up || 0, breadth.down || 0);
                        console.log('[BREADTH] Updated Market Intelligence with:', breadth.up, 'up,', breadth.down, 'down');
                    } else {
                        // Fallback to market_overview gainers/losers if market_breadth not available
                        const moData = mobileData.market_overview || {};
                        if (moData.gainers !== undefined || moData.losers !== undefined) {
                            updateMarketIntelBreadth(moData.gainers || 0, moData.losers || 0);
                            console.log('[BREADTH] Fallback to market_overview:', moData.gainers, 'gainers,', moData.losers, 'losers');
                        }
                    }

                    // Update confluence scores if needed - filter out system status entries
                    if (mobileData.confluence_scores) {
                        console.log('Raw confluence scores:', mobileData.confluence_scores);
                        const validScores = mobileData.confluence_scores.filter(score =>
                            score &&
                            score.symbol &&
                            score.symbol !== 'SYSTEM_STATUS' &&
                            score.sentiment !== 'INITIALIZING' &&
                            !score.symbol.includes('SYSTEM')
                        );
                        console.log('Filtered valid scores:', validScores);
                        if (validScores.length > 0) {
                            updateSymbols({ symbols: validScores });
                            // Update native Momentum Waves widget
                            updateMomentumWaves(mobileData.confluence_scores);
                        } else {
                            // If no valid scores, show empty state
                            console.log('No valid confluence scores, showing empty state');
                            updateSymbols({ symbols: [] });
                        }
                    }
                }

                // Update price ticker with confluence scores data
                if (mobileData?.confluence_scores) {
                    updatePriceTicker(mobileData.confluence_scores);
                }

                // Fetch Perpetuals Pulse data (separate from main data to avoid blocking)
                fetchPerpetualsPulse();

                // Update Market Intelligence card with CoinGecko data
                if (coinGeckoData && coinGeckoData.status === 'success') {
                    updateMarketIntelligence(coinGeckoData.data);
                }

                // Final summary
                console.log('[DEBUG] ====== LOAD COMPLETE SUMMARY ======');
                console.log('[DEBUG] Signals in DOM:', document.getElementById('signalsList')?.children.length || 0);
                console.log('[DEBUG] Alerts in DOM:', document.getElementById('alertsList')?.children.length || 0);
                console.log('[DEBUG] Gainers in DOM:', document.getElementById('topGainersList')?.children.length || 0);
                console.log('[DEBUG] Losers in DOM:', document.getElementById('topLosersList')?.children.length || 0);
                console.log('[DEBUG] =====================================');
            } catch (error) {
                console.error('[DEBUG] ERROR in loadDashboardData:', error);
                console.error('[DEBUG] Stack trace:', error.stack);
                // Make error visible on page
                const errDiv = document.createElement('div');
                errDiv.style.cssText = 'position:fixed;top:0;left:0;right:0;background:red;color:white;padding:10px;z-index:9999;font-size:12px;';
                errDiv.textContent = 'JS Error: ' + error.message;
                document.body.prepend(errDiv);
            }
        }

        // Price Ticker Functions
        function updatePriceTicker(scores) {
            const tickerTrack = document.getElementById('tickerTrack');
            if (!tickerTrack || !scores || scores.length === 0) return;

            // Filter valid scores and sort by volume
            const validScores = scores.filter(s =>
                s && s.symbol && s.price &&
                s.symbol !== 'SYSTEM_STATUS' &&
                !s.symbol.includes('SYSTEM')
            ).sort((a, b) => (b.volume_24h || 0) - (a.volume_24h || 0));

            if (validScores.length === 0) return;

            // Create ticker items HTML
            const createTickerItem = (score) => {
                const symbol = score.symbol.replace('USDT', '');
                const price = parseFloat(score.price);
                const change = parseFloat(score.change_24h || 0);
                const changeClass = change >= 0 ? 'positive' : 'negative';
                const changePrefix = change >= 0 ? '+' : '';

                // Format price based on magnitude
                let priceStr;
                if (price >= 1000) priceStr = price.toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 });
                else if (price >= 1) priceStr = price.toFixed(2);
                else if (price >= 0.01) priceStr = price.toFixed(4);
                else priceStr = price.toFixed(6);

                return `
                    <div class="ticker-item">
                        <span class="ticker-symbol">${symbol}</span>
                        <span class="ticker-price">$${priceStr}</span>
                        <span class="ticker-change ${changeClass}">${changePrefix}${change.toFixed(1)}%</span>
                    </div>
                    <span class="ticker-separator"></span>
                `;
            };

            // Generate ticker content (duplicate for seamless loop)
            const tickerContent = validScores.map(createTickerItem).join('');
            tickerTrack.innerHTML = tickerContent + tickerContent;

            // Adjust animation speed based on content width
            const contentWidth = tickerTrack.scrollWidth / 2;
            const speed = Math.max(10, contentWidth / 80); // ~80px per second (fast scan)
            tickerTrack.style.animationDuration = `${speed}s`;
        }

        async function loadSignalsData() {
            try {
                // Fetch trade-ready signals with entry/SL/TP levels
                const response = await fetch('/api/dashboard/trade-signals');
                const data = await response.json();
                updateTradeSignals(data);
            } catch (error) {
                console.error('Error loading trade signals data:', error);
                // Fallback to empty state
                updateTradeSignals({ signals: [], summary: {}, performance_24h: {} });
            }
        }


        async function loadAlphaData() {
            try {
                // Load both APIs in parallel for faster loading
                const [oppResponse, mobileResponse] = await Promise.all([
                    fetch('/api/dashboard/opportunities'),
                    fetch('/api/dashboard/mobile-data')
                ]);

                // Process opportunities
                const data = await oppResponse.json();
                const opportunities = Array.isArray(data) ? data : (data.opportunities || []);
                updateAlpha({ opportunities });

                // Process confluence scores
                const mobileData = await mobileResponse.json();
                if (mobileData.status === 'success' && mobileData.confluence_scores) {
                    const validScores = mobileData.confluence_scores.filter(score =>
                        score &&
                        score.symbol &&
                        score.symbol !== 'SYSTEM_STATUS' &&
                        score.sentiment !== 'INITIALIZING' &&
                        !score.symbol.includes('SYSTEM')
                    );
                    if (validScores.length > 0) {
                        updateSymbols({ symbols: validScores });
                        // Update native Momentum Waves widget
                        updateMomentumWaves(mobileData.confluence_scores);
                    }
                }
            } catch (error) {
                console.error('Error loading alpha data:', error);
            }
        }

        // =====================================================
        // ALERT NOTIFICATION SYSTEM
        // =====================================================

        // Notification state
        let lastSeenAlertTimestamp = parseInt(localStorage.getItem('lastSeenAlertTimestamp') || '0');
        let alertNotificationsEnabled = localStorage.getItem('alertNotifications') !== 'false';
        let alertSoundEnabled = localStorage.getItem('alertSound') !== 'false';
        let pushNotificationsEnabled = false;
        let unreadAlertCount = 0;

        // Create audio element for notification chime (simple 880Hz beep)
        const alertChime = new Audio('data:audio/wav;base64,UklGRl9vT19teleS0NSyeQ8ANZFgQ1LF4DgA1kdDTsHcNADSQz9KvdgwAM4/O0a51CwAyjs3QrXQKADGNzc+scgkAMIzMzqtxCAAvjMvNqnAHAC6Ly8ypbgYALYrKzKhtBQAricnLoWwEACuIyMmfawMAKofHyZ9pAgAphs');
        alertChime.volume = 0.3;

        // Fallback: Use Web Audio API for notification sound
        function playNotificationSound() {
            try {
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);

                oscillator.frequency.value = 880; // A5 note
                oscillator.type = 'sine';

                gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);

                oscillator.start(audioCtx.currentTime);
                oscillator.stop(audioCtx.currentTime + 0.3);
            } catch (e) {
                console.log('Audio playback not available:', e);
            }
        }

        // Request push notification permission
        async function requestNotificationPermission() {
            if (!('Notification' in window)) {
                console.log('Browser does not support notifications');
                return false;
            }

            if (Notification.permission === 'granted') {
                pushNotificationsEnabled = true;
                return true;
            }

            if (Notification.permission !== 'denied') {
                const permission = await Notification.requestPermission();
                pushNotificationsEnabled = permission === 'granted';
                return pushNotificationsEnabled;
            }

            return false;
        }

        // Show push notification
        function showPushNotification(title, body, icon = '') {
            if (!pushNotificationsEnabled || Notification.permission !== 'granted') return;

            try {
                const notification = new Notification(title, {
                    body: body,
                    icon: '/static/img/logo.png',
                    badge: '/static/img/logo.png',
                    tag: 'virtuoso-alert',
                    renotify: true,
                    silent: false
                });

                notification.onclick = () => {
                    window.focus();
                    switchTab('alerts');
                    notification.close();
                };

                // Auto-close after 5 seconds
                setTimeout(() => notification.close(), 5000);
            } catch (e) {
                console.warn('Push notification failed:', e);
            }
        }

        // Play notification sound
        function playAlertSound() {
            if (!alertSoundEnabled) return;

            // Use Web Audio API for reliable notification sound
            playNotificationSound();
        }

        // Update badge count
        function updateAlertBadge(count) {
            const badge = document.getElementById('alertsBadge');
            if (!badge) return;

            unreadAlertCount = count;

            if (count > 0) {
                badge.textContent = count > 99 ? '99+' : count;
                badge.classList.remove('hidden');
            } else {
                badge.classList.add('hidden');
            }
        }

        // Mark alerts as seen (when user views alerts tab)
        function markAlertsAsSeen(alerts) {
            if (!alerts || alerts.length === 0) return;

            // Find the newest alert timestamp
            let newestTimestamp = 0;
            alerts.forEach(alert => {
                const ts = alert.unix_timestamp || (new Date(alert.timestamp).getTime() / 1000) || 0;
                if (ts > newestTimestamp) newestTimestamp = ts;
            });

            if (newestTimestamp > lastSeenAlertTimestamp) {
                lastSeenAlertTimestamp = newestTimestamp;
                localStorage.setItem('lastSeenAlertTimestamp', lastSeenAlertTimestamp.toString());
            }

            updateAlertBadge(0);
        }

        // Check if alert is important (warrants notification)
        function isImportantAlert(alert) {
            const details = alert.details || {};
            const message = alert.message || '';

            // Infer alert type from message if not explicitly set
            let alertType = alert.alert_type || alert.details?.type || alert.type || '';

            // Fallback: infer type from message content
            if (!alertType && message) {
                if (message.toLowerCase().includes('regime')) {
                    alertType = 'regime_change';
                } else if (message.toLowerCase().includes('whale')) {
                    alertType = 'whale_trade';
                } else if (message.toLowerCase().includes('liquidation')) {
                    alertType = 'liquidation_cascade';
                } else if (message.toLowerCase().includes('signal') || message.toLowerCase().includes('confluence')) {
                    alertType = 'high_confluence';
                }
            }
            const level = alert.level || '';

            // 1. High confluence signals / trading signals
            if (alertType === 'high_confluence' || alertType === 'signal') {
                return true;
            }

            // 2. Massive liquidation cascades ($500K+)
            if (alertType === 'liquidation_cascade') {
                const totalValue = details.total_value || 0;
                return totalValue >= 500000;  // $500K minimum
            }

            // 3. Large whale trades ($1M+)
            if (alertType === 'whale_trade') {
                const tradeValue = details.data?.largest_trade_usd || details.total_value || 0;
                return tradeValue >= 1000000;  // $1M minimum
            }

            // 4. Critical level alerts
            if (level === 'critical' || message.includes('') || message.includes('CRITICAL')) {
                return true;
            }

            // 5. Significant regime changes (not minor ranging/sideways)
            if (alertType === 'regime_change') {
                const newRegime = (details.new_regime || '').toLowerCase();
                // Only notify for trend or volatility changes, not ranging/sideways
                return newRegime.includes('trend') || newRegime.includes('volatility');
            }

            return false;
        }

        // Check for new alerts and notify
        function checkForNewAlerts(alerts) {
            if (!alerts || alerts.length === 0) {
                console.log('[ALERTS] checkForNewAlerts: No alerts to check');
                return;
            }

            // Count all new alerts (for badge)
            let newAlertCount = 0;
            // Track important alerts (for sound/push)
            let importantNewAlerts = [];

            alerts.forEach(alert => {
                const ts = alert.unix_timestamp || (new Date(alert.timestamp).getTime() / 1000) || 0;
                if (ts > lastSeenAlertTimestamp) {
                    newAlertCount++;
                    // Only add to important list if it meets criteria
                    if (isImportantAlert(alert)) {
                        importantNewAlerts.push(alert);
                    }
                }
            });

            // Update badge for ALL new alerts
            updateAlertBadge(newAlertCount);

            // Log new alerts detection
            if (newAlertCount > 0) {
                console.log('[ALERTS] New alerts detected', {
                    total_new: newAlertCount,
                    important_new: importantNewAlerts.length,
                    sound_enabled: alertSoundEnabled,
                    push_enabled: pushNotificationsEnabled,
                    tab_active: document.getElementById('alertsTab')?.classList.contains('active')
                });
            }

            // Only notify (sound + push) for IMPORTANT new alerts
            if (importantNewAlerts.length > 0 && !document.getElementById('alertsTab')?.classList.contains('active')) {
                // Play sound once for important alerts
                if (alertSoundEnabled) {
                    console.log('[ALERTS] Playing alert sound for', importantNewAlerts.length, 'important alerts');
                    playAlertSound();
                }

                // Show push notification for the most important alert
                const newestImportant = importantNewAlerts.sort((a, b) =>
                    (b.unix_timestamp || 0) - (a.unix_timestamp || 0)
                )[0];

                if (pushNotificationsEnabled && newestImportant) {
                    const symbol = newestImportant.symbol || 'Market';

                    // FIX: Use defensive pattern for alert type field
                    const alertType = newestImportant.alert_type || newestImportant.details?.type || newestImportant.type || 'Alert';

                    // Monitor fallback usage in notifications
                    if (!newestImportant.alert_type) {
                        console.warn('[ALERT-NOTIF] Push notification using fallback type field', {
                            has_details_type: !!newestImportant.details?.type,
                            has_legacy_type: !!newestImportant.type,
                            symbol: symbol,
                            resolved_type: alertType
                        });
                    }

                    const typeLabel = alertType.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());

                    console.log('[ALERTS] Showing push notification', {
                        symbol,
                        type: alertType,
                        label: typeLabel,
                        timestamp: newestImportant.unix_timestamp
                    });

                    showPushNotification(
                        ` ${symbol} - ${typeLabel}`,
                        newestImportant.message || 'Important alert received',
                        ''
                    );
                }
            }
        }

        // Initialize notification system
        function initNotifications() {
            // Request permission on first user interaction
            document.addEventListener('click', function initPushOnClick() {
                requestNotificationPermission();
                document.removeEventListener('click', initPushOnClick);
            }, { once: true });

            // Check for notification support
            if ('Notification' in window && Notification.permission === 'granted') {
                pushNotificationsEnabled = true;
            }
        }

        async function loadAlertsData() {
            try {
                const response = await fetch('/api/dashboard/alerts');
                const data = await response.json();
                // API returns array directly, wrap it for updateAlerts
                const alerts = Array.isArray(data) ? data : (data.alerts || []);

                // Check for new alerts and update badge/notifications
                checkForNewAlerts(alerts);

                // If alerts tab is active, mark as seen
                if (document.getElementById('alertsTab')?.classList.contains('active')) {
                    markAlertsAsSeen(alerts);
                }

                updateAlerts({ alerts });
            } catch (error) {
                console.error('Error loading alerts data:', error);
            }
        }

        // =====================================================
        // CRYPTO PERFORMANCE TRACKER FUNCTIONS (BYBIT DATA)
        // =====================================================

        // Performance tracker state
        let currentTimeframe = 4;  // Default to 4H (recommended for day trading)
        let perfAutoRefreshEnabled = true;
        let perfAutoRefreshInterval = null;
        const PERF_AUTO_REFRESH_MS = 120000;  // 2 minutes

        // Chip-based timeframe selector with auto-scroll
        function selectTimeframe(buttonEl, hours) {
            hapticFeedback('light'); // Haptic feedback on timeframe change
            // Remove active state from all chips
            document.querySelectorAll('.tf-chip').forEach(btn => {
                btn.classList.remove('tf-chip-active');
            });

            // Add active state to clicked chip
            buttonEl.classList.add('tf-chip-active');

            // Auto-scroll selected chip to center
            const scroller = document.getElementById('timeframeScroller');
            if (scroller && buttonEl) {
                const chipOffset = buttonEl.offsetLeft - (scroller.offsetWidth / 2) + (buttonEl.offsetWidth / 2);
                scroller.scrollTo({ left: chipOffset, behavior: 'smooth' });
            }

            // Update timeframe label
            const timeframeLabels = {
                0.0833: '5m', 0.25: '15m', 0.5: '30m',
                1: '1H', 4: '4H', 12: '12H', 24: '24H'
            };
            const labelText = timeframeLabels[hours] || hours + 'H';
            const chartTimeframeLabel = document.getElementById('chartTimeframeLabel');
            if (chartTimeframeLabel) {
                chartTimeframeLabel.textContent = labelText;
            }

            // Call existing setTimeframe to fetch new data
            setTimeframe(hours);
        }

        // Timeframe selector (legacy - now called by selectTimeframe)
        function setTimeframe(hours) {
            currentTimeframe = hours;

            // Update button styles
            document.querySelectorAll('.tf-btn').forEach(btn => {
                const btnTf = parseFloat(btn.getAttribute('data-tf'));
                if (btnTf === hours) {
                    btn.style.background = 'rgba(251, 191, 36, 0.2)';
                    btn.style.borderColor = 'var(--accent-amber)';
                    btn.style.color = 'var(--accent-amber)';
                } else {
                    btn.style.background = 'var(--bg-secondary)';
                    btn.style.borderColor = 'var(--border-light)';
                    btn.style.color = 'var(--text-secondary)';
                }
            });

            // Update labels - format as minutes for sub-hour timeframes
            let tfLabel;
            if (hours < 1) {
                tfLabel = Math.round(hours * 60) + 'm';
            } else {
                tfLabel = hours + 'H';
            }
            const timeframeBadge = document.getElementById('timeframeBadge');
            const btcTimeframeLabel = document.getElementById('btcTimeframeLabel');
            const chartTimeframeLabel = document.getElementById('chartTimeframeLabel');

            if (timeframeBadge) timeframeBadge.textContent = tfLabel;
            if (btcTimeframeLabel) btcTimeframeLabel.textContent = tfLabel;
            if (chartTimeframeLabel) chartTimeframeLabel.textContent = tfLabel;

            // Save preference
            localStorage.setItem('perfTimeframe', hours);

            // Reset zoom state when changing timeframe (new data should fit-to-content)
            lwChartVisibleRange = null;

            // Reload data
            loadPerformanceData();
        }

        // Auto-refresh toggle for Performance tab
        function toggleAutoRefresh() {
            hapticFeedback('medium'); // Haptic feedback on toggle
            perfAutoRefreshEnabled = !perfAutoRefreshEnabled;

            const refreshStatus = document.getElementById('refreshStatus');
            const refreshToggle = document.getElementById('refreshToggle');
            const refreshIndicator = document.getElementById('refreshIndicator');

            if (perfAutoRefreshEnabled) {
                refreshStatus.textContent = 'ON';
                refreshStatus.style.color = 'var(--accent-positive)';
                refreshToggle.textContent = 'ON';
                refreshToggle.style.background = 'rgba(16, 185, 129, 0.2)';
                refreshToggle.style.borderColor = 'var(--accent-positive)';
                refreshToggle.style.color = 'var(--accent-positive)';
                refreshIndicator.style.background = 'var(--accent-positive)';
                refreshIndicator.style.animation = 'pulse 2s infinite';
                startPerfAutoRefresh();
            } else {
                refreshStatus.textContent = 'OFF';
                refreshStatus.style.color = 'var(--accent-negative)';
                refreshToggle.textContent = 'OFF';
                refreshToggle.style.background = 'rgba(239, 68, 68, 0.2)';
                refreshToggle.style.borderColor = 'var(--accent-negative)';
                refreshToggle.style.color = 'var(--accent-negative)';
                refreshIndicator.style.background = 'var(--accent-negative)';
                refreshIndicator.style.animation = 'none';
                stopPerfAutoRefresh();
            }

            localStorage.setItem('perfAutoRefresh', perfAutoRefreshEnabled);
        }

        // =====================================================
        // FULLSCREEN CHART FUNCTIONALITY (ENHANCED)
        // =====================================================

        let fullscreenHintShown = false; // Track if hint has been shown this session
        let fullscreenToggleTimeout = null;

        // ========================================
        // DOUBLE-TAP QUICK ACTIONS (Optimization #4)
        // 60% faster timeframe switching
        // ========================================
        let lastTapTime = 0;
        let lastTapX = 0;
        const DOUBLE_TAP_THRESHOLD = 300; // 300ms window for double-tap detection
        const DOUBLE_TAP_DISTANCE = 50; // Max distance between taps (pixels)

        // Initialize double-tap listener on chart
        function initDoubleTapActions() {
            const chartContainer = document.getElementById('performanceChart');
            if (!chartContainer) return;

            chartContainer.addEventListener('touchend', handleDoubleTap, { passive: false });
        }

        function handleDoubleTap(e) {
            // Only active in fullscreen mode
            const card = document.getElementById('betaChartCard');
            if (!card || !card.classList.contains('fullscreen-chart')) return;

            const touch = e.changedTouches[0];
            const currentTime = new Date().getTime();
            const tapX = touch.clientX;

            // Check if this is a double-tap
            const timeDiff = currentTime - lastTapTime;
            const distDiff = Math.abs(tapX - lastTapX);

            if (timeDiff < DOUBLE_TAP_THRESHOLD && distDiff < DOUBLE_TAP_DISTANCE) {
                // Double-tap detected!
                e.preventDefault();
                handleDoubleTapAction(tapX, e.target.clientWidth);

                // Reset tap tracking
                lastTapTime = 0;
                lastTapX = 0;
            } else {
                // Single tap - update tracking
                lastTapTime = currentTime;
                lastTapX = tapX;
            }
        }

        function handleDoubleTapAction(tapX, containerWidth) {
            const leftThird = containerWidth / 3;
            const rightThird = containerWidth * 2 / 3;

            // Get current timeframe index
            const timeframes = [0.0833, 0.25, 0.5, 1, 4, 12, 24]; // 5m, 15m, 30m, 1H, 4H, 12H, 24H
            const currentIndex = timeframes.indexOf(currentTimeframe);

            if (tapX < leftThird && currentIndex > 0) {
                // Left third: Previous timeframe
                const prevTf = timeframes[currentIndex - 1];
                const prevButton = document.querySelector(`.tf-chip[data-tf="${prevTf}"]`);
                if (prevButton) {
                    showDoubleTapFeedback(tapX, containerWidth, 'Previous');
                    hapticFeedback('medium');
                    selectTimeframe(prevButton, prevTf);
                }
            } else if (tapX > rightThird && currentIndex < timeframes.length - 1) {
                // Right third: Next timeframe
                const nextTf = timeframes[currentIndex + 1];
                const nextButton = document.querySelector(`.tf-chip[data-tf="${nextTf}"]`);
                if (nextButton) {
                    showDoubleTapFeedback(tapX, containerWidth, 'Next');
                    hapticFeedback('medium');
                    selectTimeframe(nextButton, nextTf);
                }
            } else {
                // Center: Reset zoom (if chart has zoom capability)
                if (lwChart && typeof lwChart.timeScale === 'function') {
                    showDoubleTapFeedback(tapX, containerWidth, 'Reset');
                    hapticFeedback('light');
                    try {
                        lwChart.timeScale().fitContent();
                    } catch (e) {
                        console.debug('Chart zoom reset not available');
                    }
                }
            }
        }

        // Visual feedback for double-tap actions
        function showDoubleTapFeedback(tapX, containerWidth, action) {
            const feedback = document.createElement('div');
            const leftThird = containerWidth / 3;
            const rightThird = containerWidth * 2 / 3;

            let icon, position;
            if (tapX < leftThird) {
                icon = '';
                position = 'left: 20px;';
            } else if (tapX > rightThird) {
                icon = '';
                position = 'right: 20px;';
            } else {
                icon = '';
                position = 'left: 50%; transform: translate(-50%, -50%);';
            }

            feedback.innerHTML = `<span style="font-size: 32px;">${icon}</span><br><span style="font-size: 11px; opacity: 0.8;">${action}</span>`;
            feedback.style.cssText = `
                position: absolute;
                ${position}
                top: 50%;
                transform: translateY(-50%);
                padding: 16px 20px;
                background: rgba(0, 0, 0, 0.85);
                border: 1px solid rgba(251, 191, 36, 0.4);
                border-radius: 12px;
                color: #fbbf24;
                font-family: 'IBM Plex Mono', monospace;
                font-weight: 600;
                text-align: center;
                z-index: 10000;
                pointer-events: none;
                animation: doubleTapFeedback 0.6s ease;
            `;

            const chartContainer = document.getElementById('performanceChart');
            chartContainer.appendChild(feedback);

            setTimeout(() => feedback.remove(), 600);
        }

        // CSS animation for double-tap feedback
        const doubleTapStyle = document.createElement('style');
        doubleTapStyle.textContent = `
            @keyframes doubleTapFeedback {
                0% { opacity: 0; transform: translateY(-50%) scale(0.8); }
                50% { opacity: 1; transform: translateY(-50%) scale(1.1); }
                100% { opacity: 0; transform: translateY(-50%) scale(1); }
            }
        `;
        document.head.appendChild(doubleTapStyle);

        function toggleChartFullscreen() {
            hapticFeedback('medium'); // Haptic feedback on fullscreen toggle
            // Debounce rapid toggles
            if (fullscreenToggleTimeout) return;

            fullscreenToggleTimeout = setTimeout(() => {
                fullscreenToggleTimeout = null;
            }, 300);

            const card = document.getElementById('betaChartCard');
            const btn = document.getElementById('fullscreenBtn');
            const chartContainer = document.getElementById('performanceChart');
            const isFullscreen = card.classList.contains('fullscreen-chart');

            if (!isFullscreen) {
                // ============ ENTER FULLSCREEN ============

                // Add fullscreen class
                card.classList.add('fullscreen-chart');

                // Update button icon
                btn.innerHTML = `
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"></path>
                    </svg>
                `;

                // Hide bottom nav and notify scroll controller
                document.querySelector('.bottom-nav').style.display = 'none';
                if (window.bottomNavController) {
                    window.bottomNavController.setFullscreen(true);
                }

                // CRITICAL: Prevent body scroll but ALLOW chart gestures
                document.body.style.overflow = 'hidden';
                // Don't block touch-action at body level - let fullscreen-chart handle it
                // This is especially important in landscape mode where touch targets are smaller

                // Force chart resize after transition (100ms for CSS transition)
                setTimeout(() => {
                    if (lwChart && typeof lwChart.resize === 'function') {
                        const isLandscape = window.innerWidth > window.innerHeight;
                        const newHeight = window.innerHeight - (isLandscape ? 100 : 120);

                        lwChart.resize(
                            chartContainer.clientWidth,
                            newHeight
                        );

                        // Only use transform in portrait - it causes stacking issues in landscape
                        if (!isLandscape) {
                            // Force a reflow to ensure touch handlers are properly registered
                            chartContainer.style.transform = 'translateZ(0)';

                            // iOS Safari quirk fix
                            if (/iPhone|iPad|iPod/.test(navigator.userAgent)) {
                                chartContainer.style.webkitTransform = 'translateZ(0)';
                            }
                        } else {
                            // In landscape, ensure no transform interference
                            chartContainer.style.transform = 'none';
                            chartContainer.style.webkitTransform = 'none';
                        }
                    }
                }, 100);

                // Show interaction hint (first time only)
                if (!fullscreenHintShown) {
                    showFullscreenHint();
                    fullscreenHintShown = true;
                }

                // Add swipe-down gesture listener for exit
                addSwipeDownListener(card);

                // Push state for back button support
                history.pushState({ fullscreen: true }, '', window.location.href);

            } else {
                // ============ EXIT FULLSCREEN ============
                exitFullscreen(card, btn, chartContainer);
            }
        }

        function exitFullscreen(card, btn, chartContainer) {
            // Remove fullscreen class
            card.classList.remove('fullscreen-chart');

            // Update button icon
            btn.innerHTML = `
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
                </svg>
            `;

            // Show bottom nav and notify scroll controller
            document.querySelector('.bottom-nav').style.display = 'flex';
            if (window.bottomNavController) {
                window.bottomNavController.setFullscreen(false);
                window.bottomNavController.forceShow();
            }

            // CRITICAL: Restore body scroll
            document.body.style.overflow = '';

            // Resize chart back to normal
            setTimeout(() => {
                if (lwChart && typeof lwChart.resize === 'function') {
                    chartContainer.style.height = '350px';
                    chartContainer.style.transform = '';
                    chartContainer.style.webkitTransform = '';

                    lwChart.resize(
                        chartContainer.clientWidth,
                        350
                    );
                }
            }, 100);

            // Remove swipe listener
            removeSwipeDownListener(card);
        }

        function showFullscreenHint() {
            const hint = document.createElement('div');
            hint.className = 'fullscreen-chart-hint';
            hint.textContent = ' Pinch to zoom  Drag to pan';
            document.body.appendChild(hint);

            setTimeout(() => {
                hint.remove();
            }, 2500);
        }

        // =====================================================
        // SWIPE-DOWN TO EXIT GESTURE
        // =====================================================

        let swipeStartY = 0;
        let swipeCurrentY = 0;
        let isSwiping = false;

        function addSwipeDownListener(card) {
            const header = card.querySelector('.card-header');

            header.addEventListener('touchstart', handleSwipeStart, { passive: false });
            header.addEventListener('touchmove', handleSwipeMove, { passive: false });
            header.addEventListener('touchend', handleSwipeEnd, { passive: false });
        }

        function removeSwipeDownListener(card) {
            const header = card.querySelector('.card-header');

            header.removeEventListener('touchstart', handleSwipeStart);
            header.removeEventListener('touchmove', handleSwipeMove);
            header.removeEventListener('touchend', handleSwipeEnd);
        }

        function handleSwipeStart(e) {
            // Only start swipe if touch is near top of screen
            if (e.touches[0].clientY < 100) {
                swipeStartY = e.touches[0].clientY;
                isSwiping = true;
            }
        }

        function handleSwipeMove(e) {
            if (!isSwiping) return;

            swipeCurrentY = e.touches[0].clientY;
            const swipeDistance = swipeCurrentY - swipeStartY;

            // Only allow downward swipes
            if (swipeDistance > 0) {
                e.preventDefault(); // Prevent default scroll

                // Add visual feedback
                const card = document.getElementById('betaChartCard');
                const opacity = Math.max(0.5, 1 - (swipeDistance / 300));
                card.style.opacity = opacity;
            }
        }

        function handleSwipeEnd(e) {
            if (!isSwiping) return;

            const swipeDistance = swipeCurrentY - swipeStartY;
            const card = document.getElementById('betaChartCard');

            // If swiped down more than 70px, exit fullscreen (lowered for better touch response)
            if (swipeDistance > 70) {
                const btn = document.getElementById('fullscreenBtn');
                const chartContainer = document.getElementById('performanceChart');
                exitFullscreen(card, btn, chartContainer);
            }

            // Reset opacity
            card.style.opacity = '1';
            isSwiping = false;
            swipeStartY = 0;
            swipeCurrentY = 0;
        }

        // =====================================================
        // HANDLE DEVICE ORIENTATION CHANGES
        // =====================================================

        window.addEventListener('orientationchange', () => {
            const card = document.getElementById('betaChartCard');
            if (card && card.classList.contains('fullscreen-chart')) {
                setTimeout(() => {
                    const chartContainer = document.getElementById('performanceChart');
                    if (lwChart && typeof lwChart.resize === 'function') {
                        const isLandscape = window.innerWidth > window.innerHeight;
                        const newHeight = window.innerHeight - (isLandscape ? 100 : 120);

                        lwChart.resize(
                            chartContainer.clientWidth,
                            newHeight
                        );

                        // Update transform based on orientation
                        if (!isLandscape) {
                            chartContainer.style.transform = 'translateZ(0)';
                            if (/iPhone|iPad|iPod/.test(navigator.userAgent)) {
                                chartContainer.style.webkitTransform = 'translateZ(0)';
                            }
                        } else {
                            chartContainer.style.transform = 'none';
                            chartContainer.style.webkitTransform = 'none';
                        }
                    }
                }, 200); // Wait for orientation change to complete
            }
        });

        // =====================================================
        // HANDLE BACK BUTTON (Android)
        // =====================================================

        window.addEventListener('popstate', (e) => {
            const card = document.getElementById('betaChartCard');
            if (card && card.classList.contains('fullscreen-chart')) {
                e.preventDefault();
                const btn = document.getElementById('fullscreenBtn');
                const chartContainer = document.getElementById('performanceChart');
                exitFullscreen(card, btn, chartContainer);
                history.pushState(null, '', window.location.href);
            }
        });

        // =====================================================
        // HANDLE TAB SWITCH
        // =====================================================

        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                const card = document.getElementById('betaChartCard');
                if (card && card.classList.contains('fullscreen-chart')) {
                    const btn = document.getElementById('fullscreenBtn');
                    const chartContainer = document.getElementById('performanceChart');
                    exitFullscreen(card, btn, chartContainer);
                }
            }
        });

        function startPerfAutoRefresh() {
            if (perfAutoRefreshInterval) clearInterval(perfAutoRefreshInterval);
            perfAutoRefreshInterval = setInterval(() => {
                if (document.getElementById('performanceTab').style.display !== 'none') {
                    console.log('[PERFORMANCE] Auto-refreshing data...');
                    loadPerformanceData();
                }
            }, PERF_AUTO_REFRESH_MS);
        }

        function stopPerfAutoRefresh() {
            if (perfAutoRefreshInterval) {
                clearInterval(perfAutoRefreshInterval);
                perfAutoRefreshInterval = null;
            }
        }

        // ========================================
        // LAST UPDATE TIMESTAMP (Optimization #6)
        // Relative time display with animated pulse
        // ========================================
        let lastUpdateTimestamp = null;

        function updateLastUpdatedTime() {
            lastUpdateTimestamp = Date.now();
            updateRelativeTime(); // Update immediately
        }

        // Update relative time display (called every second)
        function updateRelativeTime() {
            const lastUpdated = document.getElementById('lastUpdated');
            if (!lastUpdated || !lastUpdateTimestamp) return;

            const secondsAgo = Math.floor((Date.now() - lastUpdateTimestamp) / 1000);

            let timeText;
            if (secondsAgo < 5) {
                timeText = 'Just now';
            } else if (secondsAgo < 60) {
                timeText = `${secondsAgo}s ago`;
            } else if (secondsAgo < 3600) {
                const minutesAgo = Math.floor(secondsAgo / 60);
                timeText = `${minutesAgo}m ago`;
            } else {
                const hoursAgo = Math.floor(secondsAgo / 3600);
                timeText = `${hoursAgo}h ago`;
            }

            lastUpdated.textContent = timeText;

            // Add color indication based on freshness
            if (secondsAgo < 10) {
                lastUpdated.style.color = 'var(--accent-positive)'; // Green for very fresh
            } else if (secondsAgo < 60) {
                lastUpdated.style.color = 'var(--text-accent)'; // Amber for recent
            } else {
                lastUpdated.style.color = 'var(--text-secondary)'; // Gray for stale
            }
        }

        // Start relative time updater (runs every second)
        setInterval(updateRelativeTime, 1000);

        // Initialize from localStorage on load
        function initPerformanceSettings() {
            const savedTf = localStorage.getItem('perfTimeframe');
            const savedAutoRefresh = localStorage.getItem('perfAutoRefresh');

            if (savedTf) {
                currentTimeframe = parseFloat(savedTf);
                // Update UI to match saved timeframe
                document.querySelectorAll('.tf-btn').forEach(btn => {
                    const btnTf = parseFloat(btn.getAttribute('data-tf'));
                    if (btnTf === currentTimeframe) {
                        btn.style.background = 'rgba(251, 191, 36, 0.2)';
                        btn.style.borderColor = 'var(--accent-amber)';
                        btn.style.color = 'var(--accent-amber)';
                    } else {
                        btn.style.background = 'var(--bg-secondary)';
                        btn.style.borderColor = 'var(--border-light)';
                        btn.style.color = 'var(--text-secondary)';
                    }
                });
                // Update labels - format as minutes for sub-hour timeframes
                let tfLabel;
                if (currentTimeframe < 1) {
                    tfLabel = Math.round(currentTimeframe * 60) + 'm';
                } else {
                    tfLabel = currentTimeframe + 'H';
                }
                const timeframeBadge = document.getElementById('timeframeBadge');
                const btcTimeframeLabel = document.getElementById('btcTimeframeLabel');
                const chartTimeframeLabel = document.getElementById('chartTimeframeLabel');
                if (timeframeBadge) timeframeBadge.textContent = tfLabel;
                if (btcTimeframeLabel) btcTimeframeLabel.textContent = tfLabel;
                if (chartTimeframeLabel) chartTimeframeLabel.textContent = tfLabel;
            }

            if (savedAutoRefresh === 'false') {
                perfAutoRefreshEnabled = true; // Set to true so toggle will turn it off
                toggleAutoRefresh(); // Toggle to false and update UI
            }
        }

        // Bybit symbol mapping for meme coins
        const BYBIT_SYMBOL_MAP = {
            'PEPE': '1000PEPEUSDT',
            'SHIB': '1000SHIBUSDT',
            'FLOKI': '1000FLOKIUSDT',
            'BONK': '1000BONKUSDT',
            'LUNC': '1000LUNCUSDT',
            'BABYDOGE': '1000000BABYDOGEUSDT',
            'SATS': '1000SATSUSDT',
            'RATS': '1000RATSUSDT',
            'CAT': '10000CATUSDT',
            'LADYS': '1000LADYSUSDT',
            'BTT': '1000000BTTUSDT',
            'XEC': '1000XECUSDT',
            'CHEEMS': '10000CHEEMSUSDT',
            'COQ': '1000000COQUSDT',
            'STARL': '10000STARLUSDT',
        };

        function normalizeSymbol(symbol) {
            symbol = symbol.toUpperCase();
            if (symbol.endsWith('USDT')) {
                symbol = symbol.slice(0, -4);
            } else if (symbol.endsWith('USD')) {
                symbol = symbol.slice(0, -3);
            }

            // Handle numeric prefixes
            for (const prefix of ['10000000', '1000000', '100000', '10000', '1000']) {
                if (symbol.startsWith(prefix)) {
                    return symbol.slice(prefix.length);
                }
            }
            return symbol;
        }

        async function fetchBybitTickers() {
            try {
                const response = await fetch('https://api.bybit.com/v5/market/tickers?category=linear', {
                    method: 'GET',
                    headers: { 'Accept': 'application/json' }
                });

                // Check for HTTP errors (403, 500, etc.) before parsing JSON
                if (!response.ok) {
                    console.warn('[BYBIT] HTTP error:', response.status);
                    return [];
                }

                const data = await response.json();

                if (data.retCode !== 0) {
                    throw new Error(data.retMsg || 'Bybit API error');
                }

                const tickers = data.result.list
                    .filter(t => t.symbol.endsWith('USDT'))
                    .map(t => ({
                        symbol: t.symbol,
                        normalized: normalizeSymbol(t.symbol),
                        price: parseFloat(t.lastPrice) || 0,
                        volume_24h: parseFloat(t.turnover24h) || 0,
                        price_change_pct: (parseFloat(t.price24hPcnt) || 0) * 100
                    }))
                    .sort((a, b) => b.volume_24h - a.volume_24h);

                return tickers;
            } catch (error) {
                console.error('Error fetching Bybit tickers:', error);
                return [];
            }
        }

        async function fetchBybitKlines(symbol, interval = '60', limit = 12) {
            try {
                const url = 'https://api.bybit.com/v5/market/kline?category=linear&symbol=' + symbol + '&interval=' + interval + '&limit=' + limit;
                const response = await fetch(url);

                // Check for HTTP errors before parsing JSON
                if (!response.ok) {
                    console.warn('[BYBIT] Klines HTTP error:', response.status, 'for', symbol);
                    return [];
                }

                const data = await response.json();

                if (data.retCode !== 0) {
                    return [];
                }

                // Bybit returns newest first, reverse for chronological order
                const candles = data.result.list.reverse().map(k => ({
                    timestamp: parseInt(k[0]),
                    open: parseFloat(k[1]),
                    high: parseFloat(k[2]),
                    low: parseFloat(k[3]),
                    close: parseFloat(k[4]),
                    volume: parseFloat(k[5])
                }));

                return candles;
            } catch (error) {
                console.error('Error fetching klines for ' + symbol + ':', error);
                return [];
            }
        }

        async function fetchHistoricalDataBybit(symbols, limit = 12) {
            const historicalData = {};

            for (const symbol of symbols) {
                // Check if symbol needs special mapping
                const bybitSymbol = BYBIT_SYMBOL_MAP[symbol] || (symbol + 'USDT');
                const candles = await fetchBybitKlines(bybitSymbol, '60', limit);

                if (candles.length > 0) {
                    historicalData[symbol] = candles;
                }

                // Rate limiting
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            return historicalData;
        }

        async function loadPerformanceData() {
            console.log('[PERFORMANCE] Loading performance data from cached API...');

            try {
                // Fetch pre-computed data from our cached API endpoint
                const response = await fetch(`/api/dashboard/beta-chart?timeframe=${currentTimeframe}`);

                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }

                const apiData = await response.json();
                console.log('[PERFORMANCE] API response received, from_cache:', apiData.from_cache);

                if (!apiData.chart_data || Object.keys(apiData.chart_data).length === 0) {
                    throw new Error('No chart data in API response');
                }

                // Transform API data to format expected by chart renderer
                // API returns: {symbol: [{timestamp, value}, ...]} (value is already rebased %)
                // Chart expects: {symbol: [{timestamp, close}, ...]} where close is raw price
                // We'll adapt renderPerformanceChart to handle pre-computed values

                // Update overview from API response
                const overview = apiData.overview;
                updatePerformanceOverviewFromAPI(overview);

                // Render chart with pre-computed rebased data
                renderPerformanceChartFromAPI(apiData.chart_data, apiData.performance_order);

                // Update last refreshed timestamp
                updateLastUpdatedTime();

                console.log('[PERFORMANCE] Data loaded successfully for ' + currentTimeframe + 'H timeframe');

            } catch (error) {
                console.error('[PERFORMANCE] Error loading performance data:', error);

                // Fallback to direct Bybit fetch if API fails
                console.log('[PERFORMANCE] Attempting fallback to direct Bybit fetch...');
                try {
                    await loadPerformanceDataDirect();
                } catch (fallbackError) {
                    console.error('[PERFORMANCE] Fallback also failed:', fallbackError);
                    showPerformanceError();
                }
            }
        }

        // Fallback function using direct Bybit API calls
        async function loadPerformanceDataDirect() {
            const tickers = await fetchBybitTickers();
            if (tickers.length === 0) throw new Error('No tickers fetched');

            const topSymbols = ['BTC'];
            for (const t of tickers) {
                if (t.normalized !== 'BTC' && !topSymbols.includes(t.normalized)) {
                    topSymbols.push(t.normalized);
                }
                if (topSymbols.length >= 25) break;
            }

            const historicalData = await fetchHistoricalDataBybit(topSymbols, currentTimeframe);
            updatePerformanceOverview(historicalData, tickers);
            renderPerformanceChart(historicalData);
            updateLastUpdatedTime();
        }

        // Update overview metrics from API response
        function updatePerformanceOverviewFromAPI(overview) {
            const btcChangeEl = document.getElementById('perfBtcChange');
            if (btcChangeEl) {
                const btcChange = overview.btc_change || 0;
                btcChangeEl.textContent = (btcChange >= 0 ? '+' : '') + btcChange.toFixed(2) + '%';
                btcChangeEl.style.color = btcChange >= 0 ? 'var(--accent-positive)' : 'var(--accent-negative)';
            }

            // Update symbols count, outperformers, underperformers from API
            const symbolCountEl = document.getElementById('perfSymbolCount');
            if (symbolCountEl && overview.symbols_count !== undefined) {
                symbolCountEl.textContent = overview.symbols_count;
            }

            const outperformersEl = document.getElementById('perfOutperformers');
            if (outperformersEl && overview.outperformers !== undefined) {
                outperformersEl.textContent = overview.outperformers;
            }

            const underperformersEl = document.getElementById('perfUnderperformers');
            if (underperformersEl && overview.underperformers !== undefined) {
                underperformersEl.textContent = overview.underperformers;
            }

            // Update Price HUD (Optimization #2)
            updatePriceHUD(overview.btc_price, overview.btc_change);
        }

        // Price HUD Update Function (Optimization #2)
        function updatePriceHUD(price, change24h) {
            const hudPrice = document.getElementById('hudPrice');
            const hudChangeValue = document.getElementById('hudChangeValue');
            const hudChangeArrow = document.getElementById('hudChangeArrow');
            const hudChange = document.getElementById('hudChange');

            if (!hudPrice || !hudChangeValue || !hudChangeArrow || !hudChange) return;

            // Update price with animation
            if (price) {
                hudPrice.classList.add('updating');
                hudPrice.textContent = '$' + (price >= 10000
                    ? Math.round(price).toLocaleString()
                    : price.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2}));
                setTimeout(() => hudPrice.classList.remove('updating'), 300);
            }

            // Update 24h change
            if (change24h !== undefined && change24h !== null) {
                const changeNum = parseFloat(change24h);
                const isPositive = changeNum >= 0;

                hudChangeValue.textContent = (isPositive ? '+' : '') + changeNum.toFixed(2) + '%';
                hudChangeArrow.textContent = isPositive ? '' : '';

                // Update color classes
                hudChange.classList.remove('positive', 'negative');
                hudChange.classList.add(isPositive ? 'positive' : 'negative');
            }
        }

        // Add floating tooltip to chart (uses globals: lwChart, lwSeriesData)
        function addFloatingTooltip(chartDiv) {
            const tooltip = document.createElement('div');
            tooltip.id = 'perfTooltip';
            tooltip.style.cssText = `
                position: absolute;
                display: none;
                padding: 8px 12px;
                background: rgba(10, 10, 10, 0.95);
                border: 1px solid rgba(251, 191, 36, 0.3);
                border-radius: 6px;
                font-family: 'IBM Plex Mono', monospace;
                font-size: 11px;
                color: #e0e0e0;
                pointer-events: none;
                z-index: 100;
                max-height: 180px;
                overflow-y: auto;
                backdrop-filter: blur(4px);
            `;
            chartDiv.style.position = 'relative';
            chartDiv.appendChild(tooltip);

            lwChart.subscribeCrosshairMove(param => {
                if (!param.time || param.seriesData.size === 0) {
                    tooltip.style.display = 'none';
                    return;
                }

                // Gather all values at this time
                const values = [];
                param.seriesData.forEach((priceData, series) => {
                    for (const data of lwSeriesData) {
                        if (data.series === series && data.visible) {
                            values.push({
                                symbol: data.symbol,
                                value: priceData.value,
                                color: data.color
                            });
                            break;
                        }
                    }
                });

                // Sort by value descending
                values.sort((a, b) => b.value - a.value);

                // Show top 5 and bottom 2 for readability
                const topValues = values.slice(0, 5);
                const bottomValues = values.slice(-2);
                const displayValues = [...topValues];
                if (values.length > 7) {
                    displayValues.push({ symbol: '...', value: null, color: '#666' });
                }
                displayValues.push(...bottomValues.filter(v => !topValues.includes(v)));

                tooltip.innerHTML = displayValues.map(v => {
                    if (v.value === null) return `<div style="color: #666; text-align: center;"></div>`;
                    const sign = v.value >= 0 ? '+' : '';
                    const valueColor = v.value >= 0 ? '#10b981' : '#ef4444';
                    return `<div style="display: flex; justify-content: space-between; gap: 12px;">
                        <span style="color: ${v.color}; font-weight: ${v.symbol === 'BTC' ? '700' : '400'};">${v.symbol}</span>
                        <span style="color: ${valueColor};">${sign}${v.value.toFixed(2)}%</span>
                    </div>`;
                }).join('');

                // Position tooltip
                const x = param.point.x;
                const y = param.point.y;
                const containerRect = chartDiv.getBoundingClientRect();
                const tooltipX = x > containerRect.width / 2 ? x - 140 : x + 20;
                tooltip.style.left = `${tooltipX}px`;
                tooltip.style.top = `${Math.max(10, y - 60)}px`;
                tooltip.style.display = 'block';
            });
        }

        // Render chart from pre-computed API data (values are already rebased %)
        function renderPerformanceChartFromAPI(chartData, performanceOrder) {
            const chartDiv = document.getElementById('performanceChart');
            if (!chartDiv) return;

            if (Object.keys(chartData).length === 0) {
                chartDiv.innerHTML = '<div style="text-align: center; padding: 60px; color: var(--text-secondary);">No data available</div>';
                return;
            }

            // Save current zoom state before destroying chart
            if (lwChart) {
                try {
                    lwChartVisibleRange = lwChart.timeScale().getVisibleRange();
                } catch (e) {
                    lwChartVisibleRange = null;
                }
            }

            // Clear previous chart and tooltip
            chartDiv.innerHTML = '';
            const existingTooltip = document.getElementById('perfTooltip');
            if (existingTooltip) existingTooltip.remove();

            // Color palette
            const colorPalette = [
                '#00FF7F', '#FF1493', '#00CED1', '#FFD700', '#FF6347',
                '#7B68EE', '#FF69B4', '#20B2AA', '#9370DB', '#32CD32',
                '#FF4500', '#00BFFF', '#ADFF2F', '#FF00FF', '#00FA9A',
                '#DC143C', '#00FFFF', '#7FFF00', '#FF8C00', '#8A2BE2'
            ];

            // Create Lightweight Chart
            lwChart = LightweightCharts.createChart(chartDiv, {
                width: chartDiv.clientWidth,
                height: 320,
                layout: {
                    background: { color: '#0a0a0a' },
                    textColor: '#9ca3af',
                    fontSize: 10
                },
                grid: {
                    vertLines: { color: 'rgba(255, 191, 0, 0.06)' },
                    horzLines: { color: 'rgba(255, 191, 0, 0.06)' }
                },
                crosshair: {
                    mode: LightweightCharts.CrosshairMode.Magnet,
                    vertLine: {
                        color: 'rgba(251, 191, 36, 0.4)',
                        width: 1,
                        style: LightweightCharts.LineStyle.Dashed,
                        labelBackgroundColor: '#fbbf24'
                    },
                    horzLine: {
                        color: 'rgba(251, 191, 36, 0.4)',
                        width: 1,
                        style: LightweightCharts.LineStyle.Dashed,
                        labelBackgroundColor: '#333'
                    }
                },
                rightPriceScale: {
                    borderColor: 'rgba(255, 191, 0, 0.15)',
                    scaleMargins: { top: 0.08, bottom: 0.08 },
                    entireTextOnly: true
                },
                timeScale: {
                    borderColor: 'rgba(255, 191, 0, 0.15)',
                    timeVisible: true,
                    secondsVisible: false,
                    rightOffset: 5
                },
                handleScale: { mouseWheel: false, pinch: true },
                handleScroll: { mouseWheel: false, pressedMouseMove: true, horzTouchDrag: true, vertTouchDrag: false }
            });

            const symbolPerformances = [];
            let colorIndex = 0;
            lwSeries = {};
            lwSeriesData = [];
            let allTimePoints = [];

            // Use performance order from API for consistent legend sorting
            const symbols = performanceOrder || Object.keys(chartData);

            symbols.forEach(symbol => {
                const dataPoints = chartData[symbol];
                if (!dataPoints || dataPoints.length === 0) return;

                // Data is already rebased - just convert timestamp to seconds
                const data = dataPoints.map(p => ({
                    time: Math.floor(p.timestamp / 1000),
                    value: p.value
                }));

                // Collect time points for zero line
                data.forEach(d => {
                    if (!allTimePoints.includes(d.time)) {
                        allTimePoints.push(d.time);
                    }
                });

                // Final performance value
                const finalValue = data[data.length - 1].value;
                symbolPerformances.push({ symbol, finalValue });

                // Determine color (BTC always orange)
                const color = symbol === 'BTC' ? '#FFA500' : colorPalette[colorIndex % colorPalette.length];
                if (symbol !== 'BTC') colorIndex++;

                // Create line series
                const series = lwChart.addLineSeries({
                    color: color,
                    lineWidth: symbol === 'BTC' ? 2.5 : 1.2,
                    lastValueVisible: true,
                    priceLineVisible: false,
                    title: symbol,
                    crosshairMarkerRadius: symbol === 'BTC' ? 5 : 3,
                    crosshairMarkerBorderWidth: symbol === 'BTC' ? 2 : 1,
                    crosshairMarkerBackgroundColor: color
                });

                series.setData(data);
                lwSeries[symbol] = { series, color, data };
                lwSeriesData.push({ symbol, finalValue, color, visible: true, series });
            });

            // Add zero reference line
            if (allTimePoints.length > 0) {
                allTimePoints.sort((a, b) => a - b);
                const zeroLine = lwChart.addLineSeries({
                    color: 'rgba(136, 136, 136, 0.5)',
                    lineWidth: 1,
                    lineStyle: LightweightCharts.LineStyle.Dashed,
                    lastValueVisible: false,
                    priceLineVisible: false,
                    crosshairMarkerVisible: false
                });
                zeroLine.setData(allTimePoints.map(t => ({ time: t, value: 0 })));
            }

            // Restore saved zoom state or center latest data in middle of chart
            if (lwChartVisibleRange) {
                try {
                    lwChart.timeScale().setVisibleRange(lwChartVisibleRange);
                } catch (e) {
                    lwChart.timeScale().fitContent();
                }
            } else if (allTimePoints.length >= 2) {
                // Center the latest data point in the middle of the chart
                const dataStart = allTimePoints[0];
                const dataEnd = allTimePoints[allTimePoints.length - 1];
                const totalRange = dataEnd - dataStart;

                // Show the latest point in the middle of the view
                // This means we need to show half the data before and extend view after
                const visibleRange = totalRange; // Show all data
                const centerPoint = dataEnd - (visibleRange * 0.5);

                lwChart.timeScale().setVisibleRange({
                    from: Math.max(dataStart, centerPoint),
                    to: dataEnd + (visibleRange * 0.5)
                });
            } else {
                lwChart.timeScale().fitContent();
            }

            // Render legend sorted by performance
            renderPerformanceLegend(lwSeriesData);

            // Add floating tooltip
            addFloatingTooltip(chartDiv);

            // Handle resize
            const resizeObserver = new ResizeObserver(() => {
                if (lwChart) lwChart.applyOptions({ width: chartDiv.clientWidth });
            });
            resizeObserver.observe(chartDiv);
        }

        // Bridge function: converts lwSeriesData format to renderCollapsibleLegend format
        function renderPerformanceLegend(seriesData) {
            // Sort by performance (finalValue)
            const sorted = [...seriesData].sort((a, b) => b.finalValue - a.finalValue);

            // Convert to format expected by renderCollapsibleLegend
            const traces = sorted.map(s => ({
                name: s.symbol + ' ' + (s.finalValue >= 0 ? '+' : '') + s.finalValue.toFixed(1) + '%',
                line: { color: s.color }
            }));

            // Render using existing collapsible legend function
            renderCollapsibleLegend(traces, 'performanceChartLegend');
        }

        function updatePerformanceOverview(historicalData, tickers) {
            // Calculate BTC 12h change
            const btcData = historicalData['BTC'];
            let btcChange = 0;
            if (btcData && btcData.length > 0) {
                const firstPrice = btcData[0].close;
                const lastPrice = btcData[btcData.length - 1].close;
                btcChange = ((lastPrice - firstPrice) / firstPrice) * 100;
            }

            // Calculate outperformers/underperformers
            let outperformers = 0;
            let underperformers = 0;

            Object.keys(historicalData).forEach(symbol => {
                const candles = historicalData[symbol];
                if (candles.length > 0) {
                    const firstPrice = candles[0].close;
                    const lastPrice = candles[candles.length - 1].close;
                    const change = ((lastPrice - firstPrice) / firstPrice) * 100;

                    if (change > 1.0) outperformers++;
                    if (change < -3.0) underperformers++;
                }
            });

            // Update UI
            const btcChangeEl = document.getElementById('perfBtcChange');
            if (btcChangeEl) {
                btcChangeEl.textContent = (btcChange >= 0 ? '+' : '') + btcChange.toFixed(2) + '%';
                btcChangeEl.style.color = btcChange >= 0 ? 'var(--accent-positive)' : 'var(--accent-negative)';
            }

            const symbolCountEl = document.getElementById('perfSymbolCount');
            if (symbolCountEl) {
                symbolCountEl.textContent = Object.keys(historicalData).length;
            }

            const outperformersEl = document.getElementById('perfOutperformers');
            if (outperformersEl) {
                outperformersEl.textContent = outperformers;
            }

            const underperformersEl = document.getElementById('perfUnderperformers');
            if (underperformersEl) {
                underperformersEl.textContent = underperformers;
            }
        }

        // Store chart instance and series globally for toggle functionality
        // Note: lwChart and lwChartVisibleRange declared earlier to avoid TDZ errors
        let lwSeries = {};
        let lwSeriesData = [];
        let labelsVisible = true;
        let topBottomOnly = false;

        // Toggle all chart labels on/off
        function toggleChartLabels() {
            labelsVisible = !labelsVisible;
            const btn = document.getElementById('toggleLabelsBtn');

            if (labelsVisible) {
                btn.innerHTML = '<span id="toggleLabelsIcon"></span> LABELS: ON';
                btn.style.background = 'rgba(251, 191, 36, 0.15)';
            } else {
                btn.innerHTML = '<span id="toggleLabelsIcon"></span> LABELS: OFF';
                btn.style.background = 'rgba(100, 100, 100, 0.15)';
            }

            applyLabelVisibility();
        }

        // Toggle top/bottom 5 only mode
        function toggleTopBottomOnly() {
            topBottomOnly = !topBottomOnly;
            const btn = document.getElementById('toggleTopBottomBtn');

            if (topBottomOnly) {
                btn.textContent = 'TOP/BOTTOM 5: ON';
                btn.style.background = 'rgba(6, 182, 212, 0.3)';
                btn.style.borderColor = 'rgba(6, 182, 212, 0.8)';
            } else {
                btn.textContent = 'TOP/BOTTOM 5: OFF';
                btn.style.background = 'rgba(6, 182, 212, 0.15)';
                btn.style.borderColor = 'rgba(6, 182, 212, 0.4)';
            }

            applyLabelVisibility();
        }

        // Apply label visibility based on current toggle states
        function applyLabelVisibility() {
            if (!lwSeriesData || lwSeriesData.length === 0) return;

            // Sort to find top 5 and bottom 5 (handle both finalValue and finalChange property names)
            const sorted = [...lwSeriesData].sort((a, b) => {
                const aVal = a.finalValue !== undefined ? a.finalValue : a.finalChange;
                const bVal = b.finalValue !== undefined ? b.finalValue : b.finalChange;
                return bVal - aVal;
            });
            const top5 = sorted.slice(0, 5).map(s => s.symbol);
            const bottom5 = sorted.slice(-5).map(s => s.symbol);
            const topBottomSymbols = new Set([...top5, ...bottom5, 'BTC']); // Always include BTC

            lwSeriesData.forEach(seriesInfo => {
                if (!seriesInfo.series) return;

                let showLabel = labelsVisible;

                // If topBottomOnly is enabled, further filter
                if (showLabel && topBottomOnly) {
                    showLabel = topBottomSymbols.has(seriesInfo.symbol);
                }

                seriesInfo.series.applyOptions({
                    lastValueVisible: showLabel,
                    title: showLabel ? seriesInfo.symbol : ''
                });
            });
        }

        function renderPerformanceChart(historicalData) {
            const chartDiv = document.getElementById('performanceChart');

            if (!chartDiv) return;

            if (Object.keys(historicalData).length === 0) {
                chartDiv.innerHTML = '<div style="text-align: center; padding: 60px; color: var(--text-secondary);">No data available</div>';
                return;
            }

            // Save current zoom state before destroying chart
            if (lwChart) {
                try {
                    lwChartVisibleRange = lwChart.timeScale().getVisibleRange();
                } catch (e) {
                    lwChartVisibleRange = null;
                }
            }

            // Clear previous chart and tooltip
            chartDiv.innerHTML = '';
            const existingTooltip = document.getElementById('perfTooltip');
            if (existingTooltip) existingTooltip.remove();

            // Color palette
            const colorPalette = [
                '#00FF7F', '#FF1493', '#00CED1', '#FFD700', '#FF6347',
                '#7B68EE', '#FF69B4', '#20B2AA', '#9370DB', '#32CD32',
                '#FF4500', '#00BFFF', '#ADFF2F', '#FF00FF', '#00FA9A',
                '#DC143C', '#00FFFF', '#7FFF00', '#FF8C00', '#8A2BE2'
            ];

            // Create Lightweight Chart with optimized settings
            lwChart = LightweightCharts.createChart(chartDiv, {
                width: chartDiv.clientWidth,
                height: 320,
                layout: {
                    background: { color: '#0a0a0a' },
                    textColor: '#9ca3af',
                    fontSize: 10
                },
                grid: {
                    vertLines: { color: 'rgba(255, 191, 0, 0.06)' },
                    horzLines: { color: 'rgba(255, 191, 0, 0.06)' }
                },
                crosshair: {
                    mode: LightweightCharts.CrosshairMode.Magnet, // Snaps to data points
                    vertLine: {
                        color: 'rgba(251, 191, 36, 0.4)',
                        width: 1,
                        style: LightweightCharts.LineStyle.Dashed,
                        labelBackgroundColor: '#fbbf24'
                    },
                    horzLine: {
                        color: 'rgba(251, 191, 36, 0.4)',
                        width: 1,
                        style: LightweightCharts.LineStyle.Dashed,
                        labelBackgroundColor: '#333'
                    }
                },
                rightPriceScale: {
                    borderColor: 'rgba(255, 191, 0, 0.15)',
                    scaleMargins: { top: 0.08, bottom: 0.08 },
                    entireTextOnly: true
                },
                timeScale: {
                    borderColor: 'rgba(255, 191, 0, 0.15)',
                    timeVisible: true,
                    secondsVisible: false,
                    rightOffset: 5
                },
                handleScale: {
                    mouseWheel: false,
                    pinch: true
                },
                handleScroll: {
                    mouseWheel: false,
                    pressedMouseMove: true,
                    horzTouchDrag: true,
                    vertTouchDrag: false
                }
            });

            const symbolPerformances = [];
            let colorIndex = 0;
            lwSeries = {};
            lwSeriesData = [];

            // Collect all time points for zero line
            let allTimePoints = [];

            Object.keys(historicalData).forEach(symbol => {
                const candles = historicalData[symbol];
                if (candles.length === 0) return;

                const initialPrice = candles[0].close;
                const data = candles.map(c => ({
                    time: Math.floor(c.timestamp / 1000),
                    value: ((c.close - initialPrice) / initialPrice) * 100
                }));

                if (allTimePoints.length === 0) {
                    allTimePoints = data.map(d => d.time);
                }

                const finalChange = data[data.length - 1].value;
                symbolPerformances.push({ symbol, finalChange, data });

                const color = symbol === 'BTC' ? '#FFA500' : colorPalette[colorIndex++ % colorPalette.length];

                const series = lwChart.addLineSeries({
                    color: color,
                    lineWidth: symbol === 'BTC' ? 2.5 : 1.2,
                    priceFormat: {
                        type: 'custom',
                        formatter: price => `${price.toFixed(1)}%`
                    },
                    lastValueVisible: false, // Clean - no overlapping labels
                    priceLineVisible: false,
                    crosshairMarkerVisible: true,
                    crosshairMarkerRadius: symbol === 'BTC' ? 5 : 3,
                    crosshairMarkerBorderColor: color,
                    crosshairMarkerBackgroundColor: '#0a0a0a'
                });

                series.setData(data);

                lwSeries[symbol] = series;
                lwSeriesData.push({
                    symbol: symbol,
                    finalChange: finalChange,
                    color: color,
                    series: series,
                    visible: true
                });
            });

            // Add zero reference line (renders behind other series)
            if (allTimePoints.length > 0) {
                const zeroLine = lwChart.addLineSeries({
                    color: 'rgba(128, 128, 128, 0.5)',
                    lineWidth: 1,
                    lineStyle: LightweightCharts.LineStyle.Dashed,
                    lastValueVisible: false,
                    priceLineVisible: false,
                    crosshairMarkerVisible: false
                });
                zeroLine.setData(allTimePoints.map(t => ({ time: t, value: 0 })));
            }

            // Restore saved zoom state or set tight view starting at data origin
            if (lwChartVisibleRange) {
                try {
                    lwChart.timeScale().setVisibleRange(lwChartVisibleRange);
                } catch (e) {
                    lwChart.timeScale().fitContent();
                }
            } else if (allTimePoints.length >= 2) {
                // Set view to start exactly where lines begin (no empty space on left)
                allTimePoints.sort((a, b) => a - b);
                const dataStart = allTimePoints[0];
                const dataEnd = allTimePoints[allTimePoints.length - 1];
                // Add small padding on right for labels (5% of range)
                const rangePadding = (dataEnd - dataStart) * 0.05;
                lwChart.timeScale().setVisibleRange({
                    from: dataStart,
                    to: dataEnd + rangePadding
                });
            } else {
                lwChart.timeScale().fitContent();
            }

            // Add floating tooltip
            addFloatingTooltip(chartDiv);

            // Handle resize
            const resizeObserver = new ResizeObserver(entries => {
                if (lwChart && chartDiv.clientWidth > 0) {
                    lwChart.applyOptions({ width: chartDiv.clientWidth });
                }
            });
            resizeObserver.observe(chartDiv);

            // Sort by performance and create legend data
            symbolPerformances.sort((a, b) => b.finalChange - a.finalChange);
            const legendTraces = symbolPerformances.map(sp => {
                const seriesInfo = lwSeriesData.find(s => s.symbol === sp.symbol);
                return {
                    name: sp.symbol + ' ' + (sp.finalChange >= 0 ? '+' : '') + sp.finalChange.toFixed(1) + '%',
                    line: { color: seriesInfo ? seriesInfo.color : '#ffffff' }
                };
            });

            // Create collapsible legend below chart
            renderCollapsibleLegend(legendTraces, 'performanceChartLegend');
        }

        function renderCollapsibleLegend(traces, containerId) {
            const container = document.getElementById(containerId);
            if (!container) return;

            // Split into top performers (first 8) and others
            const topPerformers = traces.slice(0, 8);
            const others = traces.slice(8);

            let html = `
                <button id="legendToggle" onclick="toggleLegend()" style="
                    width: 100%;
                    padding: 10px;
                    background: rgba(26, 26, 26, 0.8);
                    border: 1px solid #fbbf24;
                    border-radius: 8px;
                    color: #fbbf24;
                    font-family: 'IBM Plex Mono', monospace;
                    font-size: 11px;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    justify-content: space-between;
                    transition: all 0.2s ease;
                ">
                    <span>VIEW ALL ${traces.length} SYMBOLS</span>
                    <span id="legendToggleIcon" style="font-size: 14px;"></span>
                </button>
                <div id="legendContent" style="
                    max-height: 0;
                    overflow: hidden;
                    transition: max-height 0.3s ease;
                    background: rgba(10, 10, 10, 0.95);
                    border: 1px solid rgba(251, 191, 36, 0.3);
                    border-top: none;
                    border-radius: 0 0 8px 8px;
                ">
                    <div style="padding: 12px; max-height: 200px; overflow-y: auto;">
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">
            `;

            // Render all traces in a compact grid
            traces.forEach(trace => {
                const symbol = trace.name.split(' ')[0];
                const change = trace.name.split(' ').slice(1).join(' ');
                html += `
                    <div onclick="toggleTrace('${symbol}')" style="
                        display: flex;
                        align-items: center;
                        padding: 6px 8px;
                        background: rgba(26, 26, 26, 0.6);
                        border-radius: 6px;
                        cursor: pointer;
                        transition: all 0.15s ease;
                        border: 1px solid transparent;
                        font-family: 'IBM Plex Mono', monospace;
                    " onmouseover="this.style.borderColor='${trace.line.color}'" onmouseout="this.style.borderColor='transparent'">
                        <div style="
                            width: 10px;
                            height: 10px;
                            background: ${trace.line.color};
                            border-radius: 2px;
                            margin-right: 6px;
                            flex-shrink: 0;
                        "></div>
                        <div style="
                            font-size: 10px;
                            color: #e0e0e0;
                            overflow: hidden;
                            text-overflow: ellipsis;
                            white-space: nowrap;
                        ">
                            <span style="font-weight: 600;">${symbol}</span>
                            <span style="color: ${change.startsWith('+') ? '#10b981' : '#ef4444'}; font-size: 9px; margin-left: 2px;">${change}</span>
                        </div>
                    </div>
                `;
            });

            html += `
                        </div>
                    </div>
                </div>
            `;

            container.innerHTML = html;
        }

        function toggleLegend() {
            const content = document.getElementById('legendContent');
            const icon = document.getElementById('legendToggleIcon');
            const toggle = document.getElementById('legendToggle');

            if (content.style.maxHeight === '0px' || content.style.maxHeight === '') {
                content.style.maxHeight = '240px';
                icon.textContent = '';
                toggle.style.borderRadius = '8px 8px 0 0';
            } else {
                content.style.maxHeight = '0px';
                icon.textContent = '';
                toggle.style.borderRadius = '8px';
            }
        }

        function toggleTrace(symbol) {
            // Find the series in the Lightweight Chart
            const seriesInfo = lwSeriesData.find(s => s.symbol === symbol);
            if (!seriesInfo || !seriesInfo.series) return;

            // Toggle visibility by changing line width (Lightweight Charts doesn't have direct visibility toggle)
            seriesInfo.visible = !seriesInfo.visible;

            if (seriesInfo.visible) {
                // Show the series
                seriesInfo.series.applyOptions({
                    lineWidth: symbol === 'BTC' ? 2.5 : 1.2,
                    color: seriesInfo.color
                });
            } else {
                // Hide the series by making it transparent
                seriesInfo.series.applyOptions({
                    lineWidth: 0,
                    color: 'transparent'
                });
            }
        }

        function renderTopPerformers(historicalData, type) {
            const performances = [];

            Object.keys(historicalData).forEach(symbol => {
                const candles = historicalData[symbol];
                if (candles.length > 0) {
                    const firstPrice = candles[0].close;
                    const lastPrice = candles[candles.length - 1].close;
                    const change = ((lastPrice - firstPrice) / firstPrice) * 100;
                    performances.push({ symbol, change });
                }
            });

            // Sort and get top 10
            performances.sort((a, b) => type === 'gainers' ? b.change - a.change : a.change - b.change);
            const top10 = performances.slice(0, 10);

            // Render
            const listId = type === 'gainers' ? 'perfTopGainers' : 'perfTopLosers';
            const listEl = document.getElementById(listId);

            if (!listEl) return;

            listEl.innerHTML = '';

            top10.forEach(item => {
                const changeColor = item.change >= 0 ? 'var(--accent-positive)' : 'var(--accent-negative)';
                const changeText = (item.change >= 0 ? '+' : '') + item.change.toFixed(2) + '%';

                listEl.innerHTML += '<div style="display: flex; justify-content: space-between; align-items: center; padding: 12px; background: var(--bg-secondary); border-radius: 8px; border: 1px solid var(--border-light);"><div><div style="font-size: 14px; font-weight: 600; color: var(--text-primary); font-family: \'IBM Plex Mono\', monospace;">' + item.symbol + '</div></div><div style="font-size: 18px; font-weight: 700; color: ' + changeColor + '; font-family: \'IBM Plex Mono\', monospace;">' + changeText + '</div></div>';
            });
        }

        function showPerformanceError() {
            const perfBtcChange = document.getElementById('perfBtcChange');
            if (perfBtcChange) perfBtcChange.textContent = '--';

            const perfSymbolCount = document.getElementById('perfSymbolCount');
            if (perfSymbolCount) perfSymbolCount.textContent = '--';

            const perfOutperformers = document.getElementById('perfOutperformers');
            if (perfOutperformers) perfOutperformers.textContent = '--';

            const perfUnderperformers = document.getElementById('perfUnderperformers');
            if (perfUnderperformers) perfUnderperformers.textContent = '--';

            const performanceChart = document.getElementById('performanceChart');
            if (performanceChart) {
                performanceChart.innerHTML = '<div style="text-align: center; padding: 60px; color: var(--accent-negative);">Error loading performance data</div>';
            }

            const perfTopGainers = document.getElementById('perfTopGainers');
            if (perfTopGainers) {
                perfTopGainers.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-secondary);">Unable to load data</div>';
            }

            const perfTopLosers = document.getElementById('perfTopLosers');
            if (perfTopLosers) {
                perfTopLosers.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-secondary);">Unable to load data</div>';
            }
        }

        // =====================================================
        // BITCOIN BETA DATA FUNCTIONS
        // =====================================================

        async function loadBetaData() {
            console.log('[BETA] Loading beta data...');
            try {
                const response = await fetch('/api/bitcoin-beta/realtime');
                const data = await response.json();

                if (data.status === 'success' && data.overview && data.symbols) {
                    // Update overview with real data
                    updateBetaOverview({
                        beta_coefficient: data.overview.market_beta || 1.0,
                        correlation: data.overview.avg_correlation || 0.5,
                        market_regime: data.overview.market_regime || 'NEUTRAL',
                        volatility_ratio: data.overview.market_beta || 1.0
                    });

                    // Transform symbols data for display
                    const betaSymbols = data.symbols.map(sym => ({
                        symbol: sym.symbol.replace('USDT', ''),
                        price: sym.last_price || 0,
                        change_24h: sym.change_24h || 0,
                        beta: sym.beta_30d || 1.0,
                        correlation: sym.correlation_30d || 0.5,
                        volume_24h: sym.volume_24h || 0,
                        risk_category: sym.risk_category?.category || 'Market Neutral',
                        risk_color: sym.risk_category?.color || '#6B7280',
                        alpha: sym.alpha_30d || 0,
                        r_squared: sym.r_squared_30d || 0
                    }));

                    // Beta symbols data is available for future use if needed
                    // The MTF Rankings card handles its own data loading via loadMTFRankings()

                    console.log('[BETA] Data loaded successfully, symbols:', betaSymbols.length);
                } else {
                    throw new Error('Invalid beta data format');
                }
            } catch (error) {
                console.error('[BETA] Error loading beta data:', error);
                updateBetaOverview({
                    beta_coefficient: 0,
                    correlation: 0,
                    market_regime: 'unknown',
                    volatility_ratio: 0
                });
                showBetaError();
            }
        }

        function updateBetaOverview(data) {
            // Update beta coefficient
            const betaCoef = document.getElementById('betaCoefficient');
            if (betaCoef) {
                const beta = data.beta_coefficient || 0;
                betaCoef.textContent = beta.toFixed(2);
                betaCoef.style.color = beta > 1 ? 'var(--accent-negative)' : beta < 1 ? 'var(--accent-positive)' : 'var(--text-primary)';
            }

            // Update correlation
            const correlation = document.getElementById('btcCorrelation');
            if (correlation) {
                const corr = data.correlation || 0;
                correlation.textContent = (corr * 100).toFixed(0) + '%';
                correlation.style.color = corr > 0.7 ? 'var(--accent-positive)' : corr < 0.3 ? 'var(--accent-negative)' : 'var(--accent-warning)';
            }

            // Update market regime (Beta section)
            // Format: "Category: Label" (e.g., "Bearish: Risk-Off")
            const regimeEl = document.getElementById('betaMarketRegime');
            if (regimeEl) {
                let marketRegime = data.market_regime || 'Neutral: Unknown';
                if (typeof marketRegime === 'object') {
                    marketRegime = marketRegime.regime || 'Neutral: Unknown';
                }
                marketRegime = String(marketRegime);
                regimeEl.textContent = marketRegime;

                // Extract category for coloring (before the colon)
                const category = marketRegime.split(':')[0].trim().toUpperCase();
                if (category.includes('BULLISH')) {
                    regimeEl.style.background = 'rgba(76, 175, 80, 0.2)';
                } else if (category.includes('BEARISH')) {
                    regimeEl.style.background = 'rgba(244, 67, 54, 0.2)';
                } else {
                    regimeEl.style.background = 'rgba(255, 191, 0, 0.2)';
                }
            }

            // Update volatility ratio
            const volRatio = document.getElementById('volatilityRatio');
            if (volRatio) {
                const ratio = data.volatility_ratio || 0;
                volRatio.textContent = ratio.toFixed(2) + 'x';
            }
        }

        // =====================================================
        // BETA RANKINGS FUNCTIONS (MULTI-TIMEFRAME)
        // =====================================================

        async function loadMTFRankings() {
            const cluster = document.getElementById('mtfClusterSelector')?.value || 'day_trading';
            const rankingsList = document.getElementById('mtfRankingsList');

            if (!rankingsList) return;

            console.log('[MTF] Loading rankings for cluster:', cluster);

            try {
                const response = await fetch(`/api/altcoins/mtf-ranking?cluster=${cluster}&top_n=8`);
                const data = await response.json();

                if (data.status === 'success' && data.data && data.data.rankings) {
                    renderMTFRankings(data.data.rankings);
                } else {
                    throw new Error('Invalid MTF data format');
                }
            } catch (error) {
                console.error('[MTF] Error loading rankings:', error);
                rankingsList.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-secondary);">Unable to load MTF rankings</div>';
            }
        }

        // =====================================================
        // MTF RANKINGS VISUALIZATION HELPERS
        // =====================================================

        /**
         * Generate circular progress ring for MTF score (0-100)
         * @param {number} score - MTF score (0-100)
         * @param {number} size - SVG size in pixels
         * @returns {string} SVG HTML string
         */
        function generateScoreRing(score, size = 64) {
            const radius = (size - 8) / 2;
            const circumference = 2 * Math.PI * radius;
            const offset = circumference - (score / 100) * circumference;

            // Color gradient based on score
            let strokeColor = '#ef4444'; // red (0-40)
            if (score >= 70) strokeColor = '#10b981'; // green (70-100)
            else if (score >= 50) strokeColor = '#fbbf24'; // amber (50-70)
            else if (score >= 40) strokeColor = '#f59e0b'; // orange (40-50)

            return `
                <svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" style="transform: rotate(-90deg); display: block;">
                    <!-- Background ring -->
                    <circle
                        cx="${size/2}"
                        cy="${size/2}"
                        r="${radius}"
                        fill="none"
                        stroke="rgba(255,255,255,0.08)"
                        stroke-width="4"
                    />
                    <!-- Progress ring -->
                    <circle
                        cx="${size/2}"
                        cy="${size/2}"
                        r="${radius}"
                        fill="none"
                        stroke="${strokeColor}"
                        stroke-width="4"
                        stroke-dasharray="${circumference}"
                        stroke-dashoffset="${offset}"
                        stroke-linecap="round"
                        style="transition: stroke-dashoffset 0.6s ease;"
                    />
                    <!-- Inner score text -->
                    <text
                        x="${size/2}"
                        y="${size/2}"
                        text-anchor="middle"
                        dominant-baseline="middle"
                        fill="${strokeColor}"
                        font-size="${size * 0.35}"
                        font-weight="800"
                        font-family="'IBM Plex Mono', monospace"
                        style="transform: rotate(90deg); transform-origin: ${size/2}px ${size/2}px;"
                    >${Math.round(score)}</text>
                </svg>
            `;
        }

        /**
         * Generate timeframe performance sparkline
         * @param {Object} timeframeDetails - Object with timeframe keys and performance values
         * @returns {string} SVG HTML string
         */
        function generatePerformanceSparkline(timeframeDetails) {
            if (!timeframeDetails || Object.keys(timeframeDetails).length === 0) {
                return '<div style="height: 40px; display: flex; align-items: center; color: var(--text-tertiary); font-size: 10px;">No data</div>';
            }

            const timeframes = Object.entries(timeframeDetails).map(([tf, value]) => {
                // Compact label format for comprehensive mode (7 TFs)
                const numTf = parseFloat(tf);
                let label;
                if (numTf < 1) {
                    label = `${Math.round(numTf * 60)}m`; // 0.25 -> 15m, 0.5 -> 30m
                } else {
                    label = `${Math.round(numTf)}h`;
                }
                return {
                    label: label,
                    value: parseFloat(value) || 0
                };
            });

            const tfCount = timeframes.length;
            // Dynamic sizing: wider for more timeframes
            const width = tfCount <= 3 ? 100 : tfCount <= 5 ? 130 : 160;
            const height = 40;
            const gap = tfCount <= 3 ? 4 : tfCount <= 5 ? 3 : 2;
            const barWidth = (width / tfCount) - gap;
            const fontSize = tfCount <= 3 ? 8 : tfCount <= 5 ? 7 : 6;
            const maxAbsValue = Math.max(...timeframes.map(tf => Math.abs(tf.value)));
            const scale = maxAbsValue > 0 ? (height / 2 - 8) / maxAbsValue : 1;

            const bars = timeframes.map((tf, i) => {
                const barHeight = Math.max(2, Math.abs(tf.value) * scale);
                const isPositive = tf.value >= 0;
                const y = isPositive ? (height / 2 - barHeight) : height / 2;
                const color = isPositive ? '#10b981' : '#ef4444';
                const opacity = 0.7 + (Math.abs(tf.value) / maxAbsValue) * 0.3;

                return `
                    <rect
                        x="${i * (barWidth + gap)}"
                        y="${y}"
                        width="${barWidth}"
                        height="${barHeight}"
                        fill="${color}"
                        opacity="${opacity}"
                        rx="1"
                    />
                    <text
                        x="${i * (barWidth + gap) + barWidth / 2}"
                        y="${height - 1}"
                        text-anchor="middle"
                        fill="#6b7280"
                        font-size="${fontSize}"
                        font-family="'IBM Plex Mono', monospace"
                    >${tf.label}</text>
                `;
            }).join('');

            return `
                <svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" style="display: block; flex-shrink: 0;">
                    <line x1="0" y1="${height / 2}" x2="${width}" y2="${height / 2}" stroke="rgba(255,255,255,0.1)" stroke-width="1"/>
                    ${bars}
                </svg>
            `;
        }

        /**
         * Generate consistency indicator (visual progress bar)
         * @param {number} aligned - Number of aligned timeframes
         * @param {number} total - Total timeframes
         * @returns {string} HTML string
         */
        function generateConsistencyIndicator(aligned, total) {
            const ratio = aligned / total;
            const percentage = Math.round(ratio * 100);

            // Color based on consistency
            let color = '#ef4444'; // red (<50%)
            if (percentage >= 80) color = '#10b981'; // green (80-100%)
            else if (percentage >= 60) color = '#fbbf24'; // amber (60-80%)
            else if (percentage >= 50) color = '#f59e0b'; // orange (50-60%)

            // For 5+ timeframes, use compact progress bar instead of circles
            if (total >= 5) {
                const barWidth = 60;
                const filledWidth = (aligned / total) * barWidth;
                return `
                    <div style="display: flex; align-items: center; gap: 6px; flex-shrink: 0;">
                        <div style="
                            width: ${barWidth}px;
                            height: 6px;
                            background: rgba(255,255,255,0.1);
                            border-radius: 3px;
                            overflow: hidden;
                            flex-shrink: 0;
                        ">
                            <div style="
                                width: ${filledWidth}px;
                                height: 100%;
                                background: ${color};
                                border-radius: 3px;
                                box-shadow: 0 0 4px ${color}40;
                            "></div>
                        </div>
                        <span style="font-size: 10px; color: ${color}; font-weight: 600; font-family: 'IBM Plex Mono', monospace; line-height: 1; white-space: nowrap;">${aligned}/${total}</span>
                    </div>
                `;
            }

            // For 3-4 timeframes, use circles (original behavior)
            const circleSize = total <= 3 ? 8 : 6;
            const circleGap = total <= 3 ? 4 : 3;
            const circles = Array.from({ length: total }, (_, i) => {
                const filled = i < aligned;
                return `<div style="
                    width: ${circleSize}px;
                    height: ${circleSize}px;
                    border-radius: 50%;
                    background: ${filled ? color : 'rgba(255,255,255,0.1)'};
                    border: 1px solid ${filled ? color : 'rgba(255,255,255,0.2)'};
                    ${filled ? 'box-shadow: 0 0 4px ' + color + '40;' : ''}
                    flex-shrink: 0;
                "></div>`;
            }).join('');

            return `
                <div style="display: flex; align-items: center; gap: ${circleGap}px; flex-shrink: 0;">
                    ${circles}
                    <span style="font-size: 10px; color: ${color}; font-weight: 600; font-family: 'IBM Plex Mono', monospace; line-height: 1; white-space: nowrap;">${aligned}/${total}</span>
                </div>
            `;
        }

        /**
         * Main MTF Rankings Renderer with Enhanced Visualizations
         */
        function renderMTFRankings(rankings) {
            const rankingsList = document.getElementById('mtfRankingsList');
            if (!rankingsList) return;

            if (!rankings || rankings.length === 0) {
                rankingsList.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-secondary);">No MTF rankings available</div>';
                return;
            }

            rankingsList.innerHTML = rankings.map(coin => {
                // Signal colors
                const signalColors = {
                    'STRONG_BUY': { bg: 'rgba(16, 185, 129, 0.15)', color: '#10b981', border: 'rgba(16, 185, 129, 0.3)', pulse: true },
                    'BUY': { bg: 'rgba(59, 130, 246, 0.15)', color: '#3b82f6', border: 'rgba(59, 130, 246, 0.3)', pulse: false },
                    'WEAK_BUY': { bg: 'rgba(139, 92, 246, 0.15)', color: '#8b5cf6', border: 'rgba(139, 92, 246, 0.3)', pulse: false },
                    'NEUTRAL': { bg: 'rgba(107, 114, 128, 0.15)', color: '#6b7280', border: 'rgba(107, 114, 128, 0.3)', pulse: false },
                    'WEAK_SELL': { bg: 'rgba(239, 68, 68, 0.15)', color: '#ef4444', border: 'rgba(239, 68, 68, 0.3)', pulse: false },
                    'SELL': { bg: 'rgba(239, 68, 68, 0.2)', color: '#ef4444', border: 'rgba(239, 68, 68, 0.4)', pulse: false },
                    'STRONG_SELL': { bg: 'rgba(239, 68, 68, 0.25)', color: '#ef4444', border: 'rgba(239, 68, 68, 0.5)', pulse: true }
                };

                const signalStyle = signalColors[coin.signal] || signalColors['NEUTRAL'];
                const perfColor = coin.total_outperformance >= 0 ? '#10b981' : '#ef4444';

                // Generate visualizations
                const scoreRing = generateScoreRing(coin.mtf_score, 64);
                const sparkline = generatePerformanceSparkline(coin.timeframe_details);
                const consistencyIndicator = generateConsistencyIndicator(coin.aligned_timeframes, coin.total_timeframes);

                return `
                    <div class="signal-card" style="
                        cursor: pointer;
                        position: relative;
                        border-left: 3px solid ${signalStyle.color};
                        padding: 14px;
                        margin-bottom: 8px;
                        background: var(--bg-secondary);
                        border-radius: 8px;
                        width: 100%;
                        box-sizing: border-box;
                        display: block;
                        ${signalStyle.pulse ? 'animation: subtle-pulse 2s ease-in-out infinite;' : ''}
                    " onclick="viewMTFDetails('${coin.symbol}')">

                        <!-- Header Row: Rank/Symbol + Signal Badge -->
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                            <div style="display: flex; align-items: baseline; gap: 8px;">
                                <span style="
                                    font-family: 'IBM Plex Mono', monospace;
                                    font-size: 12px;
                                    color: var(--text-secondary);
                                    font-weight: 600;
                                    min-width: 24px;
                                    line-height: 1.5;
                                ">#${String(coin.rank).padStart(2, '0')}</span>
                                <span style="
                                    font-size: 16px;
                                    font-weight: 700;
                                    color: var(--text-primary);
                                    letter-spacing: 0.5px;
                                    line-height: 1.5;
                                ">${coin.symbol}</span>
                            </div>
                            <div class="card-badge" style="
                                background: ${signalStyle.bg};
                                color: ${signalStyle.color};
                                border: 1px solid ${signalStyle.border};
                                font-size: 9px;
                                padding: 6px 8px;
                                letter-spacing: 0.5px;
                                white-space: nowrap;
                                line-height: 1;
                            ">
                                ${coin.signal.replace(/_/g, ' ')}
                            </div>
                        </div>

                        <!-- Main Content Row: Score Ring + Metrics -->
                        <div style="display: flex; gap: 16px; align-items: center; width: 100%;">

                            <!-- Score Ring -->
                            <div style="
                                flex: 0 0 64px;
                                width: 64px;
                                height: 64px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                            ">
                                ${scoreRing}
                            </div>

                            <!-- Metrics Column -->
                            <div style="flex: 1 1 auto; display: flex; flex-direction: column; gap: 6px; min-width: 0; overflow: visible;">

                                <!-- Performance -->
                                <div style="display: flex; justify-content: space-between; align-items: center; gap: 12px;">
                                    <span style="font-size: 11px; color: var(--text-secondary); line-height: 1.2;">Performance</span>
                                    <span style="
                                        font-size: 14px;
                                        font-weight: 700;
                                        color: ${perfColor};
                                        font-family: 'IBM Plex Mono', monospace;
                                        line-height: 1.2;
                                        white-space: nowrap;
                                    ">${coin.total_outperformance >= 0 ? '+' : ''}${coin.total_outperformance.toFixed(2)}%</span>
                                </div>

                                <!-- Timeframe Sparkline -->
                                <div style="display: flex; align-items: center; justify-content: flex-end; margin: 2px 0; width: 100%;">
                                    ${sparkline}
                                </div>

                                <!-- Consistency Indicator -->
                                <div style="display: flex; justify-content: space-between; align-items: center; gap: 12px;">
                                    <span style="font-size: 11px; color: var(--text-secondary); line-height: 1.2;">Alignment</span>
                                    ${consistencyIndicator}
                                </div>

                            </div>
                        </div>

                    </div>
                `;
            }).join('');
        }

        // Add subtle pulse animation for STRONG signals
        const style = document.createElement('style');
        style.textContent = `
            @keyframes subtle-pulse {
                0%, 100% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0); }
                50% { box-shadow: 0 0 8px 2px rgba(16, 185, 129, 0.2); }
            }
        `;
        document.head.appendChild(style);

        function viewMTFDetails(symbol) {
            console.log('[MTF] View details for:', symbol);
            // Could navigate to detailed view or show modal
        }

        // =====================================================
        // END CRYPTO PERFORMANCE TRACKER FUNCTIONS
        // =====================================================

        function updateTradeSignals(data) {
            console.log('[DEBUG] updateTradeSignals() called');
            const signalsList = document.getElementById('signalsList');
            const signalCount = document.getElementById('signalCount');
            const longCount = document.getElementById('longCount');
            const shortCount = document.getElementById('shortCount');
            const winRate = document.getElementById('winRate');
            const winLoss = document.getElementById('winLoss');

            const signals = data.signals || [];
            const summary = data.summary || {};
            const performance = data.performance_24h || {};

            console.log('[DEBUG] trade signals count:', signals.length);

            // Update summary stats
            signalCount.textContent = signals.length;
            longCount.textContent = summary.long_signals || 0;
            shortCount.textContent = summary.short_signals || 0;
            winRate.textContent = performance.win_rate !== undefined ? `${performance.win_rate}%` : '--';
            winLoss.textContent = `${performance.wins || 0}/${performance.losses || 0}`;

            // Render signal cards
            signalsList.innerHTML = '';

            if (signals.length > 0) {
                signals.forEach(signal => {
                    signalsList.innerHTML += createTradeSignalCard(signal);
                });
                // Re-initialize Lucide icons for new cards
                if (typeof lucide !== 'undefined') {
                    lucide.createIcons();
                }
            } else {
                signalsList.innerHTML = createEmptyState('No active trade signals');
            }
        }

        // Legacy updateSignals for backward compatibility
        function updateSignals(data) {
            const signals = Array.isArray(data) ? data : (data.signals || []);
            updateTradeSignals({ signals: signals, summary: {}, performance_24h: {} });
        }


        function updateAlpha(data) {
            console.log('[DEBUG] updateAlpha() called');
            console.log('[DEBUG] Alpha data.opportunities:', data.opportunities?.length || 0);
            const alphaList = document.getElementById('alphaList');
            if (!alphaList) {
                console.warn('[DEBUG] alphaList element not found, skipping update');
                return;
            }
            alphaList.innerHTML = '';

            if (data.opportunities && data.opportunities.length > 0) {
                data.opportunities.forEach(alpha => {
                    alphaList.innerHTML += createAlphaCard(alpha);
                });
            } else {
                alphaList.innerHTML = createEmptyState('No alpha opportunities');
            }
        }

        // 
        // MOMENTUM WAVES NATIVE WIDGET
        // 

        function createMomentumSparkline(scoreHistory, width = 55, height = 20) {
            if (!scoreHistory || scoreHistory.length < 2) {
                return '';
            }

            const data = scoreHistory.slice(-12);
            const min = Math.min(...data);
            const max = Math.max(...data);
            const range = max - min || 1;
            const padding = 2;

            const points = data.map((val, i) => {
                const x = padding + (i / (data.length - 1)) * (width - padding * 2);
                const y = padding + (height - padding * 2) - ((val - min) / range) * (height - padding * 2);
                return `${x.toFixed(1)},${y.toFixed(1)}`;
            });

            return `<svg class="momentum-sparkline-mobile" viewBox="0 0 ${width} ${height}" preserveAspectRatio="none">
                <path class="sparkline-path-mobile" d="M${points.join(' L')}"/>
            </svg>`;
        }

        function formatMomentumPrice(price) {
            if (price === null || price === undefined) return '-';
            if (price >= 10000) return price.toLocaleString('en-US', { maximumFractionDigits: 0 });
            if (price >= 100) return price.toFixed(1);
            if (price >= 1) return price.toFixed(2);
            if (price >= 0.01) return price.toFixed(4);
            return price.toFixed(6);
        }

        function formatMomentumChange(change) {
            if (change === null || change === undefined) return '-';
            const prefix = change >= 0 ? '+' : '';
            return prefix + change.toFixed(1) + '%';
        }

        function updateMomentumWaves(confluenceScores) {
            const container = document.getElementById('momentumWavesContainer');
            const countBadge = document.getElementById('momentumWavesCount');

            if (!container) return;

            const validScores = (confluenceScores || []).filter(s => s && s.symbol && !s.symbol.includes('SYSTEM'));

            // Sort by signal strength: bullish/bearish first, then warming, then neutral
            validScores.sort((a, b) => {
                const scoreA = a.score || a.confluence_score || 50;
                const scoreB = b.score || b.confluence_score || 50;
                // Priority: bullish(65) or bearish(35) = 2, warming(60-64 or 36-40) = 1, neutral = 0
                const priorityA = (scoreA >= 65 || scoreA <= 35) ? 2 : (scoreA >= 60 || scoreA <= 40) ? 1 : 0;
                const priorityB = (scoreB >= 65 || scoreB <= 35) ? 2 : (scoreB >= 60 || scoreB <= 40) ? 1 : 0;
                // First sort by priority (higher first)
                if (priorityA !== priorityB) return priorityB - priorityA;
                // Within same priority, sort by distance from 50 (stronger signals first)
                return Math.abs(scoreB - 50) - Math.abs(scoreA - 50);
            });

            // Update count badge
            if (countBadge) {
                countBadge.textContent = validScores.length;
            }

            if (validScores.length === 0) {
                container.innerHTML = `
                    <div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: var(--text-muted);">
                        <i data-lucide="waves" style="width: 32px; height: 32px; margin-bottom: 8px; opacity: 0.5;"></i>
                        <div style="font-size: 12px;">No momentum data available</div>
                    </div>
                `;
                if (typeof lucide !== 'undefined') lucide.createIcons();
                return;
            }

            // 8-level pulse duration system
            const pulseLevels = [
                { threshold: 45, duration: 0.5 },
                { threshold: 40, duration: 0.7 },
                { threshold: 35, duration: 0.9 },
                { threshold: 28, duration: 1.2 },
                { threshold: 20, duration: 1.6 },
                { threshold: 12, duration: 2.2 },
                { threshold: 5, duration: 3.0 },
                { threshold: 0, duration: 4.5 }
            ];

            const cardsHtml = validScores.slice(0, 20).map((score, index) => {
                const change = score.change_24h || score.price_change_24h || score.change || 0;
                const confluenceScore = score.score || score.confluence_score || 50;
                // Direction and signal class with amber warming zones
                const direction = confluenceScore >= 65 ? 'LONG' :
                                 confluenceScore >= 60 ? 'WARM' :
                                 confluenceScore <= 35 ? 'SHORT' :
                                 confluenceScore <= 40 ? 'COOL' : 'NEUTRAL';
                const signalClass = confluenceScore >= 65 ? 'bullish' :
                                   confluenceScore >= 60 ? 'warming' :
                                   confluenceScore <= 35 ? 'bearish' :
                                   confluenceScore <= 40 ? 'warming' : 'neutral';
                const symbol = score.symbol.replace('USDT', '');
                const fullSymbol = score.symbol;
                const cardId = `alpha_pulse_${symbol}_${index}`;

                // Determine column position for mirrored expansion
                const isRightColumn = index % 2 === 1;
                const columnPosition = isRightColumn ? 'right' : 'left';

                const sparkline = createMomentumSparkline(score.score_history);
                const circumference = 2 * Math.PI * 14; // radius 14 for 36px circle
                const offset = circumference - (confluenceScore / 100) * circumference;

                // Calculate score change from history (like Alpha Report trend)
                const scoreHistory = score.score_history || [];
                let scoreChange = 0;
                let hasScoreHistory = false;
                if (scoreHistory.length >= 2) {
                    scoreChange = scoreHistory[scoreHistory.length - 1] - scoreHistory[0];
                    hasScoreHistory = true;
                }
                const scoreChangeDisplay = hasScoreHistory
                    ? (scoreChange >= 0 ? '+' : '') + scoreChange.toFixed(1)
                    : '';
                const scoreChangeColor = scoreChange > 2 ? '#34d399' : scoreChange < -2 ? '#f87171' : 'var(--text-secondary)';
                const scoreTrendArrow = scoreChange > 2 ? '' : scoreChange < -2 ? '' : '';

                const trendArrow = change >= 0
                    ? '<span class="momentum-trend-arrow-mobile" style="color: #34d399;">&#9650;</span>'
                    : '<span class="momentum-trend-arrow-mobile" style="color: #f87171;">&#9660;</span>';

                // Calculate pulse intensity
                const intensity = Math.abs(confluenceScore - 50);
                const pulseDuration = pulseLevels.find(l => intensity >= l.threshold).duration;

                // Extract component scores
                // Note: API returns 'price_structure' but UI displays as 'position'
                const components = score.components || score.results || {};
                const componentScores = {
                    technical: components.technical || 50,
                    volume: components.volume || 50,
                    orderflow: components.orderflow || 50,
                    orderbook: components.orderbook || 50,
                    position: components.price_structure || components.position || 50,
                    sentiment: components.sentiment || 50
                };

                // Generate component bars HTML
                const componentBarsHtml = Object.entries(componentScores).map(([comp, compScore]) => {
                    const height = Math.max(8, (compScore / 100) * 24);
                    const barColor = compScore >= 65 ? 'var(--accent-positive)' : compScore <= 35 ? 'var(--accent-negative)' : 'var(--accent-warning)';
                    return `<div style="flex: 1; background: rgba(255, 255, 255, 0.08); border-radius: 2px; height: 24px; position: relative; overflow: hidden;">
                        <div style="position: absolute; bottom: 0; width: 100%; height: ${height}px; background: ${barColor}; opacity: 0.85;"></div>
                    </div>`;
                }).join('');

                // Extract timeframe metadata if available
                const tfMetadata = score.timeframe_metadata || {};
                const tfWeightsLabel = tfMetadata.weights_label || '1m: 40% | 5m: 30% | 30m: 20% | 4h: 10%';

                // Generate timeframe weights badge HTML
                const tfBadgeHtml = `
                    <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 8px; padding: 6px 8px; background: rgba(139, 92, 246, 0.1); border: 1px solid rgba(139, 92, 246, 0.2); border-radius: 6px;">
                        <i data-lucide="clock" style="width: 12px; height: 12px; color: var(--accent-primary); opacity: 0.8;"></i>
                        <span style="font-size: 9px; color: var(--text-secondary); font-weight: 500;">TF Weights: ${tfWeightsLabel}</span>
                    </div>`;

                // Generate expanded breakdown HTML with CSS Grid alignment
                const breakdownHtml = tfBadgeHtml + `<div style="display: grid; grid-template-columns: 80px 1fr 28px; gap: 6px 12px; align-items: center;">` +
                    Object.entries(componentScores).map(([comp, compScore]) => {
                        const compColor = compScore >= 65 ? 'var(--accent-positive)' : compScore <= 35 ? 'var(--accent-negative)' : 'var(--accent-warning)';
                        const compName = comp.charAt(0).toUpperCase() + comp.slice(1);
                        return `
                        <span style="font-size: 10px; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${compName}</span>
                        <div style="height: 4px; background: rgba(255, 255, 255, 0.1); border-radius: 2px; overflow: hidden;">
                            <div style="width: ${compScore}%; height: 100%; background: ${compColor}; transition: width 0.3s ease;"></div>
                        </div>
                        <span style="font-size: 11px; font-weight: 600; color: ${compColor}; text-align: right;">${Math.round(compScore)}</span>`;
                    }).join('') + `</div>`;

                // Buttons always on right - only track column position for expansion direction
                const buttonBorder = 'border-left: 1px solid var(--border-light);';

                return `
                    <div class="momentum-card-mobile ${signalClass}" data-column="${columnPosition}" style="--pulse-duration: ${pulseDuration}s; cursor: pointer; overflow: visible; transition: all 0.3s ease;" id="${cardId}">
                        <div class="card-pulse-ring-mobile"></div>
                        <div style="display: flex; flex-direction: row;">
                            <!-- Main card content with touch feedback -->
                            <div class="momentum-card-inner-mobile"
                                 onclick="toggleAlphaPulseCard('${cardId}')"
                                 ontouchstart="this.style.transform='scale(0.98)'; this.style.opacity='0.85';"
                                 ontouchend="this.style.transform=''; this.style.opacity='';"
                                 style="flex: 1; min-width: 0; transition: transform 0.15s ease, opacity 0.15s ease;">
                                <div class="momentum-card-header">
                                    <span class="momentum-symbol-mobile">${symbol}</span>
                                    <span class="momentum-signal-badge-mobile ${direction}">${direction}</span>
                                </div>
                                <div class="momentum-card-body">
                                    <div class="momentum-metrics-mobile">
                                        <div class="momentum-metric-mobile">
                                            <span class="momentum-metric-label-mobile">PRICE</span>
                                            <span class="momentum-metric-value-mobile">${formatMomentumPrice(score.price || 0)}</span>
                                        </div>
                                        <div class="momentum-metric-mobile">
                                            <span class="momentum-metric-label-mobile">24H</span>
                                            <span class="momentum-metric-value-mobile ${change >= 0 ? 'positive' : 'negative'}">
                                                ${formatMomentumChange(change)}${trendArrow}
                                            </span>
                                        </div>
                                        <div class="momentum-metric-mobile" title="Score trend since tracking started">
                                            <span class="momentum-metric-label-mobile">TREND</span>
                                            <span class="momentum-metric-value-mobile" style="color: ${scoreChangeColor};">
                                                ${scoreChangeDisplay}${scoreTrendArrow}
                                            </span>
                                        </div>
                                    </div>
                                    <div class="momentum-score-container-mobile">
                                        ${sparkline}
                                        <div class="momentum-score-circle-mobile">
                                            <div class="momentum-pulse-ring-mobile"></div>
                                            <svg class="momentum-score-ring-mobile" width="36" height="36" viewBox="0 0 36 36">
                                                <circle class="momentum-score-ring-bg-mobile" cx="18" cy="18" r="14"/>
                                                <circle class="momentum-score-ring-progress-mobile"
                                                    cx="18" cy="18" r="14"
                                                    stroke-dasharray="${circumference}"
                                                    stroke-dashoffset="${offset}"/>
                                            </svg>
                                            <div class="momentum-score-inner-mobile">
                                                <span class="momentum-score-value-mobile">${Math.round(confluenceScore)}</span>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <!-- Mini component bars -->
                                <div style="display: flex; gap: 2px; margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.05);">
                                    ${componentBarsHtml}
                                </div>
                                <!-- Tap indicator - down chevron (flips up on expand) -->
                                <div style="display: flex; justify-content: center; margin-top: 6px;">
                                    <i data-lucide="chevron-down" style="width: 16px; height: 16px; color: var(--text-secondary); opacity: 0.6; transition: transform 0.3s ease;" id="${cardId}_chevron"></i>
                                </div>
                            </div>
                            <!-- Horizontal slide: Action buttons (position depends on column) -->
                            <div id="${cardId}_buttons" style="display: none; width: 0; overflow: hidden; ${buttonBorder} background: rgba(0,0,0,0.2); opacity: 0; transition: all 0.3s ease;">
                                <div style="padding: 8px; min-width: 70px; display: flex; flex-direction: column; gap: 6px; height: 100%; justify-content: center;">
                                    <button onclick="event.stopPropagation(); viewDetailedAnalysis('${fullSymbol}')" style="min-height: 44px; padding: 8px; background: var(--accent-primary); border: none; border-radius: 6px; color: var(--bg-primary); font-size: 11px; font-weight: 700; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 4px; touch-action: manipulation;">
                                        <i data-lucide="chart-line" style="width: 14px; height: 14px;"></i>
                                    </button>
                                    <button onclick="event.stopPropagation(); viewAlerts('${fullSymbol}')" style="min-height: 44px; padding: 8px; background: rgba(255, 191, 0, 0.15); border: 1px solid rgba(251, 191, 36, 0.3); border-radius: 6px; color: var(--text-primary); font-size: 11px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 4px; touch-action: manipulation;">
                                        <i data-lucide="bell" style="width: 14px; height: 14px;"></i>
                                    </button>
                                </div>
                            </div>
                        </div>
                        <!-- Vertical expansion: Breakdown grid (full width below card) -->
                        <div id="${cardId}_expanded" style="display: none; max-height: 0; overflow: hidden; opacity: 0; transition: all 0.3s ease; border-top: 1px solid var(--border-light); background: rgba(0,0,0,0.15);">
                            <div style="padding: 12px;">
                                <h4 style="font-size: 10px; font-weight: 600; color: var(--text-primary); margin-bottom: 10px; text-transform: uppercase; letter-spacing: 0.5px;">Score Breakdown</h4>
                                ${breakdownHtml}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = cardsHtml;

            // Re-init Lucide icons
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }

        // Store alerts data for filtering
        let currentAlertsData = [];
        let currentAlertFilter = 'all';

        function updateAlerts(data) {
            // Handle both array response and {alerts: [...]} object response
            const alerts = Array.isArray(data) ? data : (data.alerts || []);
            console.log('[DEBUG] updateAlerts() called, alerts:', alerts.length);

            // Store for filtering
            currentAlertsData = alerts;

            // Update count badge
            document.getElementById('alertCount').textContent = alerts.length;

            // Render with current filter
            renderAlerts(alerts, currentAlertFilter);

            // Also render signal alerts in the Signals tab
            renderAlertedSignals(alerts);
        }

        function renderAlerts(alerts, filter) {
            const startTime = performance.now();

            try {
                const alertsList = document.getElementById('alertsList');
                if (!alertsList) {
                    console.error('[ERROR] alertsList element not found');
                    return;
                }

                // Apply filter
                let filteredAlerts = alerts;
                if (filter !== 'all') {
                    // Signal filter should match 'signal', 'high_confluence', and 'confluence' types
                    if (filter === 'signal') {
                        filteredAlerts = alerts.filter(a => {
                            const alertType = a.alert_type || a.details?.type || '';
                            return alertType === 'signal' ||
                                   alertType === 'high_confluence' ||
                                   alertType === 'confluence';  // Include confluence alerts - these are LONG/SHORT trading signals
                        });
                    } else {
                        filteredAlerts = alerts.filter(a => {
                            const alertType = a.alert_type || a.details?.type || '';
                            return alertType === filter;
                        });
                    }
                }

                alertsList.innerHTML = '';

                if (filteredAlerts.length > 0) {
                    let successCount = 0;
                    let failureCount = 0;

                    filteredAlerts.forEach((alert, index) => {
                        try {
                            alertsList.innerHTML += createAlertCard(alert);
                            successCount++;
                        } catch (cardError) {
                            failureCount++;
                            console.error('[ERROR] Failed to create alert card', {
                                index,
                                symbol: alert.symbol,
                                alert_type: alert.alert_type || alert.details?.type || alert.type,
                                error: cardError.message
                            });
                            // Continue rendering other alerts - don't let one bad alert break everything
                        }
                    });

                    // Log performance and success rate
                    const duration = performance.now() - startTime;
                    console.log('[PERF] renderAlerts:', {
                        total_alerts: alerts.length,
                        filtered: filteredAlerts.length,
                        rendered: successCount,
                        failed: failureCount,
                        filter: filter,
                        duration_ms: duration.toFixed(2)
                    });
                } else {
                // Special empty state for signal filter - match the Alerted card style
                if (filter === 'signal') {
                    alertsList.innerHTML = `
                        <div style="text-align: center; padding: 24px 16px;">
                            <i data-lucide="radar" style="width: 28px; height: 28px; color: var(--accent-positive); margin-bottom: 8px; opacity: 0.7;"></i>
                            <div style="font-size: 12px; color: var(--text-primary); font-weight: 500;">Scanning for opportunities</div>
                            <div style="font-size: 10px; margin-top: 4px; color: var(--text-secondary);">High-conviction signals will appear here</div>
                        </div>
                    `;
                } else {
                    const filterNames = {
                        'whale_trade': 'whale',
                        'liquidation_cascade': 'liquidation',
                        'regime_change': 'regime'
                    };
                    const filterName = filterNames[filter] || '';
                    alertsList.innerHTML = createEmptyState(`No ${filterName} alerts`);
                }
            }

                // Initialize Lucide icons for filter pills
                setTimeout(() => { if (typeof lucide !== 'undefined') lucide.createIcons(); }, 50);

            } catch (error) {
                console.error('[ERROR] renderAlerts failed completely', {
                    alert_count: alerts?.length || 0,
                    filter,
                    error: error.message,
                    stack: error.stack
                });

                // Show user-friendly error UI
                const alertsList = document.getElementById('alertsList');
                if (alertsList) {
                    alertsList.innerHTML = `
                        <div style="text-align: center; padding: 24px 16px; background: var(--background-secondary); border-radius: 8px; margin: 8px 0;">
                            <i data-lucide="alert-triangle" style="width: 32px; height: 32px; color: var(--accent-negative); margin-bottom: 12px; opacity: 0.8;"></i>
                            <div style="font-size: 13px; color: var(--text-primary); font-weight: 500; margin-bottom: 4px;">Failed to load alerts</div>
                            <div style="font-size: 11px; color: var(--text-secondary);">Try refreshing the page</div>
                        </div>
                    `;
                    setTimeout(() => { if (typeof lucide !== 'undefined') lucide.createIcons(); }, 50);
                }
            }
        }

        function filterAlerts(filter) {
            currentAlertFilter = filter;

            // Update pill active states
            document.querySelectorAll('.alert-filter-pill').forEach(pill => {
                pill.classList.remove('active');
                if (pill.dataset.filter === filter) {
                    pill.classList.add('active');
                }
            });

            // Re-render with filter
            renderAlerts(currentAlertsData, filter);
        }

        // Render signal-type alerts in the Signals tab
        function renderAlertedSignals(alerts) {
            const alertedSignalsList = document.getElementById('alertedSignalsList');
            const alertedSignalCount = document.getElementById('alertedSignalCount');

            // Filter for signal-type alerts (including confluence alerts which are trading signals)
            // FIX: Use defensive pattern for alert type field
            const signalAlerts = alerts.filter(a => {
                const alertType = a.alert_type || a.details?.type || a.type || '';
                return alertType === 'signal' ||
                       alertType === 'high_confluence' ||
                       alertType === 'confluence';  // Include confluence alerts - these are LONG/SHORT trading signals
            });

            // Update count
            alertedSignalCount.textContent = signalAlerts.length;
            alertedSignalsList.innerHTML = '';

            if (signalAlerts.length === 0) {
                // Show positive empty state
                alertedSignalsList.innerHTML = `
                    <div style="text-align: center; padding: 16px;">
                        <i data-lucide="radar" style="width: 28px; height: 28px; color: var(--accent-positive); margin-bottom: 8px; opacity: 0.7;"></i>
                        <div style="font-size: 12px; color: var(--text-primary); font-weight: 500;">Scanning for opportunities</div>
                        <div style="font-size: 10px; margin-top: 4px; color: var(--text-secondary);">High-conviction signals will appear here</div>
                    </div>
                `;
            } else {
                // Render each signal alert using an expandable card format (like Alpha Pulse)
                signalAlerts.forEach((alert, index) => {
                    alertedSignalsList.innerHTML += createAlertedSignalCard(alert, index);
                });
            }

            // Initialize Lucide icons
            setTimeout(() => { if (typeof lucide !== 'undefined') lucide.createIcons(); }, 50);
        }

        // Track currently expanded alerted signal card (accordion behavior)
        let currentlyExpandedAlertedSignal = null;

        // Create an expandable card for alerted signals (similar to Alpha Pulse cards)
        function createAlertedSignalCard(alert, index) {
            const symbol = alert.symbol || 'UNKNOWN';
            const details = alert.details || {};
            const signalType = details.signal_type || details.type || '';
            const confluenceScore = details.confluence_score || details.score || 0;

            // Parse timestamp for relative time and report filename
            let alertDate;
            let alertTimestamp = '';
            if (alert.unix_timestamp) {
                alertDate = new Date(alert.unix_timestamp * 1000);
                alertTimestamp = alertDate.toISOString().replace(/[-:T]/g, '').slice(0, 15);
            } else if (alert.timestamp) {
                // Handle both numeric (Unix ms) and string timestamps
                if (typeof alert.timestamp === 'number') {
                    alertDate = new Date(alert.timestamp);
                } else {
                    alertDate = new Date(alert.timestamp.replace(' ', 'T') + 'Z');
                }
                alertTimestamp = alertDate.toISOString().replace(/[-:T]/g, '').slice(0, 15);
            } else {
                alertDate = new Date();
                alertTimestamp = alertDate.toISOString().replace(/[-:T]/g, '').slice(0, 15);
            }
            const relativeTime = formatRelativeTime(alertDate);

            // Direction
            const isLong = signalType.toUpperCase() === 'LONG' || signalType.toUpperCase() === 'BUY';
            const direction = isLong ? 'LONG' : 'SHORT';
            const dirColor = isLong ? 'var(--accent-positive)' : 'var(--accent-negative)';
            const dirBg = isLong ? 'rgba(16, 185, 129, 0.15)' : 'rgba(239, 68, 68, 0.15)';
            const dirIcon = isLong ? 'trending-up' : 'trending-down';
            const borderColor = isLong ? 'rgba(16, 185, 129, 0.3)' : 'rgba(239, 68, 68, 0.3)';

            // Score color
            const scoreColor = confluenceScore >= 70 ? 'var(--accent-positive)' : confluenceScore >= 55 ? 'var(--neon-amber)' : 'var(--text-secondary)';

            // Clean symbol
            const displaySymbol = symbol.replace(/USDT$/i, '');
            const fullSymbol = symbol.replace(/USDT$/i, 'USDT');

            // Generate unique card ID
            const cardId = `alerted_signal_${displaySymbol}_${index}`;

            // Extract price levels if available
            const entryPrice = parseFloat(details.entry_price || details.price || 0);
            const stopLoss = parseFloat(details.stop_loss || 0);
            const takeProfit = parseFloat(details.take_profit || 0);

            const formatPrice = (p) => {
                if (p >= 1000) return p.toFixed(2);
                if (p >= 1) return p.toFixed(4);
                return p.toFixed(6);
            };

            // Build price info if available
            let priceInfo = '';
            if (entryPrice > 0) {
                priceInfo = `
                    <div style="display: flex; gap: 12px; margin-top: 10px; padding-top: 10px; border-top: 1px solid var(--border-light);">
                        ${stopLoss > 0 ? `<div><span style="font-size: 9px; color: var(--accent-negative);">SL</span><div style="font-size: 12px; color: var(--text-primary);">$${formatPrice(stopLoss)}</div></div>` : ''}
                        <div><span style="font-size: 9px; color: var(--neon-amber);">ENTRY</span><div style="font-size: 12px; color: var(--neon-amber); font-weight: 600;">$${formatPrice(entryPrice)}</div></div>
                        ${takeProfit > 0 ? `<div><span style="font-size: 9px; color: var(--accent-positive);">TP</span><div style="font-size: 12px; color: var(--text-primary);">$${formatPrice(takeProfit)}</div></div>` : ''}
                    </div>
                `;
            }

            return `
                <div id="${cardId}" style="background: var(--bg-secondary); border: 1px solid ${borderColor}; border-radius: 10px; margin-bottom: 8px; overflow: hidden; transition: all 0.3s ease;">
                    <div style="display: flex; flex-direction: row;">
                        <!-- Main card content (clickable) -->
                        <div class="alerted-signal-inner"
                             onclick="toggleAlertedSignalCard('${cardId}')"
                             ontouchstart="this.style.transform='scale(0.98)'; this.style.opacity='0.85';"
                             ontouchend="this.style.transform=''; this.style.opacity='';"
                             style="flex: 1; min-width: 0; padding: 12px; cursor: pointer; transition: transform 0.15s ease, opacity 0.15s ease;">
                            <!-- Header -->
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <span style="font-weight: 700; font-size: 15px; color: var(--text-primary);">${displaySymbol}</span>
                                    <div style="background: ${dirBg}; padding: 3px 8px; border-radius: 5px; display: flex; align-items: center; gap: 3px;">
                                        <i data-lucide="${dirIcon}" style="width: 12px; height: 12px; color: ${dirColor};"></i>
                                        <span style="font-size: 11px; font-weight: 600; color: ${dirColor};">${direction}</span>
                                    </div>
                                </div>
                                <div style="display: flex; align-items: center; gap: 6px;">
                                    <div style="background: rgba(16, 185, 129, 0.15); padding: 3px 6px; border-radius: 4px;">
                                        <i data-lucide="bell" style="width: 10px; height: 10px; color: var(--accent-positive);"></i>
                                    </div>
                                    <div style="background: ${scoreColor}20; padding: 3px 8px; border-radius: 5px;">
                                        <span style="font-size: 12px; font-weight: 700; color: ${scoreColor};">${confluenceScore.toFixed(0)}</span>
                                    </div>
                                </div>
                            </div>
                            <!-- Time -->
                            <div style="font-size: 10px; color: var(--text-secondary); margin-top: 6px;">
                                Alerted ${relativeTime}
                            </div>
                            ${priceInfo}
                            <!-- Tap indicator (chevron that flips on expand) -->
                            <div style="display: flex; justify-content: center; margin-top: 8px;">
                                <i data-lucide="chevron-down" style="width: 14px; height: 14px; color: var(--text-secondary); opacity: 0.5; transition: transform 0.3s ease;" id="${cardId}_chevron"></i>
                            </div>
                        </div>
                        <!-- Horizontal slide: Action buttons panel -->
                        <div id="${cardId}_buttons" style="display: none; width: 0; overflow: hidden; border-left: 1px solid var(--border-light); background: rgba(0,0,0,0.2); opacity: 0; transition: all 0.3s ease;">
                            <div style="padding: 8px; min-width: 80px; display: flex; flex-direction: column; gap: 6px; height: 100%; justify-content: center;">
                                <!-- Alpha Analysis Button -->
                                <button onclick="event.stopPropagation(); viewDetailedAnalysis('${fullSymbol}')"
                                        style="min-height: 40px; padding: 8px; background: var(--accent-primary); border: none; border-radius: 6px; color: var(--bg-primary); font-size: 10px; font-weight: 700; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 2px; touch-action: manipulation;">
                                    <i data-lucide="bar-chart-3" style="width: 16px; height: 16px;"></i>
                                    <span>Analysis</span>
                                </button>
                                <!-- HTML Report Button -->
                                <button onclick="event.stopPropagation(); viewAlertReport('${fullSymbol}', '${alertTimestamp}')"
                                        style="min-height: 40px; padding: 8px; background: rgba(255, 191, 0, 0.15); border: 1px solid rgba(251, 191, 36, 0.3); border-radius: 6px; color: var(--neon-amber); font-size: 10px; font-weight: 600; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 2px; touch-action: manipulation;">
                                    <i data-lucide="file-text" style="width: 16px; height: 16px;"></i>
                                    <span>Report</span>
                                </button>
                                <!-- Trade Button -->
                                <button onclick="event.stopPropagation(); window.open('https://www.bybit.com/trade/usdt/${fullSymbol}', '_blank')"
                                        style="min-height: 40px; padding: 8px; background: rgba(16, 185, 129, 0.15); border: 1px solid rgba(16, 185, 129, 0.3); border-radius: 6px; color: var(--accent-positive); font-size: 10px; font-weight: 600; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 2px; touch-action: manipulation;">
                                    <i data-lucide="external-link" style="width: 16px; height: 16px;"></i>
                                    <span>Trade</span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        // Store symbols data for sorting
        let currentSymbolsData = [];
        
        function updateSymbols(data) {
            const symbolsList = document.getElementById('analyzedSymbolsList');
            const symbolsCount = document.getElementById('symbolsCount');

            const symbols = data.symbols || [];
            currentSymbolsData = symbols; // Store for sorting
            
            // Only update if element exists (Beta tab may not be loaded yet)
            if (symbolsCount) {
                symbolsCount.textContent = symbols.length;
            }
            
            renderSymbols(symbols);

            // Initialize Lucide icons for the new elements
            setTimeout(() => { if (typeof lucide !== 'undefined') lucide.createIcons(); }, 100);
        }

        let symbolsListWarningShown = false;  // Only warn once to reduce console noise

        function renderSymbols(symbols) {
            const symbolsList = document.getElementById('analyzedSymbolsList');

            // Beta tab may not be loaded yet (lazy loading)
            if (!symbolsList) {
                if (!symbolsListWarningShown) {
                    console.debug('[DEBUG] analyzedSymbolsList not loaded yet, will render when tab activates');
                    symbolsListWarningShown = true;
                }
                return;
            }
            
            symbolsList.innerHTML = '';
            
            if (symbols.length > 0) {
                symbols.forEach(symbol => {
                    symbolsList.innerHTML += createAnalyzedSymbolItem(symbol);
                });
            } else {
                symbolsList.innerHTML = '<div class="empty-state" style="text-align: center; color: var(--text-secondary); padding: 20px; grid-column: 1 / -1;">No symbols data available</div>';
            }
        }
        
        function sortSymbols() {
            const sortSelector = document.getElementById('sortSelector');
            if (!sortSelector) {
                console.warn('[WARN] sortSelector element not found, using default sort');
                return;
            }
            
            const sortBy = sortSelector.value;
            let sortedSymbols = [...currentSymbolsData];
            
            switch(sortBy) {
                case 'score':
                    sortedSymbols.sort((a, b) => (b.confluence_score || b.score || 0) - (a.confluence_score || a.score || 0));
                    break;
                case 'change':
                    sortedSymbols.sort((a, b) => {
                        const changeA = parseFloat(a.price_change_percent || a.change_24h || 0);
                        const changeB = parseFloat(b.price_change_percent || b.change_24h || 0);
                        return changeB - changeA;
                    });
                    break;
                case 'volume':
                    sortedSymbols.sort((a, b) => {
                        const priceA = a.price || a.current_price || 0;
                        const priceB = b.price || b.current_price || 0;
                        const volumeA = a.volume_usd || a.quote_volume || ((a.volume || a.volume_24h || 0) * priceA) || 0;
                        const volumeB = b.volume_usd || b.quote_volume || ((b.volume || b.volume_24h || 0) * priceB) || 0;
                        return volumeB - volumeA;
                    });
                    break;
                case 'symbol':
                    sortedSymbols.sort((a, b) => (a.symbol || a).localeCompare(b.symbol || b));
                    break;
            }
            
            renderSymbols(sortedSymbols);
            setTimeout(() => { if (typeof lucide !== 'undefined') lucide.createIcons(); }, 100);
        }

        function updateMarketOverview(data) {
            console.log('[DEBUG] updateMarketOverview called with:', data);
            console.log('[DEBUG] data keys:', Object.keys(data || {}));

            // === FEAR & GREED INDEX (Compact Display) ===
            const fearGreedValue = parseInt(data.fear_greed_value || 50);
            const fearGreedLabel = data.fear_greed_label || 'Neutral';
            document.getElementById('fearGreedValue').textContent = fearGreedValue;
            document.getElementById('fearGreedLabel').textContent = fearGreedLabel;

            // Color based on value
            const fearGreedValueEl = document.getElementById('fearGreedValue');
            if (fearGreedValue <= 25) {
                fearGreedValueEl.style.color = '#f44336'; // Extreme Fear - Red
            } else if (fearGreedValue <= 45) {
                fearGreedValueEl.style.color = '#ff9800'; // Fear - Orange
            } else if (fearGreedValue <= 55) {
                fearGreedValueEl.style.color = 'var(--accent-warning)'; // Neutral - Yellow
            } else if (fearGreedValue <= 75) {
                fearGreedValueEl.style.color = '#8bc34a'; // Greed - Light Green
            } else {
                fearGreedValueEl.style.color = '#4caf50'; // Extreme Greed - Green
            }

            // === MARKET REGIME ===
            // Format: "Category: Label" (e.g., "Bearish: Risk-Off", "Strong Bullish: Euphoric Rally")
            const regimeData = data.market_regime || data.regime || 'Neutral: Unknown';
            const regime = safeExtractValue(regimeData, 'Neutral: Unknown', false);
            const regimeContainer = document.getElementById('marketRegime');
            const regimeCategoryEl = document.getElementById('regimeCategory');
            const regimeLabelEl = document.getElementById('regimeLabel');
            if (regimeContainer && regimeCategoryEl) {
                // Split into category and label
                const parts = regime.split(':');
                const category = parts[0].trim();
                const label = parts.length > 1 ? parts[1].trim() : '';

                // Set the two-line content
                regimeCategoryEl.textContent = category;
                if (regimeLabelEl) {
                    regimeLabelEl.textContent = label;
                }

                // Apply background color based on category
                const categoryUpper = category.toUpperCase();
                if (categoryUpper.includes('BULLISH')) {
                    regimeContainer.style.background = 'rgba(76, 175, 80, 0.2)';
                    regimeCategoryEl.style.color = 'var(--accent-positive)';
                } else if (categoryUpper.includes('BEARISH')) {
                    regimeContainer.style.background = 'rgba(244, 67, 54, 0.2)';
                    regimeCategoryEl.style.color = 'var(--accent-negative)';
                } else {
                    // Neutral regimes
                    regimeContainer.style.background = 'rgba(255, 191, 0, 0.15)';
                    regimeCategoryEl.style.color = 'var(--text-primary)';
                }
            }

            // === TOTAL MARKET CAP & 24H VOLUME ===
            const totalMarketCap = parseFloat(data.total_market_cap || 0);
            const marketCapChange = parseFloat(data.market_cap_change_24h || 0);

            document.getElementById('totalMarketCap').textContent = formatMarketCap(totalMarketCap);

            const mcapChangeEl = document.getElementById('marketCapChange');
            mcapChangeEl.textContent = (marketCapChange >= 0 ? '+' : '') + marketCapChange.toFixed(2) + '%';
            if (marketCapChange >= 0) {
                mcapChangeEl.style.background = 'rgba(76, 175, 80, 0.2)';
                mcapChangeEl.style.color = 'var(--accent-positive)';
            } else {
                mcapChangeEl.style.background = 'rgba(244, 67, 54, 0.2)';
                mcapChangeEl.style.color = 'var(--accent-negative)';
            }

            // Update 24H Volume (now in market cap row)
            const totalVolume = parseFloat(data.total_volume || data.coingecko_volume_24h || 0);
            document.getElementById('totalVolume').textContent = formatMarketCap(totalVolume);

            // === DOMINANCE BREAKDOWN ===
            const btcDom = parseFloat(data.btc_dominance || 57);
            const ethDom = parseFloat(data.eth_dominance || 12);
            const stableDom = parseFloat(data.stablecoin_dominance || 8);
            // Calculate altcoin dominance (everything else)
            const altDom = Math.max(0, 100 - btcDom - ethDom - stableDom);

            // Update text labels
            document.getElementById('btcDominance').textContent = btcDom.toFixed(1) + '%';
            document.getElementById('ethDominance').textContent = ethDom.toFixed(1) + '%';
            document.getElementById('stableDominance').textContent = stableDom.toFixed(1) + '%';
            document.getElementById('altDominance').textContent = altDom.toFixed(1) + '%';

            // Update bar widths (scale to fit, minimum widths handled by CSS)
            const scale = 100 / (btcDom + ethDom + stableDom + altDom);
            document.getElementById('btcDomBar').style.width = `${btcDom * scale}%`;
            document.getElementById('ethDomBar').style.width = `${ethDom * scale}%`;
            document.getElementById('stableDomBar').style.width = `${stableDom * scale}%`;
            document.getElementById('altDomBar').style.width = `${altDom * scale}%`;

            // === TREND STRENGTH ===
            const trendStrength = parseFloat(data.trend_strength || 50);
            document.getElementById('trendStrength').textContent = Math.round(trendStrength);
            document.getElementById('trendStrengthBar').style.width = `${trendStrength}%`;

            const trendBar = document.getElementById('trendStrengthBar');
            if (trendStrength >= 70) {
                trendBar.style.background = 'var(--accent-positive)';
            } else if (trendStrength >= 30) {
                trendBar.style.background = 'var(--accent-warning)';
            } else {
                trendBar.style.background = 'var(--accent-negative)';
            }

            // === VOLATILITY ===
            const currentVol = parseFloat(data.current_volatility || data.volatility || data.market_dispersion || 0);
            const avgVol = parseFloat(data.avg_volatility || data.avg_market_dispersion || 8);
            document.getElementById('currentVolatility').textContent = currentVol.toFixed(1) + '%';
            document.getElementById('avgVolatility').textContent = avgVol.toFixed(1) + '%';

            const descriptorElement = document.getElementById('volatilityDescriptor');
            let descriptor = '';
            let descriptorColor = '';

            if (currentVol < 3) {
                descriptor = 'Very Low';
                descriptorColor = 'var(--accent-positive)';
            } else if (currentVol < 5) {
                descriptor = 'Low';
                descriptorColor = 'var(--accent-positive)';
            } else if (currentVol < 10) {
                descriptor = 'Normal';
                descriptorColor = 'var(--text-primary)';
            } else if (currentVol < 15) {
                descriptor = 'Elevated';
                descriptorColor = '#FFA500';
            } else if (currentVol < 20) {
                descriptor = 'High';
                descriptorColor = 'var(--accent-negative)';
            } else if (currentVol < 30) {
                descriptor = 'Very High';
                descriptorColor = 'var(--accent-negative)';
            } else {
                descriptor = 'Extreme';
                descriptorColor = '#FF0000';
            }

            descriptorElement.textContent = descriptor;
            descriptorElement.style.color = descriptorColor;

            const volElement = document.getElementById('currentVolatility');
            if (currentVol > avgVol * 1.2) {
                volElement.style.color = 'var(--accent-negative)';
            } else if (currentVol > avgVol) {
                volElement.style.color = 'var(--accent-warning)';
            } else {
                volElement.style.color = 'var(--accent-positive)';
            }

            // === MARKET SENTIMENT BREADTH ===
            if (data.market_breadth) {
                const breadth = data.market_breadth;
                updateMarketBreadth(breadth.up || breadth.up_count || 0, breadth.down || breadth.down_count || 0);
            } else if (data.market_overview) {
                updateMarketBreadth(data.market_overview.gainers || 0, data.market_overview.losers || 0);
            } else if (data.gainers !== undefined || data.losers !== undefined) {
                updateMarketBreadth(data.gainers || 0, data.losers || 0);
            } else {
                updateMarketBreadth(0, 0);
            }

            // === ALTCOIN SEASON INDICATOR ===
            const altcoinSeason = data.altcoin_season || 'Dormant';
            const altSeasonEl = document.getElementById('altcoinSeason');
            altSeasonEl.textContent = altcoinSeason;

            if (altcoinSeason === 'Active') {
                altSeasonEl.style.background = 'rgba(139, 92, 246, 0.3)';
                altSeasonEl.style.color = '#c4b5fd';
            } else if (altcoinSeason === 'Emerging') {
                altSeasonEl.style.background = 'rgba(139, 92, 246, 0.2)';
                altSeasonEl.style.color = '#a78bfa';
            } else {
                altSeasonEl.style.background = 'rgba(139, 92, 246, 0.1)';
                altSeasonEl.style.color = '#8b5cf6';
            }
        }

        function formatMarketCap(value) {
            if (value >= 1e12) {
                return '$' + (value / 1e12).toFixed(2) + 'T';
            } else if (value >= 1e9) {
                return '$' + (value / 1e9).toFixed(2) + 'B';
            } else if (value >= 1e6) {
                return '$' + (value / 1e6).toFixed(2) + 'M';
            } else {
                return '$' + value.toFixed(0);
            }
        }
        
        function formatVolume(volume) {
            if (volume >= 1e9) {
                return '$' + (volume / 1e9).toFixed(2) + 'B';
            } else if (volume >= 1e6) {
                return '$' + (volume / 1e6).toFixed(2) + 'M';
            } else if (volume >= 1e3) {
                return '$' + (volume / 1e3).toFixed(2) + 'K';
            } else {
                return '$' + volume.toFixed(2);
            }
        }

        function formatTimestamp(timestamp) {
            // Format timestamp as compact date+time for mobile: "Dec 3, 2:04 PM"
            const date = new Date(timestamp);
            const now = new Date();
            const isToday = date.toDateString() === now.toDateString();
            const yesterday = new Date(now);
            yesterday.setDate(yesterday.getDate() - 1);
            const isYesterday = date.toDateString() === yesterday.toDateString();

            const timeStr = date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });

            if (isToday) {
                return timeStr;  // Just time for today's alerts
            } else if (isYesterday) {
                return `Yesterday, ${timeStr}`;
            } else {
                // Show month and day for older alerts
                const monthDay = date.toLocaleDateString([], { month: 'short', day: 'numeric' });
                return `${monthDay}, ${timeStr}`;
            }
        }

        // Format relative time (e.g., "2h ago", "5m ago")
        function formatRelativeTime(dateInput) {
            const date = new Date(dateInput);
            const now = new Date();
            const diffMs = now - date;
            const diffSec = Math.floor(diffMs / 1000);
            const diffMin = Math.floor(diffSec / 60);
            const diffHr = Math.floor(diffMin / 60);
            const diffDays = Math.floor(diffHr / 24);

            if (diffSec < 60) return 'just now';
            if (diffMin < 60) return `${diffMin}m ago`;
            if (diffHr < 24) return `${diffHr}h ago`;
            if (diffDays === 1) return 'yesterday';
            if (diffDays < 7) return `${diffDays}d ago`;
            return date.toLocaleDateString();
        }

        function updateTopMovers(data) {
            console.log('[DEBUG] updateTopMovers() called');
            console.log('[DEBUG] gainers:', data?.gainers?.length || 0, 'losers:', data?.losers?.length || 0);
            const gainersList = document.getElementById('topGainersList');
            const losersList = document.getElementById('topLosersList');

            // Clear loading state
            gainersList.innerHTML = '';
            losersList.innerHTML = '';

            // Get gainers and losers
            const gainers = data.gainers || [];
            const losers = data.losers || [];
            
            // Display top 5 gainers
            if (gainers.length > 0) {
                gainers.slice(0, 5).forEach(item => {
                    gainersList.innerHTML += createMoverItem(item, 'gainer');
                });
            } else {
                gainersList.innerHTML = '<div style="text-align: center; color: var(--text-secondary); font-size: 12px; padding: 10px;">No gainers found</div>';
            }
            
            // Display top 5 losers
            if (losers.length > 0) {
                losers.slice(0, 5).forEach(item => {
                    losersList.innerHTML += createMoverItem(item, 'loser');
                });
            } else {
                losersList.innerHTML = '<div style="text-align: center; color: var(--text-secondary); font-size: 12px; padding: 10px;">No losers found</div>';
            }

            // NOTE: Market Intelligence breadth gauge is now updated separately
            // using actual market_breadth data from the API, not movers array length
            // See: mobileData.market_breadth update in fetchMobileData()
        }
        
        function createMoverItem(item, type) {
            const symbol = item.symbol || item;
            const displaySymbol = item.display_symbol || symbol;
            const change = parseFloat(item.change || item.change_24h || item.percentage || 0);
            const price = item.price || item.last || 0;
            const volume = item.volume || item.volume_24h || 0;
            
            const changeColor = type === 'gainer' ? 'var(--accent-positive)' : 'var(--accent-negative)';
            const changePrefix = type === 'gainer' ? '+' : '';
            
            // Use the cleaned display symbol (1000 prefix already removed from API)
            // Also remove USDT suffix for even cleaner display
            const finalDisplaySymbol = displaySymbol.replace('USDT', '').replace('USD', '');
            
            return `
                <div style="background: var(--bg-secondary); border: 1px solid var(--border-light); border-radius: 8px; padding: 10px; cursor: pointer;" onclick="viewSymbol('${symbol}')">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                        <span style="font-weight: 600; font-size: 13px; color: var(--text-primary);">${finalDisplaySymbol}</span>
                        <span style="font-weight: 700; font-size: 14px; color: ${changeColor};">${changePrefix}${Math.abs(change).toFixed(2)}%</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span style="font-size: 11px; color: var(--text-secondary);">$${price > 100 ? price.toFixed(2) : price.toFixed(4)}</span>
                        <span style="font-size: 10px; color: var(--text-secondary);">Vol: ${(volume / 1e6).toFixed(1)}M</span>
                    </div>
                </div>
            `;
        }

        // Component creators - Compact row format (matching Top Movers style)
        function createOpportunityCard(opp) {
            console.log('[DEBUG] createOpportunityCard() called with:', JSON.stringify(opp));
            if (!opp || !opp.symbol) {
                console.error('[DEBUG] Invalid opportunity object:', opp);
                return '<div style="padding: 8px; color: var(--text-secondary);">Invalid data</div>';
            }

            // Score color: green for high, yellow for medium, gray for low
            const scoreColor = opp.score >= 70 ? 'var(--accent-positive)' : opp.score >= 55 ? 'var(--accent-warning)' : 'var(--text-secondary)';
            const momentum = opp.momentum || `${opp.price_change > 0 ? '+' : ''}${(opp.price_change || 0).toFixed(1)}%`;
            const isBullish = opp.direction === 'bullish' || opp.price_change > 0;
            const momentumColor = isBullish ? 'var(--accent-positive)' : 'var(--accent-negative)';

            // SVG icons with appropriate colors
            const trendIcon = isBullish
                ? `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" style="vertical-align: middle;"><path d="M7 17L17 7M17 7H7M17 7V17" stroke="var(--accent-positive)" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/></svg>`
                : `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" style="vertical-align: middle;"><path d="M7 7L17 17M17 17H7M17 17V7" stroke="var(--accent-negative)" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
            const directionText = opp.direction || (isBullish ? 'bullish' : 'bearish');
            const directionColor = isBullish ? 'var(--accent-positive)' : 'var(--accent-negative)';

            // Option C: Dense Two-Column Layout - eliminates whitespace
            return `<div style="background: var(--bg-secondary); border: 1px solid var(--border-light); border-radius: 8px; padding: 10px; cursor: pointer; margin-bottom: 6px;" onclick="viewConfluenceAnalysis('${opp.symbol}')">
                    <div style="display: grid; grid-template-columns: 1fr auto; gap: 4px 10px;">
                        <div style="display: flex; flex-direction: column; gap: 2px;">
                            <span style="font-weight: 600; font-size: 14px; color: var(--text-primary);">${opp.symbol}</span>
                            <span style="font-size: 11px; color: ${directionColor}; display: flex; align-items: center; gap: 4px;">${trendIcon} ${directionText}</span>
                        </div>
                        <div style="display: flex; flex-direction: column; gap: 2px; text-align: right;">
                            <div style="display: flex; align-items: center; gap: 6px; justify-content: flex-end;">
                                <span style="font-size: 11px; font-weight: 600; color: ${scoreColor}; background: ${scoreColor}20; padding: 2px 6px; border-radius: 4px;">${opp.score}</span>
                                <span style="font-weight: 700; font-size: 14px; color: ${momentumColor};">${momentum}</span>
                            </div>
                            <span style="font-size: 11px; color: var(--text-secondary);">${opp.volume || 'N/A'}</span>
                        </div>
                    </div>
                </div>`;
        }

        function createTradeSignalCard(signal) {
            // Extract trade signal data
            const symbol = signal.symbol || 'N/A';
            const direction = signal.direction || 'NEUTRAL';
            const isLong = direction === 'LONG';
            const score = parseFloat(signal.confluence_score || 50);
            const entryPrice = parseFloat(signal.entry_price || signal.current_price || 0);
            const stopLoss = parseFloat(signal.stop_loss || 0);
            const takeProfit = parseFloat(signal.take_profit || 0);
            const currentPrice = parseFloat(signal.current_price || entryPrice);
            const rrRatio = parseFloat(signal.risk_reward_ratio || 2.0);
            const pnlPct = parseFloat(signal.current_pnl_pct || 0);
            const timeRemaining = parseFloat(signal.time_remaining_hours || 24);
            const status = signal.status || 'ACTIVE';
            const change24h = parseFloat(signal.change_24h || 0);

            // Format prices intelligently (more decimals for small prices)
            const formatPrice = (p) => {
                if (p >= 1000) return p.toFixed(2);
                if (p >= 1) return p.toFixed(4);
                return p.toFixed(6);
            };

            // Colors based on direction
            const dirColor = isLong ? 'var(--accent-positive)' : 'var(--accent-negative)';
            const dirBg = isLong ? 'rgba(16, 185, 129, 0.15)' : 'rgba(239, 68, 68, 0.15)';
            const dirIcon = isLong ? 'trending-up' : 'trending-down';

            // P&L color
            const pnlColor = pnlPct > 0 ? 'var(--accent-positive)' : pnlPct < 0 ? 'var(--accent-negative)' : 'var(--text-secondary)';
            const pnlPrefix = pnlPct > 0 ? '+' : '';

            // Status styling
            const statusStyles = {
                'ACTIVE': { color: 'var(--neon-amber)', bg: 'rgba(251, 191, 36, 0.15)', icon: 'circle-dot', text: 'Active' },
                'HIT_TP': { color: 'var(--accent-positive)', bg: 'rgba(16, 185, 129, 0.15)', icon: 'check-circle', text: 'TP Hit ' },
                'HIT_SL': { color: 'var(--accent-negative)', bg: 'rgba(239, 68, 68, 0.15)', icon: 'x-circle', text: 'SL Hit ' },
                'EXPIRED': { color: 'var(--text-secondary)', bg: 'rgba(128, 128, 128, 0.15)', icon: 'clock', text: 'Expired' }
            };
            const statusStyle = statusStyles[status] || statusStyles['ACTIVE'];

            // Score color
            const scoreColor = score >= 70 ? 'var(--accent-positive)' : score >= 55 ? 'var(--neon-amber)' : 'var(--text-secondary)';

            // Calculate distance to TP/SL for progress indicator
            // FIX: Prevent NaN when totalRange is 0 (missing TP/SL data)
            const totalRange = Math.abs(takeProfit - stopLoss);
            const currentFromEntry = currentPrice - entryPrice;
            let progressPct = 50; // Default to midpoint if no TP/SL data
            if (totalRange > 0) {
                progressPct = isLong
                    ? ((currentPrice - stopLoss) / totalRange) * 100
                    : ((stopLoss - currentPrice) / totalRange) * 100;
            }
            const clampedProgress = Math.max(0, Math.min(100, isNaN(progressPct) ? 50 : progressPct));

            // Remove USDT suffix for cleaner display
            const displaySymbol = symbol.replace(/USDT$/i, '');
            const fullSymbol = symbol.replace(/USDT$/i, 'USDT');

            return `
                <div style="background: var(--bg-secondary); border: 1px solid var(--border-light); border-radius: 12px; padding: 14px; margin-bottom: 10px;">
                    <!-- Header: Symbol + Direction + Status -->
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span style="font-weight: 700; font-size: 16px; color: var(--text-primary);">${displaySymbol}</span>
                            <div style="background: ${dirBg}; padding: 4px 10px; border-radius: 6px; display: flex; align-items: center; gap: 4px;">
                                <i data-lucide="${dirIcon}" style="width: 14px; height: 14px; color: ${dirColor};"></i>
                                <span style="font-size: 12px; font-weight: 600; color: ${dirColor};">${direction}</span>
                            </div>
                        </div>
                        <div style="display: flex; align-items: center; gap: 6px;">
                            <div style="background: ${statusStyle.bg}; padding: 4px 8px; border-radius: 6px;">
                                <span style="font-size: 11px; font-weight: 500; color: ${statusStyle.color};">${statusStyle.text}</span>
                            </div>
                            <div style="background: ${scoreColor}20; padding: 4px 8px; border-radius: 6px;">
                                <span style="font-size: 12px; font-weight: 700; color: ${scoreColor};">${score.toFixed(0)}</span>
                            </div>
                        </div>
                    </div>

                    <!-- Price Levels Grid -->
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-bottom: 12px;">
                        <div style="background: rgba(0,0,0,0.2); padding: 8px; border-radius: 6px; text-align: center;">
                            <div style="font-size: 9px; color: var(--accent-negative); text-transform: uppercase; margin-bottom: 2px;">Stop Loss</div>
                            <div style="font-size: 13px; font-weight: 600; color: var(--text-primary);">$${formatPrice(stopLoss)}</div>
                        </div>
                        <div style="background: rgba(251, 191, 36, 0.1); padding: 8px; border-radius: 6px; text-align: center; border: 1px solid var(--neon-amber);">
                            <div style="font-size: 9px; color: var(--neon-amber); text-transform: uppercase; margin-bottom: 2px;">Entry</div>
                            <div style="font-size: 13px; font-weight: 700; color: var(--neon-amber);">$${formatPrice(entryPrice)}</div>
                        </div>
                        <div style="background: rgba(0,0,0,0.2); padding: 8px; border-radius: 6px; text-align: center;">
                            <div style="font-size: 9px; color: var(--accent-positive); text-transform: uppercase; margin-bottom: 2px;">Take Profit</div>
                            <div style="font-size: 13px; font-weight: 600; color: var(--text-primary);">$${formatPrice(takeProfit)}</div>
                        </div>
                    </div>

                    <!-- Progress Bar (current price position) -->
                    <div style="margin-bottom: 12px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                            <span style="font-size: 10px; color: var(--text-secondary);">SL</span>
                            <span style="font-size: 11px; color: var(--text-primary);">Current: <span style="font-weight: 600; color: ${pnlColor};">$${formatPrice(currentPrice)}</span></span>
                            <span style="font-size: 10px; color: var(--text-secondary);">TP</span>
                        </div>
                        <div style="height: 6px; background: rgba(0,0,0,0.3); border-radius: 3px; overflow: hidden; position: relative;">
                            <div style="position: absolute; left: 0; top: 0; height: 100%; width: ${clampedProgress}%; background: linear-gradient(90deg, var(--accent-negative), var(--neon-amber), var(--accent-positive)); border-radius: 3px;"></div>
                            <div style="position: absolute; left: calc(${clampedProgress}% - 4px); top: -1px; width: 8px; height: 8px; background: white; border-radius: 50%; box-shadow: 0 0 4px rgba(0,0,0,0.5);"></div>
                        </div>
                    </div>

                    <!-- Stats Row -->
                    <div style="display: flex; justify-content: space-between; align-items: center; padding-top: 10px; border-top: 1px solid var(--border-light);">
                        <div style="display: flex; gap: 12px;">
                            <div>
                                <span style="font-size: 10px; color: var(--text-secondary);">P&L</span>
                                <div style="font-size: 14px; font-weight: 700; color: ${pnlColor};">${pnlPrefix}${pnlPct.toFixed(2)}%</div>
                            </div>
                            <div>
                                <span style="font-size: 10px; color: var(--text-secondary);">R:R</span>
                                <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">${rrRatio.toFixed(1)}:1</div>
                            </div>
                            <div>
                                <span style="font-size: 10px; color: var(--text-secondary);">Expires</span>
                                <div style="font-size: 14px; font-weight: 600; color: ${timeRemaining < 4 ? 'var(--accent-negative)' : 'var(--text-primary)'};">${timeRemaining.toFixed(0)}h</div>
                            </div>
                        </div>
                        <button class="action-btn btn-primary" style="flex: none; padding: 6px 28px; font-size: 11px;" onclick="window.open('https://www.bybit.com/trade/usdt/${fullSymbol}', '_blank')">
                            Trade
                        </button>
                    </div>
                </div>
            `;
        }

        // Legacy createSignalCard for backward compatibility
        function createSignalCard(signal) {
            return createTradeSignalCard(signal);
        }


        function createAlphaCard(opp) {
            const isBullish = opp.direction === 'bullish';
            const dirColor = isBullish ? 'var(--accent-positive)' : 'var(--accent-negative)';
            const dirBg = isBullish ? 'rgba(16, 185, 129, 0.15)' : 'rgba(239, 68, 68, 0.15)';
            const dirIcon = isBullish ? 'trending-up' : 'trending-down';
            const scoreColor = opp.score >= 65 ? 'var(--accent-positive)' : opp.score >= 50 ? 'var(--accent-warning)' : 'var(--accent-negative)';

            return `
                <div class="opportunity-item" style="background: var(--bg-secondary); border: 1px solid var(--border-light); border-radius: 12px; padding: 14px; margin-bottom: 10px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span style="font-weight: 700; font-size: 16px; color: var(--text-primary);">${opp.symbol}</span>
                            <i data-lucide="${dirIcon}" style="width: 16px; height: 16px; color: ${dirColor};"></i>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <div style="background: ${dirBg}; padding: 4px 10px; border-radius: 6px;">
                                <span style="font-size: 13px; font-weight: 600; color: ${dirColor};">${opp.momentum}</span>
                            </div>
                        </div>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-bottom: 10px;">
                        <div style="background: rgba(0,0,0,0.2); padding: 8px; border-radius: 6px; text-align: center;">
                            <div style="font-size: 9px; color: var(--text-secondary); text-transform: uppercase; margin-bottom: 2px;">Score</div>
                            <div style="font-size: 14px; font-weight: 700; color: ${scoreColor};">${opp.score}</div>
                        </div>
                        <div style="background: rgba(0,0,0,0.2); padding: 8px; border-radius: 6px; text-align: center;">
                            <div style="font-size: 9px; color: var(--text-secondary); text-transform: uppercase; margin-bottom: 2px;">Opp Score</div>
                            <div style="font-size: 14px; font-weight: 600; color: var(--neon-amber);">${opp.opportunity_score?.toFixed(1) || 'N/A'}</div>
                        </div>
                        <div style="background: rgba(0,0,0,0.2); padding: 8px; border-radius: 6px; text-align: center;">
                            <div style="font-size: 9px; color: var(--text-secondary); text-transform: uppercase; margin-bottom: 2px;">Volume</div>
                            <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">${opp.volume}</div>
                        </div>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span style="font-size: 11px; color: var(--text-secondary); text-transform: capitalize;">${opp.direction} setup</span>
                        <button class="action-btn btn-primary" style="padding: 6px 14px; font-size: 11px;" onclick="window.open('https://www.bybit.com/trade/usdt/${opp.full_symbol}', '_blank')">
                            Trade
                        </button>
                    </div>
                </div>
            `;
        }

        // Alert card redesign - handles both whale trades and liquidation cascades
        function createAlertCard(alert) {
            const message = alert.message || '';
            const details = alert.details || {};
            const level = alert.level || 'warning';

            // Infer alert type from message if not explicitly set
            let alertType = alert.alert_type || alert.details?.type || alert.type || '';

            // Fallback: infer type from message content for regime change alerts
            if (!alertType && message) {
                if (message.toLowerCase().includes('regime')) {
                    alertType = 'regime_change';
                } else if (message.toLowerCase().includes('whale')) {
                    alertType = 'whale_trade';
                } else if (message.toLowerCase().includes('liquidation')) {
                    alertType = 'liquidation_cascade';
                } else if (message.toLowerCase().includes('signal') || message.toLowerCase().includes('confluence')) {
                    alertType = 'high_confluence';
                }
            }

            // Determine symbol - strip USDT suffix for cleaner display
            let symbol = alert.symbol;
            if (symbol && symbol !== 'null' && symbol !== 'UNKNOWN') {
                // Clean up symbol format (BTCUSDT -> BTC, ETHUSDT -> ETH)
                symbol = symbol.replace(/USDT$/i, '');
            } else {
                symbol = 'UNKNOWN';
            }

            // Parse timestamp - handle both numeric (Unix ms) and string formats
            let alertDate;
            if (alert.unix_timestamp) {
                alertDate = new Date(alert.unix_timestamp * 1000);
            } else if (alert.timestamp) {
                if (typeof alert.timestamp === 'number') {
                    alertDate = new Date(alert.timestamp);
                } else {
                    alertDate = new Date(alert.timestamp.replace(' ', 'T') + 'Z');
                }
            } else {
                alertDate = new Date();
            }
            const relativeTime = formatRelativeTime(alertDate);

            // Extract data based on alert type
            let totalValue = 0;
            let dominant = '';
            let alertLabel = '';
            let confidence = 0;  // For regime changes

            if (alertType === 'whale_trade') {
                // Whale trade: data is nested in details.data
                const data = details.data || {};
                totalValue = data.largest_trade_usd || 0;
                dominant = data.direction || data.largest_trade_side?.toUpperCase() || '';
                alertLabel = ' Whale';
            } else if (alertType === 'liquidation_cascade') {
                // Liquidation cascade: data is directly in details
                totalValue = details.total_value || 0;
                dominant = details.dominant || details.largest_side || '';
                alertLabel = ' Liq';
            } else if (alertType === 'regime_change') {
                // Regime change: show transition info with confidence
                const newRegime = details.new_regime || '';
                const prevRegime = details.previous_regime || '';
                confidence = details.new_confidence || 0;
                alertLabel = ' Regime';
                // Determine direction based on new regime
                if (newRegime.includes('uptrend')) {
                    dominant = ' ' + newRegime.replace('_', ' ').replace('moderate ', '').toUpperCase();
                } else if (newRegime.includes('downtrend')) {
                    dominant = ' ' + newRegime.replace('_', ' ').replace('moderate ', '').toUpperCase();
                } else if (newRegime.includes('volatility')) {
                    dominant = ' HIGH VOL';
                } else if (newRegime === 'ranging') {
                    dominant = ' RANGING';
                } else {
                    dominant = newRegime.replace('_', ' ').toUpperCase();
                }
            } else if (alertType === 'high_confluence' || alertType === 'signal') {
                // High confluence / Signal alerts: show signal type and confluence score
                const signalType = details.signal_type || details.type || '';
                confidence = (details.confluence_score || details.score || 0) / 100;  // Convert to 0-1 range
                alertLabel = ' Signal';
                // Determine direction based on signal type
                if (signalType.toUpperCase() === 'LONG' || signalType.toUpperCase() === 'BUY') {
                    dominant = ' LONG';
                } else if (signalType.toUpperCase() === 'SHORT' || signalType.toUpperCase() === 'SELL') {
                    dominant = ' SHORT';
                } else {
                    dominant = signalType.toUpperCase() || 'NEUTRAL';
                }
            } else {
                // Fallback for other alert types
                totalValue = details.total_value || details.data?.largest_trade_usd || 0;
                dominant = details.dominant || details.data?.direction || '';
            }

            const isGlobal = details.is_global || symbol === 'GLOBAL';

            // Severity  background tint (brand style guide colors)
            let bgTint = 'rgba(251, 191, 36, 0.04)';  // Default: subtle amber
            if (alertType === 'whale_trade') {
                bgTint = 'rgba(59, 130, 246, 0.08)';  // Blue wash for whales
            } else if (alertType === 'regime_change') {
                bgTint = 'rgba(139, 92, 246, 0.08)';  // Purple wash for regime changes
            } else if (alertType === 'high_confluence' || alertType === 'signal') {
                bgTint = 'rgba(16, 185, 129, 0.08)';  // Green wash for signals
            } else if (message.includes('') || message.includes('CRITICAL') || level === 'critical') {
                bgTint = 'rgba(239, 68, 68, 0.12)';  // Red wash
            } else if (message.includes('') || message.includes('HIGH')) {
                bgTint = 'rgba(245, 158, 11, 0.10)';  // Orange wash
            } else if (message.includes('') || message.includes('MODERATE')) {
                bgTint = 'rgba(251, 191, 36, 0.06)';  // Amber wash
            }

            // Side color based on direction
            // For whale trades: SELL = bearish (red), BUY = bullish (green)
            // For liquidations: SHORT = bullish (green, shorts got liquidated), LONG = bearish (red)
            // For regime changes: uptrend = green, downtrend = red, volatility = orange, ranging = gray
            // For signals: LONG = bullish (green), SHORT = bearish (red)
            let sideColor = '#6b7280';  // Default gray
            if (alertType === 'whale_trade') {
                sideColor = dominant === 'BUY' ? '#10b981' : '#ef4444';
            } else if (alertType === 'regime_change') {
                if (dominant.includes('') || dominant.includes('UPTREND')) {
                    sideColor = '#10b981';  // Green for uptrend
                } else if (dominant.includes('') || dominant.includes('DOWNTREND')) {
                    sideColor = '#ef4444';  // Red for downtrend
                } else if (dominant.includes('') || dominant.includes('VOL')) {
                    sideColor = '#f59e0b';  // Orange for high volatility
                } else {
                    sideColor = '#8b5cf6';  // Purple for ranging/other
                }
            } else if (alertType === 'high_confluence' || alertType === 'signal') {
                // Signals: LONG = green, SHORT = red
                if (dominant.includes('LONG') || dominant.includes('')) {
                    sideColor = '#10b981';  // Green for long
                } else if (dominant.includes('SHORT') || dominant.includes('')) {
                    sideColor = '#ef4444';  // Red for short
                } else {
                    sideColor = '#6b7280';  // Gray for neutral
                }
            } else {
                sideColor = dominant === 'SHORT' ? '#10b981' : '#ef4444';
            }

            // Format value compactly (or confidence/score for regime changes and signals)
            let valueStr = '';
            let isConfidence = false;  // Flag to style confidence differently
            if ((alertType === 'regime_change' || alertType === 'high_confluence' || alertType === 'signal') && confidence > 0) {
                // Show confidence as smaller labeled value for regime changes and signals
                valueStr = Math.round(confidence * 100) + '%';
                isConfidence = true;
            } else if (totalValue >= 1000000) {
                valueStr = '$' + (totalValue / 1000000).toFixed(1) + 'M';
            } else if (totalValue >= 1000) {
                valueStr = '$' + Math.round(totalValue / 1000) + 'K';
            } else if (totalValue > 0) {
                valueStr = '$' + Math.round(totalValue);
            }

            // Clean symbol - strip 1000 prefix and USDT suffix
            let displaySymbol = isGlobal ? 'GLOBAL' : symbol.replace('USDT', '');
            if (displaySymbol.startsWith('1000') && displaySymbol.length > 4) {
                displaySymbol = displaySymbol.substring(4);
            }

            // For signal alerts, add click handler to navigate to Signals tab
            const isSignalAlert = alertType === 'high_confluence' || alertType === 'signal';
            const clickHandler = isSignalAlert ? `onclick="navigateToAlertedSignals()"` : '';
            const cursorStyle = isSignalAlert ? 'cursor: pointer;' : '';

            return `
                <div class="signal-card" data-alert-type="${alertType}" ${clickHandler} style="
                    padding: 12px 16px;
                    background: ${bgTint};
                    border-radius: 8px;
                    display: flex;
                    flex-direction: column;
                    gap: 6px;
                    font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
                    ${cursorStyle}
                ">
                    <!-- Row 1: Symbol (left) + Direction + Value (right) -->
                    <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                        <span style="font-size: 15px; font-weight: 600; color: #fbbf24; font-family: 'IBM Plex Mono', monospace;">${displaySymbol}</span>
                        <div style="display: flex; align-items: center; gap: 12px;">
                            ${dominant ? `<span style="font-size: 12px; font-weight: 600; color: ${sideColor}; font-family: 'IBM Plex Mono', monospace; letter-spacing: 0.5px;">${dominant}</span>` : ''}
                            ${isConfidence
                                ? `<span style="font-size: 11px; color: #6b7280; font-family: 'IBM Plex Mono', monospace; background: rgba(255,255,255,0.05); padding: 2px 6px; border-radius: 4px;"><span style="font-weight: 600; color: #d1d5db;">${valueStr}</span> Conf</span>`
                                : `<span style="font-size: 17px; font-weight: 700; color: #e0e0e0; font-family: 'IBM Plex Mono', monospace;">${valueStr}</span>`
                            }
                        </div>
                    </div>
                    <!-- Row 2: Alert message -->
                    ${message ? `<div style="font-size: 11px; color: #9ca3af; line-height: 1.4; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;">${message.replace(/\s*/g, '').replace(/\s*/g, '').replace(/\s*/g, '')}</div>` : ''}
                    <!-- Row 3: Time (left) + Label tags (right) -->
                    <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                        <span style="font-size: 10px; color: #6b7280;">${relativeTime}</span>
                        ${alertLabel ? `<span style="font-size: 9px; color: #9ca3af; padding: 2px 6px; background: rgba(255,255,255,0.05); border-radius: 4px;">${alertLabel.replace(/^[]\s*/, '')}</span>` : ''}
                    </div>
                </div>
            `;
        }

        function createAnalyzedSymbolItem(symbol) {
            // Handle different data formats
            const symbolName = symbol.symbol || symbol;
            const price = symbol.price || symbol.current_price || 0;
            const confluenceScore = symbol.confluence_score || symbol.score || 50;
            const change = symbol.price_change_percent || symbol.change_24h || 0;
            const changeValue = typeof change === 'string' ? parseFloat(change) : change;
            const volume = symbol.volume || symbol.volume_24h || 0;
            const volume_usd = symbol.volume_usd || symbol.quote_volume || symbol.turnover_24h || (volume * price) || 0;
            const high_24h = symbol.high_24h || symbol.high || 0;
            const low_24h = symbol.low_24h || symbol.low || 0;
            
            // Extract component scores if available
            const components = symbol.components || symbol.results || {};
            // Note: reliability from backend is 0-1 decimal, convert to percentage (0-100)
            const reliabilityRaw = symbol.reliability || 0;
            const reliability = reliabilityRaw <= 1 ? reliabilityRaw * 100 : reliabilityRaw;
            const signalType = symbol.signal_type || symbol.type || 'NEUTRAL';
            const signalStrength = symbol.signal_strength || symbol.strength || 'weak';
            const timestamp = symbol.timestamp || Date.now();
            
            // Generate unique ID for expand/collapse
            const cardId = `card_${symbolName.replace(/[^a-zA-Z0-9]/g, '_')}`;
            
            // Determine score color and get trend icon
            let scoreColor = 'var(--text-secondary)';
            let scoreBg = 'rgba(255, 255, 255, 0.05)';
            let scoreLevel = 'WEAK';
            let trendIcon = 'minus';
            
            if (confluenceScore >= 70) {
                scoreColor = 'var(--accent-positive)';
                scoreBg = 'rgba(76, 175, 80, 0.1)';
                scoreLevel = 'STRONG';
                trendIcon = 'trending-up';
            } else if (confluenceScore >= 50) {
                scoreColor = 'var(--accent-warning)';
                scoreBg = 'rgba(255, 191, 0, 0.1)';
                scoreLevel = 'MODERATE';
                trendIcon = changeValue > 0 ? 'trending-up' : 'trending-down';
            } else {
                scoreColor = 'var(--accent-negative)';
                scoreBg = 'rgba(244, 67, 54, 0.1)';
                scoreLevel = 'WEAK';
                trendIcon = 'trending-down';
            }
            
            // Format symbol name (remove 1000 prefix and USDT suffix for display)
            let displaySymbol = symbolName;
            if (displaySymbol.startsWith('1000') && displaySymbol.length > 4) {
                displaySymbol = displaySymbol.substring(4);
            }
            displaySymbol = displaySymbol.replace('USDT', '').replace('USD', '');
            const changePrefix = changeValue > 0 ? '+' : '';
            const changeColor = changeValue >= 0 ? 'var(--accent-positive)' : 'var(--accent-negative)';
            
            // Format turnover/USD volume
            let turnoverDisplay = '';
            if (volume_usd > 0) {
                turnoverDisplay = volume_usd > 1e9 ? '$' + (volume_usd/1e9).toFixed(2) + 'B' : 
                                 volume_usd > 1e6 ? '$' + (volume_usd/1e6).toFixed(1) + 'M' : 
                                 volume_usd > 1e3 ? '$' + (volume_usd/1e3).toFixed(1) + 'K' : 
                                 '$' + volume_usd.toFixed(0);
            }
            
            // Calculate price range percentage
            const priceRange = high_24h > 0 && low_24h > 0 ? ((high_24h - low_24h) / low_24h * 100).toFixed(2) : 0;
            
            // Component scores for mini visualization
            const componentScores = {
                technical: components.technical || 50,
                volume: components.volume || 50,
                orderflow: components.orderflow || 50,
                sentiment: components.sentiment || 50,
                orderbook: components.orderbook || 50,
                price_structure: components.price_structure || 50
            };

            // Extract timeframe metadata for this card
            const tfMeta = signal.timeframe_metadata || {};
            const tfWeightsText = tfMeta.weights_label || '1m: 40% | 5m: 30% | 30m: 20% | 4h: 10%';
            
            return `
                <div class="symbol-card" id="${cardId}" style="background: var(--bg-secondary); border: 1px solid var(--border-light); border-radius: 14px; cursor: pointer; transition: all 0.2s ease; position: relative; overflow: hidden; margin-bottom: 12px;">
                    <!-- Score indicator bar -->
                    <div style="position: absolute; top: 0; left: 0; right: 0; height: 4px; background: ${scoreColor}; opacity: 0.9;"></div>

                    <!-- Main card content (always visible) -->
                    <div style="padding: 18px 16px;" onclick="toggleCardExpansion('${cardId}')">
                        <!-- Header with symbol and score -->
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 14px;">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <span style="font-weight: 700; font-size: 18px; color: var(--text-primary);">${displaySymbol}</span>
                                <i data-lucide="${trendIcon}" style="width: 16px; height: 16px; color: ${scoreColor};"></i>
                            </div>
                            <div style="background: ${scoreBg}; padding: 6px 10px; border-radius: 8px;">
                                <span style="font-size: 15px; font-weight: 700; color: ${scoreColor};">${Math.round(confluenceScore)}</span>
                            </div>
                        </div>

                        <!-- Price and change row -->
                        <div style="display: flex; justify-content: space-between; align-items: baseline; margin-bottom: 14px;">
                            <div style="font-size: 16px; font-weight: 600; color: var(--text-primary);">
                                $${price > 100 ? price.toFixed(2) : price < 1 ? price.toFixed(4) : price.toFixed(3)}
                            </div>
                            <div style="font-size: 14px; font-weight: 600; color: ${changeColor};">
                                ${changePrefix}${Math.abs(changeValue).toFixed(2)}%
                            </div>
                        </div>
                        
                        <!-- Turnover and range row -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 14px;">
                            <div style="padding: 10px 8px; background: rgba(0, 0, 0, 0.25); border-radius: 8px;">
                                <div style="font-size: 10px; color: var(--text-secondary); text-transform: uppercase; margin-bottom: 2px;">Turnover</div>
                                <div style="font-size: 13px; font-weight: 600; color: var(--text-primary);">${turnoverDisplay || 'N/A'}</div>
                            </div>
                            <div style="padding: 10px 8px; background: rgba(0, 0, 0, 0.25); border-radius: 8px;">
                                <div style="font-size: 10px; color: var(--text-secondary); text-transform: uppercase; margin-bottom: 2px;">24H Range</div>
                                <div style="font-size: 13px; font-weight: 600; color: var(--text-primary);">${priceRange}%</div>
                            </div>
                        </div>

                        <!-- Component breakdown mini bars -->
                        <div style="display: flex; gap: 3px; margin-bottom: 10px;">
                            ${Object.entries(componentScores).map(([comp, score]) => {
                                const height = Math.max(12, (score / 100) * 36);
                                const barColor = score >= 70 ? 'var(--accent-positive)' : score >= 30 ? 'var(--accent-warning)' : 'var(--accent-negative)';
                                return `<div style="flex: 1; background: rgba(255, 255, 255, 0.05); border-radius: 3px; height: 36px; position: relative; overflow: hidden;">
                                    <div style="position: absolute; bottom: 0; width: 100%; height: ${height}px; background: ${barColor}; opacity: 0.8;"></div>
                                </div>`;
                            }).join('')}
                        </div>

                        <!-- Expand indicator -->
                        <div style="display: flex; justify-content: center; margin-top: 10px;">
                            <i data-lucide="chevron-down" style="width: 16px; height: 16px; color: var(--text-secondary); transition: transform 0.3s;" id="${cardId}_chevron"></i>
                        </div>
                    </div>
                    
                    <!-- Expanded content (hidden by default) -->
                    <div id="${cardId}_expanded" style="display: none; padding: 0 16px 16px 16px; border-top: 1px solid var(--border-light);">
                        <!-- Timeframe weights badge -->
                        <div style="display: flex; align-items: center; gap: 6px; margin: 12px 0 8px 0; padding: 6px 8px; background: rgba(139, 92, 246, 0.1); border: 1px solid rgba(139, 92, 246, 0.2); border-radius: 6px;">
                            <i data-lucide="clock" style="width: 12px; height: 12px; color: var(--accent-primary); opacity: 0.8;"></i>
                            <span style="font-size: 9px; color: var(--text-secondary); font-weight: 500;">TF Weights: ${tfWeightsText}</span>
                        </div>

                        <!-- Component scores breakdown -->
                        <div style="margin-bottom: 12px;">
                            <h4 style="font-size: 12px; font-weight: 600; color: var(--text-primary); margin-bottom: 8px; text-transform: uppercase;">Component Breakdown</h4>
                            ${Object.entries(componentScores).map(([comp, score]) => {
                                const compColor = score >= 70 ? 'var(--accent-positive)' : score >= 30 ? 'var(--accent-warning)' : 'var(--accent-negative)';
                                const compName = comp.replace('_', ' ').charAt(0).toUpperCase() + comp.replace('_', ' ').slice(1);
                                return `
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                                    <span style="font-size: 11px; color: var(--text-secondary);">${compName}</span>
                                    <div style="display: flex; align-items: center; gap: 6px;">
                                        <div style="width: 60px; height: 4px; background: rgba(255, 255, 255, 0.1); border-radius: 2px; overflow: hidden;">
                                            <div style="width: ${score}%; height: 100%; background: ${compColor};"></div>
                                        </div>
                                        <span style="font-size: 11px; font-weight: 600; color: ${compColor}; min-width: 25px; text-align: right;">${Math.round(score)}</span>
                                    </div>
                                </div>`;
                            }).join('')}
                        </div>
                        
                        <!-- Signal details -->
                        <div style="margin-bottom: 12px;">
                            <h4 style="font-size: 12px; font-weight: 600; color: var(--text-primary); margin-bottom: 8px; text-transform: uppercase;">Signal Details</h4>
                            <div style="padding: 8px; background: rgba(0, 0, 0, 0.2); border-radius: 6px; text-align: center;">
                                <div style="font-size: 9px; color: var(--text-secondary); margin-bottom: 4px;">Current Signal</div>
                                <div style="font-size: 14px; font-weight: 700; color: ${signalType === 'LONG' ? 'var(--accent-positive)' : signalType === 'SHORT' ? 'var(--accent-negative)' : 'var(--text-secondary)'};">${signalType}</div>
                            </div>
                        </div>
                        
                        <!-- Reliability and timestamp -->
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <span style="font-size: 9px; color: var(--text-secondary);">Reliability: </span>
                                <span style="font-size: 11px; font-weight: 600; color: ${reliability >= 80 ? 'var(--accent-positive)' : reliability >= 60 ? 'var(--accent-warning)' : 'var(--accent-negative)'};">${reliability.toFixed(1)}%</span>
                            </div>
                            <div style="font-size: 9px; color: var(--text-secondary);">
                                ${formatTimestamp(timestamp)}
                            </div>
                        </div>

                        <!-- Action buttons -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 14px;">
                            <button onclick="viewDetailedAnalysis('${symbolName}')" style="padding: 12px 10px; background: var(--accent-primary); border: none; border-radius: 8px; color: var(--bg-primary); font-size: 13px; font-weight: 700; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 6px;">
                                <i data-lucide="chart-line" style="width: 14px; height: 14px;"></i>
                                Analyze
                            </button>
                            <button onclick="viewAlerts('${symbolName}')" style="padding: 12px 10px; background: rgba(255, 191, 0, 0.15); border: 1px solid rgba(251, 191, 36, 0.3); border-radius: 8px; color: var(--text-primary); font-size: 13px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 6px;">
                                <i data-lucide="bell" style="width: 14px; height: 14px;"></i>
                                Alerts
                            </button>
                        </div>
                    </div>
                </div>
            `;
        }
        
        function createSymbolItem(symbol) {
            // Handle different data formats
            const symbolName = symbol.symbol || symbol;
            const price = symbol.price || symbol.current_price || 0;
            const confluenceScore = symbol.confluence_score || symbol.score || 50;
            const change = symbol.price_change_percent || symbol.change_24h || 0;
            const changeValue = typeof change === 'string' ? parseFloat(change) : change;
            const changeClass = changeValue > 0 ? 'change-positive' : changeValue < 0 ? 'change-negative' : 'change-neutral';
            const changePrefix = changeValue > 0 ? '+' : '';
            
            // Determine score color
            let scoreColor = 'var(--text-secondary)';
            if (confluenceScore >= 70) {
                scoreColor = 'var(--accent-positive)';
            } else if (confluenceScore >= 30 && confluenceScore < 70) {
                scoreColor = 'var(--accent-warning)';
            } else {
                scoreColor = 'var(--accent-negative)';
            }
            
            // Format price based on value
            const formattedPrice = price > 100 ? price.toFixed(2) : price > 1 ? price.toFixed(4) : price.toFixed(6);
            
            return `
                <div class="symbol-item" onclick="viewSymbol('${symbolName}')">
                    <div class="symbol-info">
                        <div>
                            <div class="symbol-name">${symbolName.replace('USDT', '')}</div>
                            <div class="symbol-price">$${formattedPrice}</div>
                        </div>
                    </div>
                    <div class="symbol-metrics">
                        <div class="confluence-score">
                            <div class="score-value" style="color: ${scoreColor}">${confluenceScore}</div>
                            <div class="score-label">Score</div>
                        </div>
                        <div class="symbol-change ${changeClass}">
                            ${changePrefix}${changeValue.toFixed(2)}%
                        </div>
                    </div>
                </div>
            `;
        }

        function createEmptyState(message) {
            return `
                <div class="empty-state">
                    <i data-lucide="inbox" class="empty-icon"></i>
                    <div class="empty-title">No Data</div>
                    <div class="empty-text">${message}</div>
                </div>
            `;
        }

        // Helper functions
        function getScoreClass(score) {
            if (score >= 80) return 'score-high';
            if (score >= 60) return 'score-medium';
            return 'score-low';
        }

        function getScoreColor(score) {
            if (score >= 80) return 'var(--accent-positive)';
            if (score >= 60) return 'var(--accent-warning)';
            return 'var(--accent-negative)';
        }

        // Debounce function for performance
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        const debouncedRefresh = debounce(() => {
            const activeTab = document.querySelector('.nav-item.active');
            // Extract tab name from onclick attribute (more reliable than label text)
            const onclick = activeTab.getAttribute('onclick') || '';
            const match = onclick.match(/switchTab\(['"](\w+)['"]\)/);
            const tabName = match ? match[1] : 'dashboard';

            // Load the current tab's data
            loadTabData(tabName);

            // Also refresh the price ticker (fetch fresh data)
            refreshPriceTicker();

            // Show refresh feedback with success haptic
            haptic.success();
            pullToRefresh.innerHTML = '<i data-lucide="check" style="width: 16px; height: 16px; margin-right: 8px;"></i><span>Updated</span>';
            setTimeout(() => {
                pullToRefresh.innerHTML = '<i data-lucide="refresh-cw" style="width: 16px; height: 16px; margin-right: 8px;"></i><span>Pull to refresh</span>';
                if (typeof lucide !== 'undefined') lucide.createIcons();
            }, 1000);
        }, 300);

        // Refresh price ticker independently
        async function refreshPriceTicker() {
            try {
                const response = await fetch('/api/dashboard/mobile-data');
                const data = await response.json();
                if (data.status === 'success' && data.confluence_scores) {
                    updatePriceTicker(data.confluence_scores);
                }
            } catch (e) {
                console.warn('Failed to refresh ticker:', e);
            }
        }

        function refreshData() {
            debouncedRefresh();
        }

        function toggleSettings() {
            // Implement settings panel
            alert('Settings panel coming soon!');
        }

        function viewOpportunity(symbol) {
            // Implement opportunity detail view
            console.log('View opportunity:', symbol);
        }


        function viewAlpha(id) {
            // Implement alpha detail view
            console.log('View alpha:', id);
        }

        function viewSymbol(symbol) {
            // Navigate to signals tab with symbol filter
            switchTab('signals');
            // TODO: Filter signals by symbol
            console.log('View symbol:', symbol);
        }

        // Card expansion/collapse functionality
        function toggleCardExpansion(cardId) {
            const expandedContent = document.getElementById(`${cardId}_expanded`);
            const chevron = document.getElementById(`${cardId}_chevron`);
            
            if (expandedContent.style.display === 'none') {
                // Expand
                expandedContent.style.display = 'block';
                chevron.style.transform = 'rotate(180deg)';
                
                // Smooth animation
                expandedContent.style.opacity = '0';
                expandedContent.style.maxHeight = '0';
                setTimeout(() => {
                    expandedContent.style.transition = 'all 0.3s ease';
                    expandedContent.style.opacity = '1';
                    expandedContent.style.maxHeight = '500px';
                }, 10);
            } else {
                // Collapse
                expandedContent.style.opacity = '0';
                expandedContent.style.maxHeight = '0';
                chevron.style.transform = 'rotate(0deg)';
                
                setTimeout(() => {
                    expandedContent.style.display = 'none';
                    expandedContent.style.transition = '';
                }, 300);
            }
            
            // Prevent event bubbling
            event.stopPropagation();
        }

        // Haptic feedback helper
        function triggerHapticFeedback(type = 'light') {
            if ('vibrate' in navigator) {
                const duration = type === 'light' ? 10 : type === 'medium' ? 20 : 30;
                navigator.vibrate(duration);
            }
        }

        // Track currently expanded card (accordion behavior)
        let currentlyExpandedAlphaCard = null;

        // Alpha Pulse card expansion/collapse - FLIP animation for smooth right-column expansion
        function toggleAlphaPulseCard(cardId) {
            const card = document.getElementById(cardId);
            const buttonsPanel = document.getElementById(`${cardId}_buttons`);
            const breakdownPanel = document.getElementById(`${cardId}_expanded`);
            const chevron = document.getElementById(`${cardId}_chevron`);

            if (!breakdownPanel || !card) return;

            const isExpanded = breakdownPanel.style.maxHeight && breakdownPanel.style.maxHeight !== '0px';
            const isRightColumn = card.dataset.column === 'right';

            // Accordion: collapse previously expanded card if different
            if (!isExpanded && currentlyExpandedAlphaCard && currentlyExpandedAlphaCard !== cardId) {
                const prevCard = document.getElementById(currentlyExpandedAlphaCard);
                const prevButtons = document.getElementById(`${currentlyExpandedAlphaCard}_buttons`);
                const prevBreakdown = document.getElementById(`${currentlyExpandedAlphaCard}_expanded`);
                const prevChevron = document.getElementById(`${currentlyExpandedAlphaCard}_chevron`);

                if (prevBreakdown && prevCard) {
                    // Collapse buttons panel
                    if (prevButtons) {
                        prevButtons.style.width = '0px';
                        prevButtons.style.opacity = '0';
                    }
                    // Collapse breakdown panel
                    prevBreakdown.style.maxHeight = '0px';
                    prevBreakdown.style.opacity = '0';
                    if (prevChevron) prevChevron.style.transform = 'rotate(0deg)';

                    setTimeout(() => {
                        if (prevButtons) prevButtons.style.display = 'none';
                        prevBreakdown.style.display = 'none';
                        prevCard.style.gridColumn = '';
                        prevCard.style.transform = '';
                    }, 300);
                }
            }

            if (!isExpanded) {
                // Haptic feedback on expand
                triggerHapticFeedback('light');

                // FLIP Animation for right-column cards to prevent jarring jump
                if (isRightColumn) {
                    // FIRST: Record current position before grid change
                    const firstRect = card.getBoundingClientRect();

                    // Prepare for GPU-accelerated animation
                    card.style.willChange = 'transform';

                    // LAST: Apply grid change (card will jump to column 1)
                    card.style.gridColumn = '1 / -1';

                    // Force layout recalc to get new position
                    const lastRect = card.getBoundingClientRect();

                    // INVERT: Calculate delta and apply inverse transform
                    const deltaX = firstRect.left - lastRect.left;

                    // Apply inverse transform (makes card appear in original position)
                    card.style.transition = 'none';
                    card.style.transform = `translateX(${deltaX}px)`;

                    // PLAY: Animate back to final position with smooth easing
                    // Double RAF ensures browser has fully painted before animating
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            // Ease-out-quint: ultra-smooth deceleration with soft landing
                            card.style.transition = 'transform 0.45s cubic-bezier(0.22, 1, 0.36, 1)';
                            card.style.transform = 'translateX(0)';

                            // Clean up will-change after animation completes
                            setTimeout(() => { card.style.willChange = ''; }, 450);
                        });
                    });
                } else {
                    // Left column - simple expansion
                    card.style.gridColumn = '1 / -1';
                }

                // Show buttons panel (horizontal)
                if (buttonsPanel) {
                    buttonsPanel.style.display = 'block';
                    setTimeout(() => {
                        buttonsPanel.style.width = '80px';
                        buttonsPanel.style.opacity = '1';
                    }, 10);
                }

                // Show breakdown panel (vertical, below card)
                breakdownPanel.style.display = 'block';
                if (chevron) chevron.style.transform = 'rotate(180deg)';

                // Scroll card into view with minimal movement (only if needed)
                requestAnimationFrame(() => {
                    card.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'nearest' });
                });

                setTimeout(() => {
                    breakdownPanel.style.maxHeight = '200px';
                    breakdownPanel.style.opacity = '1';
                }, 10);

                currentlyExpandedAlphaCard = cardId;

                // Re-initialize lucide icons
                if (typeof lucide !== 'undefined') {
                    lucide.createIcons();
                }
            } else {
                // FLIP Animation for collapsing right-column cards
                if (isRightColumn) {
                    // Get current position
                    const currentRect = card.getBoundingClientRect();

                    // Collapse buttons panel
                    if (buttonsPanel) {
                        buttonsPanel.style.width = '0px';
                        buttonsPanel.style.opacity = '0';
                    }

                    // Collapse breakdown panel
                    breakdownPanel.style.maxHeight = '0px';
                    breakdownPanel.style.opacity = '0';
                    if (chevron) chevron.style.transform = 'rotate(0deg)';

                    setTimeout(() => {
                        if (buttonsPanel) buttonsPanel.style.display = 'none';
                        breakdownPanel.style.display = 'none';

                        // Prepare for GPU-accelerated animation
                        card.style.willChange = 'transform';

                        // Record position after content collapse but before grid reset
                        const beforeReset = card.getBoundingClientRect();

                        // Reset grid
                        card.style.gridColumn = '';

                        // Get final position
                        const afterReset = card.getBoundingClientRect();

                        // Calculate delta (card moves right when returning to column 2)
                        const deltaX = beforeReset.left - afterReset.left;

                        // Apply inverse transform
                        card.style.transition = 'none';
                        card.style.transform = `translateX(${deltaX}px)`;

                        // Animate back with smooth easing
                        requestAnimationFrame(() => {
                            requestAnimationFrame(() => {
                                card.style.transition = 'transform 0.45s cubic-bezier(0.22, 1, 0.36, 1)';
                                card.style.transform = 'translateX(0)';

                                // Clean up will-change after animation completes
                                setTimeout(() => { card.style.willChange = ''; }, 450);
                            });
                        });
                    }, 300);
                } else {
                    // Left column - simple collapse
                    if (buttonsPanel) {
                        buttonsPanel.style.width = '0px';
                        buttonsPanel.style.opacity = '0';
                    }

                    breakdownPanel.style.maxHeight = '0px';
                    breakdownPanel.style.opacity = '0';
                    if (chevron) chevron.style.transform = 'rotate(0deg)';

                    setTimeout(() => {
                        if (buttonsPanel) buttonsPanel.style.display = 'none';
                        breakdownPanel.style.display = 'none';
                        card.style.gridColumn = '';
                    }, 300);
                }

                currentlyExpandedAlphaCard = null;
            }
        }

        function viewDetailedAnalysis(symbol) {
            // Navigate to detailed analysis page
            console.log('View detailed analysis for:', symbol);
            window.location.href = `/api/dashboard/confluence-analysis-page?symbol=${symbol}`;
            event.stopPropagation();
        }

        // ===== Alert Quick Actions Sheet =====
        let currentAlertSymbol = null;
        let currentAlertScore = 50;
        let currentAlertDirection = 'LONG';
        let symbolAlertSettings = JSON.parse(localStorage.getItem('symbolAlertSettings') || '{}');

        function viewAlerts(symbol, score, direction) {
            // Open the Quick Actions bottom sheet instead of navigating directly
            console.log('Opening alert sheet for:', symbol, 'Score:', score, 'Direction:', direction);
            // Prevent event bubbling if called from onclick (event may be undefined when called directly)
            if (typeof event !== 'undefined' && event && event.stopPropagation) {
                event.stopPropagation();
            }

            currentAlertSymbol = symbol;
            currentAlertScore = score || 50;
            currentAlertDirection = direction || 'LONG';

            // Update sheet header with symbol info
            document.getElementById('sheetSymbolName').textContent = symbol;

            document.getElementById('sheetDirection').textContent = currentAlertDirection;
            document.getElementById('sheetDirection').style.color = currentAlertDirection === 'LONG' ? 'var(--accent-positive)' : 'var(--accent-negative)';

            const scoreBadge = document.getElementById('sheetScoreBadge');
            scoreBadge.textContent = `Score: ${Math.round(currentAlertScore)}`;
            scoreBadge.className = `sheet-score-badge ${currentAlertDirection === 'LONG' ? 'bullish' : 'bearish'}`;

            // Count alerts for this symbol
            const symbolAlerts = (currentAlertsData || []).filter(a =>
                a.symbol === symbol || a.symbol === symbol.replace('USDT', '/USDT')
            );
            document.getElementById('sheetAlertCount').textContent = symbolAlerts.length;

            // Load saved settings for this symbol
            const savedSettings = symbolAlertSettings[symbol] || {
                threshold: 75,
                alertLong: true,
                alertShort: false
            };

            document.getElementById('thresholdSlider').value = savedSettings.threshold;
            document.getElementById('thresholdDisplay').textContent = ` ${savedSettings.threshold}`;

            updateToggleState('alertLongToggle', savedSettings.alertLong);
            updateToggleState('alertShortToggle', savedSettings.alertShort);

            // Show the sheet
            document.getElementById('alertSheetOverlay').classList.add('active');
            document.getElementById('alertBottomSheet').classList.add('active');

            // Re-init Lucide icons in the sheet
            setTimeout(() => {
                if (typeof lucide !== 'undefined') lucide.createIcons();
            }, 50);
        }

        function closeAlertSheet() {
            document.getElementById('alertSheetOverlay').classList.remove('active');
            document.getElementById('alertBottomSheet').classList.remove('active');
            currentAlertSymbol = null;
        }

        function updateThresholdDisplay(value) {
            document.getElementById('thresholdDisplay').textContent = ` ${value}`;
        }

        function updateToggleState(toggleId, isActive) {
            const toggle = document.getElementById(toggleId);
            if (isActive) {
                toggle.classList.add('active');
            } else {
                toggle.classList.remove('active');
            }
        }

        function toggleAlertOption(type) {
            const toggleId = type === 'long' ? 'alertLongToggle' : 'alertShortToggle';
            const toggle = document.getElementById(toggleId);
            toggle.classList.toggle('active');
        }

        function viewSymbolAlerts() {
            // Close sheet and navigate to alerts tab with symbol filter
            const symbolToFilter = currentAlertSymbol;
            closeAlertSheet();

            // Switch to alerts tab
            switchTab('alerts');

            // Apply symbol filter after a brief delay
            setTimeout(() => {
                filterAlertsBySymbol(symbolToFilter);
            }, 150);
        }

        function filterAlertsBySymbol(symbol) {
            if (!symbol) return;

            // Filter current alerts data by symbol
            const filteredAlerts = (currentAlertsData || []).filter(a =>
                a.symbol === symbol ||
                a.symbol === symbol.replace('USDT', '/USDT') ||
                (a.symbol && a.symbol.includes(symbol.replace('USDT', '')))
            );

            // Show a toast indicating the filter
            showToast(`Showing ${filteredAlerts.length} alerts for ${symbol}`, 'info');

            // Update the alert count badge to show filtered count
            document.getElementById('alertCount').textContent = `${filteredAlerts.length}`;

            // Add a "clear filter" button to the filter pills
            const alertFilters = document.getElementById('alertFilters');

            // Remove any existing symbol filter pill
            const existingSymbolPill = alertFilters.querySelector('.symbol-filter-pill');
            if (existingSymbolPill) existingSymbolPill.remove();

            // Add symbol filter pill at the beginning
            const symbolPill = document.createElement('button');
            symbolPill.className = 'alert-filter-pill active symbol-filter-pill';
            symbolPill.style.background = 'rgba(251, 191, 36, 0.2)';
            symbolPill.style.borderColor = 'var(--neon-amber)';
            symbolPill.innerHTML = `
                <span>${symbol}</span>
                <i data-lucide="x" style="width: 12px; height: 12px; margin-left: 4px;"></i>
            `;
            symbolPill.onclick = (e) => {
                e.stopPropagation();
                symbolPill.remove();
                renderAlerts(currentAlertsData, currentAlertFilter);
                document.getElementById('alertCount').textContent = currentAlertsData.length;
            };
            alertFilters.insertBefore(symbolPill, alertFilters.firstChild);

            // Re-render with filtered data
            renderAlerts(filteredAlerts, 'all');

            // Deselect type filter pills since we're showing symbol-filtered results
            document.querySelectorAll('.alert-filter-pill').forEach(pill => {
                if (!pill.classList.contains('symbol-filter-pill')) {
                    pill.classList.remove('active');
                }
            });

            // Re-init Lucide
            setTimeout(() => {
                if (typeof lucide !== 'undefined') lucide.createIcons();
            }, 50);
        }

        function saveAlertSettings() {
            if (!currentAlertSymbol) return;

            const settings = {
                threshold: parseInt(document.getElementById('thresholdSlider').value),
                alertLong: document.getElementById('alertLongToggle').classList.contains('active'),
                alertShort: document.getElementById('alertShortToggle').classList.contains('active')
            };

            symbolAlertSettings[currentAlertSymbol] = settings;
            localStorage.setItem('symbolAlertSettings', JSON.stringify(symbolAlertSettings));

            showToast(`Alert settings saved for ${currentAlertSymbol}`, 'success');
            console.log('Saved alert settings:', currentAlertSymbol, settings);

            closeAlertSheet();
        }

        // View HTML/PDF report for a signal alert
        async function viewAlertReport(symbol, timestamp) {
            console.log('View report for:', symbol, 'at timestamp:', timestamp);
            event.stopPropagation();

            try {
                // Show loading indicator
                const loadingToast = showToast('Loading reports...', 'info');

                // Fetch available reports for this symbol
                const response = await fetch(`/api/dashboard/signal-reports/${symbol}`);
                const data = await response.json();

                // Hide loading toast
                if (loadingToast) loadingToast.remove();

                // Check if we have HTML reports (PDF serving disabled)
                const hasHtml = data.html_reports && data.html_reports.length > 0;

                if (!hasHtml) {
                    // No HTML reports found - fall back to analysis page
                    showToast('No archived reports found. Opening live analysis...', 'warning');
                    setTimeout(() => {
                        window.location.href = `/api/dashboard/confluence-analysis-page?symbol=${symbol}`;
                    }, 1000);
                    return;
                }

                // Show report selector modal (HTML only)
                showReportSelectorModal(symbol, data);

            } catch (error) {
                console.error('Error fetching reports:', error);
                showToast('Error loading reports. Opening analysis page...', 'error');
                window.location.href = `/api/dashboard/confluence-analysis-page?symbol=${symbol}`;
            }
        }

        // Show a modal to select between available reports
        function showReportSelectorModal(symbol, reportsData) {
            // Remove existing modal if any
            const existingModal = document.getElementById('reportSelectorModal');
            if (existingModal) existingModal.remove();

            const displaySymbol = symbol.replace(/USDT$/i, '');
            const hasHtml = reportsData.html_reports && reportsData.html_reports.length > 0;
            const htmlCount = reportsData.html_reports?.length || 0;

            // Build report list HTML (HTML reports only)
            let reportsListHtml = '';

            // Signal Report - full branded report with charts and trade levels
            if (hasHtml) {
                // Find the latest signal report (not a SNAPSHOT file)
                const signalReports = reportsData.html_reports.filter(r => !r.filename.includes('_SNAPSHOT_'));
                if (signalReports.length > 0) {
                    const latestSignal = signalReports[0];
                    const signalDate = new Date(latestSignal.created);
                    reportsListHtml += `
                        <a href="${latestSignal.url}" target="_blank" class="report-item" style="display: flex; align-items: center; gap: 12px; padding: 14px; background: rgba(251, 191, 36, 0.1); border: 1px solid rgba(251, 191, 36, 0.3); border-radius: 10px; text-decoration: none; margin-bottom: 10px;">
                            <div style="width: 40px; height: 40px; background: rgba(251, 191, 36, 0.2); border-radius: 8px; display: flex; align-items: center; justify-content: center;">
                                <i data-lucide="file-text" style="width: 20px; height: 20px; color: #fbbf24;"></i>
                            </div>
                            <div style="flex: 1;">
                                <div style="font-weight: 600; color: var(--text-primary); font-size: 13px;">Signal Report</div>
                                <div style="font-size: 11px; color: var(--text-secondary);">${formatRelativeTime(signalDate)}  ${latestSignal.size_kb} KB</div>
                            </div>
                            <i data-lucide="external-link" style="width: 16px; height: 16px; color: var(--text-secondary);"></i>
                        </a>
                    `;
                }
            }

            // Live analysis row with Alpha Snapshot button
            // Alpha Snapshot = archived terminal-style analysis from alert time
            const snapshotReports = reportsData.html_reports?.filter(r => r.filename.includes('_SNAPSHOT_')) || [];
            const alphaSnapshotUrl = snapshotReports.length > 0 ? snapshotReports[0].url : null;
            reportsListHtml += `
                <div style="display: flex; gap: 10px; align-items: stretch;">
                    <a href="/api/dashboard/confluence-analysis-page?symbol=${symbol}" class="report-item" style="flex: 1; display: flex; align-items: center; gap: 12px; padding: 14px; background: rgba(16, 185, 129, 0.1); border: 1px solid rgba(16, 185, 129, 0.3); border-radius: 10px; text-decoration: none;">
                        <div style="width: 40px; height: 40px; background: rgba(16, 185, 129, 0.2); border-radius: 8px; display: flex; align-items: center; justify-content: center;">
                            <i data-lucide="activity" style="width: 20px; height: 20px; color: #10b981;"></i>
                        </div>
                        <div style="flex: 1;">
                            <div style="font-weight: 600; color: var(--text-primary); font-size: 13px;">Live Analysis</div>
                            <div style="font-size: 11px; color: var(--text-secondary);">Current market data</div>
                        </div>
                        <i data-lucide="chevron-right" style="width: 16px; height: 16px; color: var(--text-secondary);"></i>
                    </a>
                    ${alphaSnapshotUrl ? `
                    <a href="${alphaSnapshotUrl}" target="_blank" class="snapshot-btn" style="width: 60px; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 3px; padding: 8px 6px; background: rgba(168, 85, 247, 0.1); border: 1px solid rgba(168, 85, 247, 0.3); border-radius: 10px; text-decoration: none;">
                        <i data-lucide="camera" style="width: 18px; height: 18px; color: #a855f7;"></i>
                        <span style="font-size: 8px; color: #a855f7; font-weight: 600; text-align: center; line-height: 1.1;">ALPHA<br>SNAP</span>
                    </a>
                    ` : `
                    <div style="width: 60px; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 3px; padding: 8px 6px; background: rgba(100, 100, 100, 0.1); border: 1px solid rgba(100, 100, 100, 0.3); border-radius: 10px; opacity: 0.5;">
                        <i data-lucide="camera-off" style="width: 18px; height: 18px; color: #666;"></i>
                        <span style="font-size: 8px; color: #666; font-weight: 600; text-align: center; line-height: 1.1;">NO<br>SNAP</span>
                    </div>
                    `}
                </div>
            `;

            // Create modal
            const modal = document.createElement('div');
            modal.id = 'reportSelectorModal';
            modal.innerHTML = `
                <div style="position: fixed; inset: 0; background: rgba(0,0,0,0.7); backdrop-filter: blur(4px); z-index: 9999; display: flex; align-items: flex-end; justify-content: center;" onclick="closeReportModal(event)">
                    <div style="background: var(--bg-primary); border-radius: 20px 20px 0 0; width: 100%; max-width: 500px; max-height: 80vh; overflow: hidden; animation: slideUp 0.3s ease;" onclick="event.stopPropagation()">
                        <!-- Header -->
                        <div style="padding: 16px 20px; border-bottom: 1px solid var(--border-light); display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <h3 style="margin: 0; font-size: 16px; font-weight: 700; color: var(--text-primary);">${displaySymbol} Reports</h3>
                                <div style="font-size: 11px; color: var(--text-secondary); margin-top: 2px;">${htmlCount} archived report${htmlCount !== 1 ? 's' : ''}</div>
                            </div>
                            <button onclick="closeReportModal(event)" style="width: 32px; height: 32px; border-radius: 50%; border: none; background: var(--bg-secondary); cursor: pointer; display: flex; align-items: center; justify-content: center;">
                                <i data-lucide="x" style="width: 18px; height: 18px; color: var(--text-secondary);"></i>
                            </button>
                        </div>
                        <!-- Performance Section -->
                        <div id="performanceSection" style="padding: 12px 20px; border-bottom: 1px solid var(--border-light);">
                            <div style="text-align: center; color: var(--text-secondary); font-size: 12px;">
                                <i data-lucide="loader-2" class="spin" style="width: 16px; height: 16px; animation: spin 1s linear infinite;"></i>
                                Loading performance...
                            </div>
                        </div>
                        <!-- Reports List -->
                        <div style="padding: 16px 20px; overflow-y: auto; max-height: 50vh;">
                            ${reportsListHtml}
                        </div>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);

            // Initialize Lucide icons in modal
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }

            // Add slide-up animation and spin
            const style = document.createElement('style');
            style.textContent = `
                @keyframes slideUp {
                    from { transform: translateY(100%); opacity: 0; }
                    to { transform: translateY(0); opacity: 1; }
                }
                @keyframes spin {
                    from { transform: rotate(0deg); }
                    to { transform: rotate(360deg); }
                }
            `;
            modal.appendChild(style);

            // Fetch and display performance data
            loadSignalPerformance(symbol);
        }

        // Load signal performance data
        async function loadSignalPerformance(symbol) {
            const container = document.getElementById('performanceSection');
            if (!container) return;

            try {
                const response = await fetch(`/api/dashboard/signal-performance/${symbol}`);
                if (!response.ok) {
                    container.innerHTML = `<div style="text-align: center; color: var(--text-secondary); font-size: 11px;">No signal data available</div>`;
                    return;
                }

                const perf = await response.json();

                // Determine colors
                const pnlColor = perf.pnl_percent >= 0 ? '#10b981' : '#ef4444';
                const statusColors = { green: '#10b981', red: '#ef4444', amber: '#fbbf24' };
                const statusColor = statusColors[perf.status_color] || '#9ca3af';

                // Status display text
                const statusText = {
                    'STOPPED_OUT': ' Stopped Out',
                    'ALL_TARGETS_HIT': ' All Targets Hit!',
                    'TARGET_1_HIT': ' Target 1 Hit',
                    'TARGET_2_HIT': ' Target 2 Hit',
                    'TARGET_3_HIT': ' Target 3 Hit',
                    'IN_PROFIT': ' In Profit',
                    'IN_DRAWDOWN': ' In Drawdown'
                }[perf.status] || perf.status;

                container.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; gap: 12px;">
                        <!-- P&L Display -->
                        <div style="flex: 1;">
                            <div style="font-size: 10px; color: var(--text-secondary); text-transform: uppercase; margin-bottom: 2px;">Performance</div>
                            <div style="font-size: 22px; font-weight: 700; color: ${pnlColor};">
                                ${perf.pnl_percent >= 0 ? '+' : ''}${perf.pnl_percent}%
                            </div>
                            <div style="font-size: 10px; color: var(--text-secondary);">
                                ${perf.signal_type} @ $${perf.entry_price.toFixed(4)}  $${perf.current_price.toFixed(4)}
                            </div>
                        </div>
                        <!-- Status & Targets -->
                        <div style="text-align: right;">
                            <div style="font-size: 12px; font-weight: 600; color: ${statusColor}; margin-bottom: 4px;">
                                ${statusText}
                            </div>
                            <div style="font-size: 10px; color: var(--text-secondary);">
                                Targets: ${perf.targets_hit}/${perf.targets_total}
                            </div>
                            <div style="font-size: 9px; color: var(--text-secondary);">
                                ${perf.signal_age_hours}h ago
                            </div>
                        </div>
                    </div>
                `;
            } catch (error) {
                console.error('Error loading performance:', error);
                container.innerHTML = `<div style="text-align: center; color: var(--text-secondary); font-size: 11px;">Performance unavailable</div>`;
            }
        }

        // Close report modal
        function closeReportModal(event) {
            event.stopPropagation();
            const modal = document.getElementById('reportSelectorModal');
            if (modal) modal.remove();
        }

        // Show toast notification
        function showToast(message, type = 'info') {
            const existingToast = document.querySelector('.toast-notification');
            if (existingToast) existingToast.remove();

            const colors = {
                info: 'rgba(59, 130, 246, 0.9)',
                success: 'rgba(16, 185, 129, 0.9)',
                warning: 'rgba(251, 191, 36, 0.9)',
                error: 'rgba(239, 68, 68, 0.9)'
            };

            const toast = document.createElement('div');
            toast.className = 'toast-notification';
            toast.style.cssText = `
                position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
                background: ${colors[type]}; color: white; padding: 12px 20px;
                border-radius: 8px; font-size: 13px; font-weight: 500;
                z-index: 10000; animation: fadeIn 0.3s ease;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            `;
            toast.textContent = message;
            document.body.appendChild(toast);

            // Auto-remove after 3 seconds
            setTimeout(() => toast.remove(), 3000);
        }

        // Toggle expansion for alerted signal cards (similar to Alpha Pulse)
        function toggleAlertedSignalCard(cardId) {
            const card = document.getElementById(cardId);
            const buttonsPanel = document.getElementById(`${cardId}_buttons`);
            const chevron = document.getElementById(`${cardId}_chevron`);

            if (!buttonsPanel || !card) return;

            const isExpanded = buttonsPanel.style.width && buttonsPanel.style.width !== '0px';

            // Accordion: collapse previously expanded card if different
            if (!isExpanded && currentlyExpandedAlertedSignal && currentlyExpandedAlertedSignal !== cardId) {
                const prevCard = document.getElementById(currentlyExpandedAlertedSignal);
                const prevButtons = document.getElementById(`${currentlyExpandedAlertedSignal}_buttons`);
                const prevChevron = document.getElementById(`${currentlyExpandedAlertedSignal}_chevron`);

                if (prevButtons && prevCard) {
                    // Collapse buttons panel
                    prevButtons.style.width = '0px';
                    prevButtons.style.opacity = '0';
                    if (prevChevron) prevChevron.style.transform = 'rotate(0deg)';
                    setTimeout(() => {
                        prevButtons.style.display = 'none';
                    }, 300);
                }
            }

            if (!isExpanded) {
                // Haptic feedback on expand
                triggerHapticFeedback('light');

                // Show buttons panel (horizontal slide)
                buttonsPanel.style.display = 'block';
                if (chevron) chevron.style.transform = 'rotate(-90deg)';

                setTimeout(() => {
                    buttonsPanel.style.width = '90px';
                    buttonsPanel.style.opacity = '1';

                    // Auto-scroll card into view
                    setTimeout(() => {
                        card.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'nearest' });
                    }, 150);
                }, 10);

                currentlyExpandedAlertedSignal = cardId;

                // Re-initialize lucide icons for the expanded panel
                if (typeof lucide !== 'undefined') {
                    lucide.createIcons();
                }
            } else {
                // Collapse buttons panel
                buttonsPanel.style.width = '0px';
                buttonsPanel.style.opacity = '0';
                if (chevron) chevron.style.transform = 'rotate(0deg)';

                setTimeout(() => {
                    buttonsPanel.style.display = 'none';
                }, 300);

                currentlyExpandedAlertedSignal = null;
            }
        }
        
        // WebSocket connection for real-time updates
        let ws;
        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(`${protocol}//${window.location.host}/ws`);
            
            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                handleRealtimeUpdate(data);
            };
            
            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };
            
            ws.onclose = () => {
                // Reconnect after 5 seconds
                setTimeout(connectWebSocket, 5000);
            };
        }

        function handleRealtimeUpdate(data) {
            // Handle real-time updates based on data type
            if (data.type === 'signal') {
                // Update signals if on signals tab
                if (document.getElementById('signalsTab').classList.contains('active')) {
                    loadSignalsData();
                }
            } else if (data.type === 'price_update' || data.type === 'ticker') {
                // Update symbols if on dashboard tab
                if (document.getElementById('dashboardTab').classList.contains('active')) {
                    fetch('/api/dashboard/symbols')
                        .then(response => response.json())
                        .then(data => updateSymbols(data))
                        .catch(error => console.error('Error updating symbols:', error));
                }
            }
        }

        // Intersection Observer for performance
        const observerOptions = {
            root: null,
            rootMargin: '50px',
            threshold: 0.1
        };

        const intersectionObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    // Load content when it comes into view
                    const element = entry.target;
                    if (element.dataset.lazy === 'true') {
                        // Trigger lazy loading here
                        element.dataset.lazy = 'false';
                    }
                }
            });
        }, observerOptions);

        // ============================================
        // iOS-STYLE HAPTIC FEEDBACK & SWIPE GESTURES
        // ============================================

        // Haptic feedback utility (uses Vibration API)
        // Track user interaction to comply with browser vibration policy
        let userHasInteracted = false;
        document.addEventListener('touchstart', () => { userHasInteracted = true; }, { once: true, passive: true });
        document.addEventListener('click', () => { userHasInteracted = true; }, { once: true });

        const haptic = {
            light: () => {
                if (userHasInteracted && 'vibrate' in navigator) {
                    navigator.vibrate(10);
                }
            },
            medium: () => {
                if (userHasInteracted && 'vibrate' in navigator) {
                    navigator.vibrate(20);
                }
            },
            heavy: () => {
                if (userHasInteracted && 'vibrate' in navigator) {
                    navigator.vibrate([30, 10, 30]);
                }
            },
            success: () => {
                if (userHasInteracted && 'vibrate' in navigator) {
                    navigator.vibrate([10, 50, 20]);
                }
            },
            error: () => {
                if (userHasInteracted && 'vibrate' in navigator) {
                    navigator.vibrate([50, 30, 50, 30, 50]);
                }
            }
        };

        // Add haptic feedback to all interactive elements
        function initHapticFeedback() {
            // Primary interactive elements - standard haptic
            document.querySelectorAll('button, .nav-item, .tab-btn, .tf-btn, .tf-chip, .pressable').forEach(el => {
                el.addEventListener('touchstart', () => haptic.light(), { passive: true });
            });

            // Cards - lighter feedback
            document.querySelectorAll('.mobile-card').forEach(el => {
                el.addEventListener('touchstart', () => {
                    if (userHasInteracted && 'vibrate' in navigator) navigator.vibrate(5);
                }, { passive: true });
            });

            // Switches/toggles - medium feedback for state changes
            document.querySelectorAll('input[type="checkbox"], input[type="radio"], .toggle-switch').forEach(el => {
                el.addEventListener('change', () => haptic.medium(), { passive: true });
            });

            // Links and clickable text
            document.querySelectorAll('a, [role="link"], [onclick]').forEach(el => {
                if (!el.matches('button, .nav-item, .tf-chip, .tf-btn')) {
                    el.addEventListener('touchstart', () => haptic.light(), { passive: true });
                }
            });
        }

        // Initialize confluence scroll hint - hides when scrolled to bottom
        function initConfluenceScrollHint() {
            const scrollContainer = document.getElementById('confluenceScrollContainer');
            const scrollHint = document.getElementById('confluenceScrollHint');

            if (!scrollContainer || !scrollHint) return;

            // Check if content is scrollable and update hint visibility
            function updateScrollHint() {
                const isScrollable = scrollContainer.scrollHeight > scrollContainer.clientHeight;
                const isAtBottom = scrollContainer.scrollTop + scrollContainer.clientHeight >= scrollContainer.scrollHeight - 20;

                if (!isScrollable || isAtBottom) {
                    scrollHint.classList.add('hidden');
                    scrollContainer.classList.add('scrolled-bottom');
                } else {
                    scrollHint.classList.remove('hidden');
                    scrollContainer.classList.remove('scrolled-bottom');
                }
            }

            // Listen to scroll events
            scrollContainer.addEventListener('scroll', updateScrollHint, { passive: true });

            // Initial check (delay to allow content to load)
            setTimeout(updateScrollHint, 500);

            // Re-check after data loads
            const observer = new MutationObserver(() => {
                setTimeout(updateScrollHint, 100);
            });
            observer.observe(scrollContainer, { childList: true, subtree: true });
        }

        /**
         * Initialize horizontal scroll fade indicators
         * Shows gradient fade when content is scrollable left/right
         */
        function initScrollFadeIndicators() {
            // Container IDs that have horizontal scrolling
            const containerIds = ['oiDistributionContainer', 'fundingSpreadsContainer', 'alertFilters'];

            containerIds.forEach(id => {
                const container = document.getElementById(id);
                if (!container) return;

                // Wrap container if not already wrapped
                if (!container.parentElement.classList.contains('scroll-fade-wrapper')) {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'scroll-fade-wrapper';
                    container.parentElement.insertBefore(wrapper, container);
                    wrapper.appendChild(container);
                }

                const wrapper = container.parentElement;

                function updateScrollIndicators() {
                    const canScrollLeft = container.scrollLeft > 5;
                    const canScrollRight = container.scrollLeft < (container.scrollWidth - container.clientWidth - 5);

                    wrapper.classList.toggle('can-scroll-left', canScrollLeft);
                    wrapper.classList.toggle('can-scroll-right', canScrollRight);
                }

                // Listen for scroll events
                container.addEventListener('scroll', updateScrollIndicators, { passive: true });

                // Initial check (delay for content to load)
                setTimeout(updateScrollIndicators, 500);

                // Re-check when content changes
                const observer = new MutationObserver(() => {
                    setTimeout(updateScrollIndicators, 100);
                });
                observer.observe(container, { childList: true, subtree: true });
            });

            console.log('[DEBUG] Scroll fade indicators initialized');
        }


        console.log('[DEBUG] Script executing, about to register DOMContentLoaded');

        /**
         * ============================================
         * BOTTOM NAVIGATION SCROLL CONTROLLER
         * ============================================
         * Handles hide/show behavior based on scroll direction
         * - GPU-accelerated transforms
         * - RequestAnimationFrame throttling
         * - Velocity-based hiding
         * - Accessibility support (ARIA, reduced motion)
         */
        class BottomNavScrollController {
            constructor(navElement, options = {}) {
                this.nav = navElement;
                this.isHidden = false;
                this.lastScrollY = window.scrollY;
                this.lastScrollTime = Date.now();
                this.scrollVelocity = 0;
                this.ticking = false;
                this.isFullscreen = false;

                // Configuration
                this.config = {
                    hideThreshold: options.hideThreshold || 40,        // Pixels before fast-scroll hide
                    showThreshold: options.showThreshold || 10,        // Pixels before show on scroll up
                    velocityThreshold: options.velocityThreshold || 0.15,  // Lower threshold for better touch response
                    forceHideThreshold: options.forceHideThreshold || 120, // Force hide after sustained scroll (no velocity check)
                    transitionDuration: options.transitionDuration || 300
                };

                // State tracking
                this.scrollDelta = 0;
                this.isKeyboardOpen = false;
                this.lastViewportHeight = window.innerHeight;
                this.navHeight = this.nav.offsetHeight;

                // Bind methods
                this.handleScroll = this.handleScroll.bind(this);
                this.update = this.update.bind(this);
                this.handleResize = this.handleResize.bind(this);
                this.handleVisibilityChange = this.handleVisibilityChange.bind(this);

                this.init();
            }

            init() {
                console.log('[BottomNav] Initializing scroll controller');
                this.nav.setAttribute('aria-hidden', 'false');
                this.prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

                window.addEventListener('scroll', this.handleScroll, { passive: true });
                window.addEventListener('resize', this.handleResize);
                document.addEventListener('visibilitychange', this.handleVisibilityChange);

                window.bottomNavController = this;
            }

            handleScroll() {
                if (!this.ticking && !this.isFullscreen) {
                    window.requestAnimationFrame(this.update);
                    this.ticking = true;
                }
            }

            update() {
                const currentScrollY = window.scrollY;
                const currentTime = Date.now();
                const deltaY = currentScrollY - this.lastScrollY;
                const deltaTime = currentTime - this.lastScrollTime;

                this.scrollVelocity = deltaTime > 0 ? Math.abs(deltaY / deltaTime) : 0;
                this.scrollDelta += deltaY;

                // Always show at top of page
                if (currentScrollY <= 0) {
                    if (this.isHidden) this.show();
                    this.resetState();
                    this.ticking = false;
                    return;
                }

                // Don't hide if content shorter than viewport
                const contentHeight = document.documentElement.scrollHeight;
                const viewportHeight = window.innerHeight;
                if (contentHeight <= viewportHeight + this.navHeight) {
                    if (this.isHidden) this.show();
                    this.ticking = false;
                    return;
                }

                // Keep visible when keyboard is open
                if (this.isKeyboardOpen) {
                    if (this.isHidden) this.show();
                    this.ticking = false;
                    return;
                }

                // HIDE: Scrolling down with sufficient delta and velocity
                // Two conditions can trigger hide:
                // 1. Fast scroll: delta > threshold AND velocity > threshold
                // 2. Sustained scroll: delta > forceHideThreshold (catches slow continuous scrolling)
                const shouldHide = !this.isHidden && deltaY > 0 && (
                    (this.scrollDelta > this.config.hideThreshold &&
                     this.scrollVelocity > this.config.velocityThreshold) ||
                    (this.scrollDelta > this.config.forceHideThreshold)
                );
                if (shouldHide) {
                    this.hide();
                }

                // SHOW: Scrolling up with sufficient delta
                if (this.isHidden &&
                    deltaY < 0 &&
                    Math.abs(this.scrollDelta) > this.config.showThreshold) {
                    this.show();
                }

                this.lastScrollY = currentScrollY;
                this.lastScrollTime = currentTime;
                this.ticking = false;
            }

            hide() {
                if (this.isHidden || this.isFullscreen) return;
                this.isHidden = true;
                const translateY = this.navHeight + 20;
                this.nav.style.transform = `translate3d(0, ${translateY}px, 0)`;
                this.nav.setAttribute('aria-hidden', 'true');
                this.nav.style.pointerEvents = 'none';
                this.resetState();
            }

            show() {
                if (!this.isHidden) return;
                this.isHidden = false;
                this.nav.style.transform = 'translate3d(0, 0, 0)';
                this.nav.setAttribute('aria-hidden', 'false');
                this.nav.style.pointerEvents = 'auto';
                this.resetState();
            }

            resetState() {
                this.scrollDelta = 0;
                this.scrollVelocity = 0;
            }

            handleResize() {
                const currentHeight = window.innerHeight;
                const heightDifference = this.lastViewportHeight - currentHeight;

                // Detect keyboard (viewport shrinks >150px)
                if (heightDifference > 150) {
                    this.isKeyboardOpen = true;
                    this.show();
                } else if (heightDifference < -150) {
                    this.isKeyboardOpen = false;
                }

                this.lastViewportHeight = currentHeight;
                this.navHeight = this.nav.offsetHeight;
            }

            handleVisibilityChange() {
                if (!document.hidden && !this.isFullscreen) {
                    this.show();
                }
            }

            // Called by tab switching
            forceShow() {
                if (!this.isFullscreen) this.show();
            }

            // Called when entering fullscreen
            setFullscreen(isFullscreen) {
                this.isFullscreen = isFullscreen;
                if (isFullscreen) {
                    this.isHidden = true;
                }
            }

            destroy() {
                window.removeEventListener('scroll', this.handleScroll);
                window.removeEventListener('resize', this.handleResize);
                document.removeEventListener('visibilitychange', this.handleVisibilityChange);
                this.show();
                delete window.bottomNavController;
            }
        }

        // Initialize on load with performance optimizations
        document.addEventListener('DOMContentLoaded', () => {
            console.log('[DEBUG] DOMContentLoaded fired!');
            try {
                // Use requestIdleCallback for non-critical tasks
                if ('requestIdleCallback' in window) {
                    requestIdleCallback(() => {
                        connectWebSocket();
                    });
                } else {
                    setTimeout(connectWebSocket, 100);
                }

                console.log('[DEBUG] About to call loadDashboardData()');
                loadDashboardData();

                // Fetch real L/S positioning from crypto-perps-tracker API
                fetchMarketLSR();
                // Refresh L/S data every 60 seconds
                setInterval(fetchMarketLSR, 60000);

                // Initialize Double-Tap Quick Actions (Optimization #4)
                initDoubleTapActions();

            // Debounced icon refresh
            const debouncedIconRefresh = debounce(() => {
                if (typeof lucide !== 'undefined') lucide.createIcons();
            }, 100);

            // Optimize mutation observer
            const observer = new MutationObserver(debouncedIconRefresh);
            observer.observe(document.body, {
                childList: true,
                subtree: true,
                attributes: false,
                characterData: false
            });

            // Initialize Zen Mode (hidden easter egg feature)
            initZenMode();

            // Load news ticker (instant from cache, then background refresh)
            loadNewsTicker();
            startNewsRefresh(); // Periodic refresh every 5 minutes
            loadSettings(); // Load user settings including news ticker visibility

            // Initialize iOS-style features
            initHapticFeedback();
            console.log('[DEBUG] iOS features initialized (haptics)');

            // Initialize bottom navigation scroll controller
            const bottomNav = document.querySelector('.bottom-nav');
            if (bottomNav) {
                new BottomNavScrollController(bottomNav, {
                    hideThreshold: 40,         // Fast scroll trigger
                    showThreshold: 10,         // Quick reveal on scroll up
                    velocityThreshold: 0.15,   // Lowered for better touch response
                    forceHideThreshold: 120    // Guaranteed hide after sustained scroll
                });
                console.log('[DEBUG] Bottom nav scroll controller initialized');
            }

            // Initialize Performance Tracker settings (timeframe, auto-refresh)
            initPerformanceSettings();
            if (perfAutoRefreshEnabled) {
                startPerfAutoRefresh();
            }

            // Initialize confluence scroll indicator
            initConfluenceScrollHint();

            // Initialize horizontal scroll fade indicators
            initScrollFadeIndicators();

            // Initialize alert notification system
            initNotifications();
            // Load alerts on startup to check for unread (without switching tabs)
            loadAlertsData();

            console.log('[DEBUG] DOMContentLoaded handler completed successfully');
            } catch (e) {
                console.error('[DEBUG] ERROR in DOMContentLoaded:', e);
                const errDiv = document.createElement('div');
                errDiv.style.cssText = 'position:fixed;top:0;left:0;right:0;background:red;color:white;padding:10px;z-index:9999;';
                errDiv.textContent = 'Init Error: ' + e.message;
                document.body.prepend(errDiv);
            }
        });

        // Handle visibility change
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) {
                refreshData();
            }
        });

        // Service Worker for offline support
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/sw.js').catch(() => {
                console.log('Service Worker registration failed');
            });
        }

        /* ============================================
           ZEN MODE - Hidden Easter Egg Feature
           Double-tap the VIRTUOSO title to toggle header buttons
           State persists across page loads via localStorage
           ============================================ */

        function initZenMode() {
            const appTitle = document.getElementById('appTitle');
            const headerActions = document.getElementById('headerActions');

            if (!appTitle || !headerActions) {
                console.error('Zen Mode: Required elements not found');
                return;
            }

            let tapCount = 0;
            let tapTimeout = null;
            const doubleTapDelay = 400; // ms window for double-tap
            const isTouchDevice = 'ontouchstart' in window;

            // Restore zen mode state from localStorage
            const isZenMode = localStorage.getItem('zenMode') === 'true';
            const priceTicker = document.getElementById('priceTicker');
            const newsTicker = document.getElementById('newsTicker');
            if (isZenMode) {
                headerActions.classList.add('zen-hidden');
                if (priceTicker) priceTicker.classList.add('zen-hidden');
                if (newsTicker) newsTicker.classList.add('zen-hidden');
                console.log('Zen Mode: Restored hidden state');
            }

            // Unified tap handler
            function handleTap(e) {
                // On touch devices, ignore click events (they fire after touchend)
                if (e.type === 'click' && isTouchDevice) return;

                tapCount++;
                console.log('Zen tap #' + tapCount);

                if (tapCount === 1) {
                    // First tap - wait for second
                    tapTimeout = setTimeout(() => {
                        tapCount = 0;
                    }, doubleTapDelay);
                } else if (tapCount >= 2) {
                    // Double-tap!
                    clearTimeout(tapTimeout);
                    tapCount = 0;
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Zen Mode: Double-tap triggered!');
                    toggleZenMode();
                }
            }

            // Attach appropriate listener based on device type
            if (isTouchDevice) {
                appTitle.addEventListener('touchend', handleTap, { passive: false });
            } else {
                appTitle.addEventListener('click', handleTap);
            }

            console.log('Zen Mode ready. Double-tap VIRTUOSO to toggle.');
        }

        function toggleZenMode() {
            const appTitle = document.getElementById('appTitle');
            const headerActions = document.getElementById('headerActions');
            const priceTicker = document.getElementById('priceTicker');
            const newsTicker = document.getElementById('newsTicker');

            // Toggle the hidden state
            const isHidden = headerActions.classList.contains('zen-hidden');

            if (isHidden) {
                // Show actions and tickers
                headerActions.classList.remove('zen-hidden');
                if (priceTicker) priceTicker.classList.remove('zen-hidden');
                if (newsTicker) newsTicker.classList.remove('zen-hidden');
                localStorage.setItem('zenMode', 'false');
            } else {
                // Hide actions and tickers
                headerActions.classList.add('zen-hidden');
                if (priceTicker) priceTicker.classList.add('zen-hidden');
                if (newsTicker) newsTicker.classList.add('zen-hidden');
                localStorage.setItem('zenMode', 'true');
            }

            // Visual feedback: amber glow pulse
            appTitle.classList.remove('zen-tapped');
            // Force reflow to restart animation
            void appTitle.offsetWidth;
            appTitle.classList.add('zen-tapped');

            // Remove animation class after completion
            setTimeout(() => {
                appTitle.classList.remove('zen-tapped');
            }, 600);

            console.log(`Zen Mode ${isHidden ? 'disabled' : 'enabled'} - header actions ${isHidden ? 'shown' : 'hidden'}`);
        }

        // Settings Management
        let autoRefreshInterval = null;
        let userSettings = {
            refreshRate: 60000,
            defaultSort: 'score',
            symbolsLimit: 20,
            minConfluence: 70,
            soundAlerts: false,
            showNewsTicker: true,
            visibleCards: {
                marketOverview: true,
                topMovers: true
            }
        };

        function toggleSettings() {
            const panel = document.getElementById('settingsPanel');
            const overlay = document.getElementById('settingsOverlay');
            const isOpen = panel.style.right === '0px';
            
            if (isOpen) {
                panel.style.right = '-100%';
                overlay.style.opacity = '0';
                overlay.style.visibility = 'hidden';
            } else {
                panel.style.right = '0px';
                overlay.style.opacity = '1';
                overlay.style.visibility = 'visible';
                if (typeof lucide !== 'undefined') lucide.createIcons();
            }
        }

        function updateRefreshRate() {
            const rate = parseInt(document.getElementById('refreshRate').value);
            userSettings.refreshRate = rate;
            saveSettings();
            setupAutoRefresh();
        }

        function updateDefaultSort() {
            const sort = document.getElementById('defaultSort').value;
            userSettings.defaultSort = sort;
            
            const sortSelector = document.getElementById('sortSelector');
            if (sortSelector) {
                sortSelector.value = sort;
            }
            
            sortSymbols();
            saveSettings();
        }

        function updateSymbolsLimit() {
            const limit = parseInt(document.getElementById('symbolsLimit').value);
            userSettings.symbolsLimit = limit;
            saveSettings();
            loadDashboardData();
        }

        function updateMinConfluence() {
            const min = parseInt(document.getElementById('minConfluence').value);
            userSettings.minConfluence = min;
            saveSettings();
        }

        function updateSoundAlerts() {
            const enabled = document.getElementById('soundAlerts').checked;
            userSettings.soundAlerts = enabled;
            saveSettings();
        }

        function toggleCard(cardType) {
            const checkbox = document.getElementById(`show${cardType.charAt(0).toUpperCase() + cardType.slice(1)}`);
            userSettings.visibleCards[cardType] = checkbox.checked;
            saveSettings();
            applyCardVisibility();
        }

        function applyCardVisibility() {
            const cards = document.querySelectorAll('.mobile-card');
            cards.forEach(card => {
                const title = card.querySelector('.card-title')?.textContent;
                if (title?.includes('Market Overview') && !userSettings.visibleCards.marketOverview) {
                    card.style.display = 'none';
                } else if (title?.includes('Top Movers') && !userSettings.visibleCards.topMovers) {
                    card.style.display = 'none';
                } else {
                    card.style.display = 'block';
                }
            });
        }

        // News Ticker Functions
        function toggleNewsTicker() {
            const checkbox = document.getElementById('showNewsTicker');
            userSettings.showNewsTicker = checkbox.checked;
            saveSettings();
            applyNewsTickerVisibility();
        }

        function applyNewsTickerVisibility() {
            const newsTicker = document.getElementById('newsTicker');
            if (!newsTicker) return;

            // Don't show if in zen mode
            const isZenMode = localStorage.getItem('zenMode') === 'true';
            if (isZenMode) {
                newsTicker.style.display = 'none';
                return;
            }

            // Apply user setting
            if (userSettings.showNewsTicker) {
                newsTicker.style.display = 'flex';
            } else {
                newsTicker.style.display = 'none';
            }
        }

        // News ticker cache configuration
        const NEWS_CACHE_KEY = 'virtuoso_news_cache';
        const NEWS_REFRESH_INTERVAL = 300000; // 5 minutes
        let newsRefreshTimer = null;

        function getNewsFromCache() {
            try {
                const cached = localStorage.getItem(NEWS_CACHE_KEY);
                if (cached) {
                    const { news } = JSON.parse(cached);
                    return news;
                }
            } catch (e) {}
            return null;
        }

        function saveNewsToCache(news) {
            try {
                localStorage.setItem(NEWS_CACHE_KEY, JSON.stringify({
                    news: news,
                    timestamp: Date.now()
                }));
            } catch (e) {}
        }

        function renderNewsItems(newsTrack, news) {
            const newsItems = news.slice(0, 20).map(item => {
                const timeAgo = getTimeAgo(item.timestamp * 1000);
                return `
                    <div class="news-item">
                        <a href="${item.link}" target="_blank" rel="noopener">${item.title}</a>
                        <span class="news-source">${timeAgo}</span>
                    </div>
                    <span class="news-separator"></span>
                `;
            }).join('');
            // Duplicate for seamless scroll
            newsTrack.innerHTML = newsItems + newsItems;

            // Adjust animation speed based on content width (slower for reading)
            const contentWidth = newsTrack.scrollWidth / 2;
            const speed = Math.max(15, contentWidth / 60); // ~60px per second
            newsTrack.style.animationDuration = `${speed}s`;
        }

        async function loadNewsTicker() {
            const newsTrack = document.getElementById('newsTrack');
            if (!newsTrack) return;

            // 1. INSTANT: Show cached news immediately (no waiting)
            const cached = getNewsFromCache();
            if (cached && cached.length > 0) {
                renderNewsItems(newsTrack, cached);
            } else {
                // First visit - show loading state
                newsTrack.innerHTML = '<div class="news-item" style="opacity: 0.6;">Loading news...</div>';
            }

            // 2. BACKGROUND: Fetch fresh news without blocking
            try {
                const response = await fetch('/api/dashboard/news');
                const data = await response.json();

                if (data.news && data.news.length > 0) {
                    // Save to cache for next page load
                    saveNewsToCache(data.news);
                    // Update display with fresh data
                    renderNewsItems(newsTrack, data.news);
                }
            } catch (error) {
                console.error('Error loading news:', error);
                // Only show error if no cached data
                if (!cached || cached.length === 0) {
                    newsTrack.innerHTML = '<div class="news-item">Unable to load news</div>';
                }
            }
        }

        function startNewsRefresh() {
            // Clear any existing timer
            if (newsRefreshTimer) clearInterval(newsRefreshTimer);
            // Refresh news every 5 minutes
            newsRefreshTimer = setInterval(() => loadNewsTicker(), NEWS_REFRESH_INTERVAL);
        }

        function getTimeAgo(timestamp) {
            const now = Date.now();
            const diff = now - timestamp;
            const minutes = Math.floor(diff / 60000);
            const hours = Math.floor(diff / 3600000);
            const days = Math.floor(diff / 86400000);

            if (minutes < 1) return 'just now';
            if (minutes < 60) return `${minutes}m ago`;
            if (hours < 24) return `${hours}h ago`;
            return `${days}d ago`;
        }

        function resetSettings() {
            userSettings = {
                refreshRate: 60000,
                defaultSort: 'score',
                symbolsLimit: 20,
                minConfluence: 70,
                soundAlerts: false,
                showNewsTicker: true,
                visibleCards: {
                    marketOverview: true,
                    topMovers: true
                }
            };
            loadSettingsUI();
            saveSettings();
            setupAutoRefresh();
            applyCardVisibility();
            applyNewsTickerVisibility();
        }

        function exportSettings() {
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(userSettings, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "virtuoso-settings.json");
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        }

        function saveSettings() {
            localStorage.setItem('virtuoso-settings', JSON.stringify(userSettings));
        }

        function loadSettings() {
            const saved = localStorage.getItem('virtuoso-settings');
            if (saved) {
                userSettings = { ...userSettings, ...JSON.parse(saved) };
            }
            loadSettingsUI();
        }

        function loadSettingsUI() {
            // Settings panel elements (may not exist if settings modal not opened yet)
            const refreshRate = document.getElementById('refreshRate');
            const defaultSort = document.getElementById('defaultSort');
            const symbolsLimit = document.getElementById('symbolsLimit');
            const minConfluence = document.getElementById('minConfluence');
            const soundAlerts = document.getElementById('soundAlerts');
            const showNewsTicker = document.getElementById('showNewsTicker');
            const showMarketOverview = document.getElementById('showMarketOverview');
            const showTopMovers = document.getElementById('showTopMovers');
            
            if (refreshRate) refreshRate.value = userSettings.refreshRate;
            if (defaultSort) defaultSort.value = userSettings.defaultSort;
            if (symbolsLimit) symbolsLimit.value = userSettings.symbolsLimit;
            if (minConfluence) minConfluence.value = userSettings.minConfluence;
            if (soundAlerts) soundAlerts.checked = userSettings.soundAlerts;
            if (showNewsTicker) showNewsTicker.checked = userSettings.showNewsTicker;
            if (showMarketOverview) showMarketOverview.checked = userSettings.visibleCards.marketOverview;
            if (showTopMovers) showTopMovers.checked = userSettings.visibleCards.topMovers;

            // Sort selector in Beta Analysis section (may not be loaded yet if tab not active)
            const sortSelector = document.getElementById('sortSelector');
            if (sortSelector) {
                sortSelector.value = userSettings.defaultSort;
            }

            // Apply news ticker visibility
            applyNewsTickerVisibility();
        }

        function setupAutoRefresh() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
            }
            
            if (userSettings.refreshRate > 0) {
                autoRefreshInterval = setInterval(() => {
                    const activeTab = document.querySelector('.nav-item.active');
                    if (activeTab) {
                        const onclick = activeTab.getAttribute('onclick');
                        const tabName = onclick.match(/'([^']+)'/)[1];
                        loadTabData(tabName);
                    }
                }, userSettings.refreshRate);
            }
        }
    </script>

    <!-- Alert Quick Actions Bottom Sheet -->
    <div class="alert-sheet-overlay" id="alertSheetOverlay" onclick="closeAlertSheet()"></div>
    <div class="alert-bottom-sheet" id="alertBottomSheet">
        <div class="sheet-handle"></div>
        <div class="sheet-header">
            <div class="sheet-header-icon">
                <i data-lucide="bell" style="width: 20px; height: 20px;"></i>
            </div>
            <div class="sheet-header-text">
                <h3 id="sheetSymbolName">BTCUSDT</h3>
                <div class="sheet-subtitle">
                    <span id="sheetDirection">LONG</span>
                    <span class="sheet-score-badge bullish" id="sheetScoreBadge">Score: 72</span>
                </div>
            </div>
        </div>
        <div class="sheet-options">
            <!-- View Recent Alerts -->
            <div class="sheet-option" onclick="viewSymbolAlerts()">
                <div class="sheet-option-icon amber">
                    <i data-lucide="list" style="width: 18px; height: 18px;"></i>
                </div>
                <div class="sheet-option-text">
                    <h4>View Recent Alerts</h4>
                    <p>See all alerts for this symbol</p>
                </div>
                <div class="sheet-option-value">
                    <span class="count-badge" id="sheetAlertCount">0</span>
                    <i data-lucide="chevron-right" style="width: 16px; height: 16px;"></i>
                </div>
            </div>

            <div class="sheet-divider"></div>
            <div class="sheet-section-label">Alert Settings</div>

            <!-- Score Threshold Config -->
            <div class="threshold-config">
                <div class="threshold-config-header">
                    <h5>
                        <i data-lucide="zap" style="width: 14px; height: 14px; color: var(--neon-amber); vertical-align: middle;"></i>
                        Alert when score reaches
                    </h5>
                    <span class="threshold-value-display" id="thresholdDisplay"> 75</span>
                </div>
                <div class="threshold-slider-container">
                    <input type="range" id="thresholdSlider" min="50" max="95" value="75" oninput="updateThresholdDisplay(this.value)">
                </div>
                <div class="threshold-range-labels">
                    <span>50 (Neutral)</span>
                    <span>95 (Strong)</span>
                </div>
            </div>

            <!-- Alert on LONG Signal -->
            <div class="sheet-option" onclick="toggleAlertOption('long')">
                <div class="sheet-option-icon green">
                    <i data-lucide="trending-up" style="width: 18px; height: 18px;"></i>
                </div>
                <div class="sheet-option-text">
                    <h4>Alert on LONG Signal</h4>
                    <p>Notify when bullish confluence detected</p>
                </div>
                <div class="sheet-option-toggle active" id="alertLongToggle">
                    <i data-lucide="check" style="width: 12px; height: 12px;"></i>
                </div>
            </div>

            <!-- Alert on SHORT Signal -->
            <div class="sheet-option" onclick="toggleAlertOption('short')">
                <div class="sheet-option-icon red">
                    <i data-lucide="trending-down" style="width: 18px; height: 18px;"></i>
                </div>
                <div class="sheet-option-text">
                    <h4>Alert on SHORT Signal</h4>
                    <p>Notify when bearish confluence detected</p>
                </div>
                <div class="sheet-option-toggle" id="alertShortToggle">
                    <i data-lucide="check" style="width: 12px; height: 12px;"></i>
                </div>
            </div>
        </div>

        <div class="sheet-actions">
            <button class="sheet-btn secondary" onclick="closeAlertSheet()">Cancel</button>
            <button class="sheet-btn primary" onclick="saveAlertSettings()">Save Settings</button>
        </div>
    </div>

    <!-- Cache Status Indicator removed -->
        
</body>
</html>
