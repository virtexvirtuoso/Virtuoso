<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Virtuoso Mobile Dashboard</title>

    <!-- Access Control - Check for valid access cookie -->
    <script>
        (function() {
            // Check if we're on virtuosocrypto.com domain (production)
            if (window.location.hostname === 'virtuosocrypto.com' || window.location.hostname === 'www.virtuosocrypto.com') {
                // Check for mobile_access cookie
                function getCookie(name) {
                    const value = `; ${document.cookie}`;
                    const parts = value.split(`; ${name}=`);
                    if (parts.length === 2) return parts.pop().split(';').shift();
                    return null;
                }

                const accessToken = getCookie('mobile_access');

                if (!accessToken) {
                    // No access token, redirect to signin
                    console.log('[ACCESS] No mobile_access cookie found, redirecting to signin');
                    window.location.replace('/mobile/signin');
                } else {
                    console.log('[ACCESS] Valid access token found');
                }
            } else {
                // Local development - skip auth check
                console.log('[ACCESS] Development mode - auth check skipped');
            }
        })();
    </script>
    <meta name="description" content="Mobile-optimized cryptocurrency trading dashboard">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Virtuoso">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="Virtuoso">
    <meta name="theme-color" content="#0a0a0a">
    
    <!-- PWA Manifest for Android -->
    <link rel="manifest" href="/static/manifest.json">
    
    <!-- Custom Favicon with Amber Trending-Up Icon -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8IS0tIERhcmsgYmFja2dyb3VuZCBtYXRjaGluZyBkYXNoYm9hcmQgdGhlbWUgLS0+CiAgPHJlY3Qgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0IiByeD0iNCIgZmlsbD0iIzBhMGEwYSIvPgogIAogIDwhLS0gQW1iZXIgdHJlbmRpbmctdXAgaWNvbiAtLT4KICA8cGF0aCBkPSJtMyAxNyA2LTYgNCA0IDgtOCIgc3Ryb2tlPSIjZmJiZjI0IiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPgogIDxwYXRoIGQ9Im0yMSA3LTQgNFY3aDR6IiBmaWxsPSIjZmJiZjI0IiBzdHJva2U9IiNmYmJmMjQiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+Cjwvc3ZnPg==">
    
    <!-- Apple Touch Icons for iOS Home Screen -->
    <link rel="apple-touch-icon" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgwIiBoZWlnaHQ9IjE4MCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogIDxyZWN0IHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgcng9IjQiIGZpbGw9IiMwYTBhMGEiLz4KICA8cGF0aCBkPSJtMyAxNyA2LTYgNCA0IDgtOCIgc3Ryb2tlPSIjZmJiZjI0IiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPgogIDxwYXRoIGQ9Im0yMSA3LTQgNFY3aDR6IiBmaWxsPSIjZmJiZjI0IiBzdHJva2U9IiNmYmJmMjQiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+Cjwvc3ZnPg==">
    <link rel="apple-touch-icon" sizes="152x152" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUyIiBoZWlnaHQ9IjE1MiIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogIDxyZWN0IHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgcng9IjQiIGZpbGw9IiMwYTBhMGEiLz4KICA8cGF0aCBkPSJtMyAxNyA2LTYgNCA0IDgtOCIgc3Ryb2tlPSIjZmJiZjI0IiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPgogIDxwYXRoIGQ9Im0yMSA3LTQgNFY3aDR6IiBmaWxsPSIjZmJiZjI0IiBzdHJva2U9IiNmYmJmMjQiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+Cjwvc3ZnPg==">
    <link rel="apple-touch-icon" sizes="180x180" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgwIiBoZWlnaHQ9IjE4MCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogIDxyZWN0IHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgcng9IjQiIGZpbGw9IiMwYTBhMGEiLz4KICA8cGF0aCBkPSJtMyAxNyA2LTYgNCA0IDgtOCIgc3Ryb2tlPSIjZmJiZjI0IiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPgogIDxwYXRoIGQ9Im0yMSA3LTQgNFY3aDR6IiBmaWxsPSIjZmJiZjI0IiBzdHJva2U9IiNmYmJmMjQiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+Cjwvc3ZnPg==">
    
    <!-- DNS Prefetch & Preconnect for faster resource loading -->
    <link rel="dns-prefetch" href="//fonts.googleapis.com">
    <link rel="dns-prefetch" href="//fonts.gstatic.com">

    <!-- Brand Fonts - with fallback for blocked networks -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;600;700&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Fallback fonts if Google Fonts is blocked */
        @font-face {
            font-family: 'Inter';
            font-style: normal;
            font-weight: 300 700;
            src: local('Inter'), local('Segoe UI'), local('Roboto'), local('Helvetica Neue');
        }
        @font-face {
            font-family: 'IBM Plex Mono';
            font-style: normal;
            font-weight: 400 700;
            src: local('IBM Plex Mono'), local('SF Mono'), local('Consolas'), local('Monaco');
        }
    </style>

    <!-- Preload critical JavaScript for parallel download -->
    <link rel="preload" href="/static/js/lightweight-charts.min.js" as="script">

    <!-- Self-hosted JS libraries for reliability -->
    <script src="/static/js/lucide.min.js" defer></script>
    <script src="/static/js/lightweight-charts.min.js"></script>

    <style>
        /* Virtuoso Brand Mobile Dashboard v2 */
        :root {
            /* Brand Colors from style.html */
            --neon-amber: #fbbf24;
            --neon-cyan: #06B6D4;
            --neon-red: #ff0066;
            
            /* Dark Backgrounds */
            --bg-primary: #0a0a0a;
            --bg-secondary: #111111;
            --bg-panel: #1a1a1a;
            
            /* Borders */
            --border-light: #222222;
            --border-glow: rgba(251, 191, 36, 0.3);
            
            /* Text */
            --text-primary: #e0e0e0;
            --text-secondary: #9ca3af;
            --text-accent: #fbbf24;
            
            /* Semantic Colors */
            --accent-positive: #10b981;
            --accent-negative: #ef4444;
            --accent-warning: #f59e0b;
            --accent-primary: #fbbf24;  /* Primary action color (amber) */
            
            /* Layout */
            --mobile-header-height: 70px;
            --mobile-nav-height: 64px;  /* Compact glassmorphism nav */
            --safe-area-top: env(safe-area-inset-top);
            --safe-area-bottom: env(safe-area-inset-bottom);
            --content-padding: 20px;
            --card-gap: 17px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            /* Disable text selection for app-like feel */
            -webkit-user-select: none;
            user-select: none;
        }

        /* Allow text selection in specific areas */
        .selectable, input, textarea {
            -webkit-user-select: text;
            user-select: text;
        }

        /* iOS Spring Animation Timing */
        :root {
            --ios-spring: cubic-bezier(0.34, 1.56, 0.64, 1);
            --ios-ease: cubic-bezier(0.25, 0.1, 0.25, 1);
            --ios-bounce: cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        /* iOS-style Press Effect for Interactive Elements */
        .pressable, button, .nav-item, .mobile-card, .tab-btn, .tf-btn {
            transition: transform 0.15s var(--ios-spring), opacity 0.15s ease;
            cursor: pointer;
        }

        .pressable:active, button:active, .nav-item:active, .tab-btn:active, .tf-btn:active {
            transform: scale(0.97);
            opacity: 0.9;
        }

        /* Card press effect - subtle */
        .mobile-card:active {
            transform: scale(0.99);
        }

        /* Elastic Overscroll for iOS feel */
        .main-content, .tab-content {
            overscroll-behavior-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        /* Minimum 44px touch targets (Apple HIG) */
        button, .nav-item, .tab-btn, .pressable {
            min-height: 44px;
            min-width: 44px;
        }

        /* Skeleton Loading Animation */
        @keyframes shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }

        .skeleton {
            background: linear-gradient(90deg,
                var(--bg-panel) 25%,
                rgba(255,255,255,0.08) 50%,
                var(--bg-panel) 75%
            );
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite ease-in-out;
            border-radius: 6px;
        }

        .skeleton-card {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: var(--bg-secondary);
            border-radius: 8px;
            margin-bottom: 8px;
        }

        .skeleton-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
        }

        .skeleton-text {
            height: 14px;
            flex: 1;
        }

        .skeleton-text-sm {
            height: 10px;
            width: 60%;
        }

        .skeleton-chart {
            height: 200px;
            width: 100%;
        }

        .skeleton-metric {
            height: 32px;
            width: 80px;
        }
        
        /* Hardware acceleration for smooth scrolling */
        html {
            -webkit-overflow-scrolling: touch;
        }
        
        /* Optimize font rendering */
        html, body {
            text-rendering: optimizeSpeed;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Inter', 'Segoe UI', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.5;
            min-height: 100vh;
            overflow-x: hidden;
            padding-top: var(--safe-area-top);
            padding-bottom: var(--safe-area-bottom);
            -webkit-font-smoothing: antialiased;
        }
        
        /* Monospace typography for data */
        .font-mono,
        .symbol-name,
        .score-value,
        .card-badge,
        .app-title,
        .signal-score,
        .metric-value {
            font-family: 'IBM Plex Mono', monospace;
        }

        /* Mobile Header with Glassmorphism */
        .mobile-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: calc(var(--mobile-header-height) + var(--safe-area-top));
            background: linear-gradient(
                180deg,
                rgba(10, 10, 12, 0.55) 0%,
                rgba(20, 20, 25, 0.45) 100%
            );
            backdrop-filter: blur(24px) saturate(180%);
            -webkit-backdrop-filter: blur(24px) saturate(180%);
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            display: flex;
            align-items: center;
            padding: 0 16px;
            padding-top: var(--safe-area-top);
            z-index: 1001;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.4);
        }

        /* Subtle bottom highlight for depth */
        .mobile-header::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(
                90deg,
                transparent 0%,
                rgba(255, 255, 255, 0.1) 20%,
                rgba(251, 191, 36, 0.12) 50%,
                rgba(255, 255, 255, 0.1) 80%,
                transparent 100%
            );
            pointer-events: none;
        }

        /* Price Ticker Bar - Glass Effect */
        .price-ticker {
            position: fixed;
            top: calc(var(--mobile-header-height) + var(--safe-area-top));
            left: 0;
            right: 0;
            height: 28px;
            background: rgba(15, 15, 18, 0.4);
            backdrop-filter: blur(20px) saturate(150%);
            -webkit-backdrop-filter: blur(20px) saturate(150%);
            border-bottom: 1px solid rgba(255, 255, 255, 0.06);
            z-index: 999;
            overflow: hidden;
            display: flex;
            align-items: center;
        }

        .ticker-track {
            display: flex;
            animation: ticker-scroll 30s linear infinite;
            will-change: transform;
        }

        .ticker-track:hover {
            animation-play-state: paused;
        }

        @keyframes ticker-scroll {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }

        .ticker-item {
            display: flex;
            align-items: center;
            padding: 0 16px;
            white-space: nowrap;
            font-size: 11px;
            font-family: 'SF Mono', 'Fira Code', monospace;
        }

        .ticker-symbol {
            color: rgba(255, 255, 255, 0.7);
            font-weight: 600;
            margin-right: 6px;
        }

        .ticker-price {
            color: rgba(255, 255, 255, 0.5);
            margin-right: 4px;
        }

        .ticker-change {
            font-weight: 500;
            font-size: 10px;
        }

        .ticker-change.positive {
            color: var(--accent-positive);
        }

        .ticker-change.negative {
            color: var(--accent-negative);
        }

        .ticker-separator {
            color: rgba(255, 255, 255, 0.15);
            margin: 0 4px;
        }

        /* News Ticker Bar - Glass Effect */
        .news-ticker {
            position: fixed;
            top: calc(var(--mobile-header-height) + var(--safe-area-top) + 28px);
            left: 0;
            right: 0;
            height: 24px;
            background: rgba(12, 12, 15, 0.35);
            backdrop-filter: blur(16px) saturate(140%);
            -webkit-backdrop-filter: blur(16px) saturate(140%);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            overflow: hidden;
            z-index: 89;
            display: flex;
            align-items: center;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        .news-ticker.zen-hidden {
            transform: translateY(-100%);
            opacity: 0;
            pointer-events: none;
        }

        .news-ticker:not(.zen-hidden) {
            transform: translateY(0);
            opacity: 1;
        }

        .news-ticker-label {
            background: var(--neon-amber);
            color: var(--bg-primary);
            font-size: 9px;
            font-weight: 700;
            padding: 3px 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            flex-shrink: 0;
            position: relative;
            z-index: 3;
        }

        .news-track {
            display: flex;
            animation: news-scroll 120s linear infinite;
            will-change: transform;
            position: relative;
            z-index: 1;
        }

        .news-track:hover {
            animation-play-state: paused;
        }

        @keyframes news-scroll {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }

        .news-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 0 16px;
            font-size: 11px;
            white-space: nowrap;
            color: var(--text-secondary);
        }

        .news-item a {
            color: var(--text-secondary);
            text-decoration: none;
            transition: color 0.2s ease;
        }

        .news-item a:hover {
            color: var(--neon-amber);
        }

        .news-source {
            color: var(--text-muted);
            font-size: 9px;
            opacity: 0.7;
        }

        .news-separator {
            color: rgba(255, 255, 255, 0.15);
            margin: 0 4px;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }

        .app-title {
            font-size: 22px;
            font-weight: 700;
            color: var(--neon-amber);
            letter-spacing: 1.5px;
            text-shadow: 0 0 10px rgba(251, 191, 36, 0.3);
        }

        .header-actions {
            display: flex;
            gap: 16px;
        }

        .header-btn {
            background: transparent;
            border: 1px solid transparent;
            color: var(--text-primary);
            padding: 12px;
            cursor: pointer;
            border-radius: 12px;
            transition: all 0.3s ease;
            min-width: 44px;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .header-btn:hover {
            border-color: var(--neon-amber);
            box-shadow: 0 0 15px rgba(251, 191, 36, 0.2);
        }

        .header-btn:active {
            background: rgba(251, 191, 36, 0.1);
            box-shadow: 0 0 20px rgba(251, 191, 36, 0.3), inset 0 0 10px rgba(251, 191, 36, 0.1);
        }

        /* Glassmorphism Bottom Navigation - Edge-to-edge for iOS */
        .bottom-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: auto;
            background: linear-gradient(
                180deg,
                rgba(35, 35, 40, 0.95) 0%,
                rgba(25, 25, 30, 0.98) 50%,
                rgba(10, 10, 10, 1) 100%
            );
            backdrop-filter: blur(24px) saturate(180%);
            -webkit-backdrop-filter: blur(24px) saturate(180%);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px 12px;
            /* Safe area padding - critical for iOS home indicator */
            padding-bottom: calc(12px + env(safe-area-inset-bottom, 0px));
            z-index: 1000;
            box-shadow:
                0 -4px 20px rgba(0, 0, 0, 0.4),
                0 0 0 1px rgba(255, 255, 255, 0.05) inset,
                0 1px 0 rgba(255, 255, 255, 0.12) inset;
            /* GPU compositing fixes for scroll distortion */
            -webkit-transform: translate3d(0, 0, 0);
            transform: translate3d(0, 0, 0);
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            will-change: transform;
            isolation: isolate;
        }

        /* Subtle top highlight for depth */
        .bottom-nav::before {
            content: '';
            position: absolute;
            top: 0;
            left: 24px;
            right: 24px;
            height: 1px;
            background: linear-gradient(90deg,
                transparent 0%,
                rgba(255, 255, 255, 0.15) 30%,
                rgba(255, 255, 255, 0.2) 50%,
                rgba(255, 255, 255, 0.15) 70%,
                transparent 100%
            );
            border-radius: 1px;
        }

        .nav-item {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 8px 6px;
            cursor: pointer;
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            border: none;
            background: transparent;
            color: rgba(255, 255, 255, 0.45);
            text-decoration: none;
            position: relative;
            -webkit-tap-highlight-color: transparent;
            border-radius: 14px;
            margin: 0 3px;
            min-height: 44px;
        }

        .nav-item:hover {
            color: rgba(255, 255, 255, 0.85);
            background: rgba(255, 255, 255, 0.08);
        }

        .nav-item.active {
            color: #fff;
            background: linear-gradient(
                180deg,
                rgba(251, 191, 36, 0.22) 0%,
                rgba(251, 191, 36, 0.12) 100%
            );
            box-shadow:
                0 0 24px rgba(251, 191, 36, 0.2),
                0 0 0 1px rgba(251, 191, 36, 0.25) inset;
        }


        .nav-item:active {
            background: rgba(251, 191, 36, 0.15);
            transform: scale(0.92);
        }

        /* Notification Badge - positioned top-right of icon */
        .notification-badge {
            position: absolute;
            top: 2px;
            right: 50%;
            transform: translateX(20px);
            min-width: 16px;
            height: 16px;
            background: #ef4444;
            border-radius: 8px;
            font-size: 10px;
            font-weight: 700;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            animation: badgePulse 2s ease-in-out infinite;
            z-index: 10;
        }

        .notification-badge.hidden {
            display: none;
        }

        /* Fullscreen Chart Mode - Show only chart with minimal header */
        .fullscreen-chart {
            position: fixed !important;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100% !important;
            height: 100vh !important;
            margin: 0 !important;
            border-radius: 0 !important;
            z-index: 9999;
            overflow: hidden; /* Prevent scrolling to other content */
            background: var(--bg-primary);
        }

        .fullscreen-chart .card-header {
            position: sticky;
            top: 0;
            background: var(--bg-primary);
            z-index: 10;
            padding: 12px 16px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        /* Hide all sibling cards when one is fullscreen */
        .fullscreen-chart ~ .mobile-card {
            display: none !important;
        }

        /* Portrait Mode (height > width) - header + compact chips */
        @media (orientation: portrait) {
            .fullscreen-chart #performanceChart {
                height: calc(100vh - 120px) !important; /* Header (60px) + Chips (60px) */
                min-height: 300px;
            }
        }

        /* Landscape Mode (width > height) - header + compact chips */
        @media (orientation: landscape) {
            .fullscreen-chart #performanceChart {
                height: calc(100vh - 100px) !important; /* Header (60px) + Chips (40px) */
                min-height: 200px;
            }

            /* Make timeframe controls more compact in landscape */
            .fullscreen-chart #timeframeSelector {
                grid-template-columns: repeat(7, 1fr) !important;
            }

            .fullscreen-chart #timeframeSelector button {
                padding: 6px 8px !important;
                font-size: 10px !important;
                min-height: 36px !important;
            }

            /* Single row for auto-refresh in landscape */
            .fullscreen-chart .card-header {
                padding: 8px 12px;
            }
        }

        @keyframes badgePulse {
            0% { transform: translateX(20px) scale3d(1, 1, 1); }
            10% { transform: translateX(20px) scale3d(1.02, 1.02, 1); }
            20% { transform: translateX(20px) scale3d(1.04, 1.04, 1); }
            30% { transform: translateX(20px) scale3d(1.06, 1.06, 1); }
            40% { transform: translateX(20px) scale3d(1.08, 1.08, 1); }
            50% { transform: translateX(20px) scale3d(1.10, 1.10, 1); }
            60% { transform: translateX(20px) scale3d(1.08, 1.08, 1); }
            70% { transform: translateX(20px) scale3d(1.06, 1.06, 1); }
            80% { transform: translateX(20px) scale3d(1.04, 1.04, 1); }
            90% { transform: translateX(20px) scale3d(1.02, 1.02, 1); }
            100% { transform: translateX(20px) scale3d(1, 1, 1); }
        }

        .nav-icon {
            width: 20px;
            height: 20px;
            margin-bottom: 3px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            opacity: 0.9;
        }

        .nav-item.active .nav-icon {
            opacity: 1;
            filter: drop-shadow(0 0 4px rgba(251, 191, 36, 0.4));
        }

        .nav-item:hover .nav-icon {
            transform: translateY(-2px) scale(1.05);
        }

        .nav-label {
            font-size: 0.65rem;
            font-weight: 500;
            letter-spacing: 0.3px;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            text-transform: uppercase;
            opacity: 0.9;
            transition: all 0.3s ease;
        }

        .nav-item.active .nav-label {
            font-weight: 600;
            color: var(--neon-amber);
            text-shadow: 0 0 10px rgba(251, 191, 36, 0.3);
        }

        /* Main Content Area */
        .main-content {
            /* Header (70px) + price ticker (28px) + news ticker (24px) + safe area */
            padding-top: calc(var(--mobile-header-height) + var(--safe-area-top) + 52px);
            /* Edge-to-edge nav: nav height + safe area + breathing room */
            padding-bottom: calc(var(--mobile-nav-height) + env(safe-area-inset-bottom, 0px) + 24px);
            min-height: 100vh;
        }

        /* Dynamic Island Safe Area */
        @supports (padding: max(0px)) {
            .mobile-header {
                padding-top: max(var(--safe-area-top), 20px);
            }
            .main-content {
                /* Header + price ticker (28px) + news ticker (24px) + safe area */
                padding-top: calc(var(--mobile-header-height) + max(var(--safe-area-top), 20px) + 52px);
            }
        }

        /* Tab Content */
        .tab-content {
            display: none;
            padding: var(--content-padding);
            animation: fadeIn 0.3s ease;
            max-width: 430px;
            margin: 0 auto;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Mobile Cards with Neon Glow on Hover */
        .mobile-card {
            background: var(--bg-panel);
            border: 1px solid var(--border-light);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: var(--card-gap);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            transform: translate3d(0, 0, 0);
            contain: layout style paint;
        }
        
        .mobile-card:hover {
            border-color: var(--neon-amber);
            box-shadow: 0 0 20px rgba(251, 191, 36, 0.2);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .card-title {
            font-size: 18px;
            font-weight: 700;
            color: var(--text-accent);
            letter-spacing: 0.5px;
            font-family: 'IBM Plex Mono', monospace;
        }

        .card-badge {
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 12px;
            font-weight: 600;
            font-family: 'IBM Plex Mono', monospace;
            letter-spacing: 0.5px;
        }

        /* Alert Filter Pills */
        .alert-filter-pill {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            padding: 6px 12px;
            border-radius: 16px;
            border: 1px solid var(--border-light);
            background: var(--bg-secondary);
            color: var(--text-secondary);
            font-size: 11px;
            font-weight: 500;
            white-space: nowrap;
            cursor: pointer;
            transition: all 0.2s ease;
            min-height: 28px;
            line-height: 1;
        }

        .alert-filter-pill i,
        .alert-filter-pill svg {
            flex-shrink: 0;
            display: flex;
            align-items: center;
        }

        .alert-filter-pill span {
            display: inline-flex;
            align-items: center;
        }

        .alert-filter-pill:hover {
            border-color: var(--neon-amber);
            color: var(--text-primary);
        }

        .alert-filter-pill.active {
            background: rgba(251, 191, 36, 0.15);
            border-color: var(--neon-amber);
            color: var(--neon-amber);
            font-weight: 600;
        }

        /* Signal Cards */
        .signal-card {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid var(--border-light);
            transition: all 0.2s ease;
        }

        .signal-card:last-child {
            border-bottom: none;
        }
        
        .signal-card:hover {
            background: rgba(251, 191, 36, 0.05);
            margin: 0 -8px;
            padding: 12px 8px;
            border-radius: 8px;
        }

        .signal-info {
            flex: 1;
        }

        .signal-symbol {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-accent);
            margin-bottom: 6px;
            font-family: 'IBM Plex Mono', monospace;
            letter-spacing: 0.5px;
        }

        .signal-details {
            font-size: 14px;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        .signal-score {
            font-size: 22px;
            font-weight: 700;
            padding: 10px 16px;
            border-radius: 12px;
            text-align: center;
            min-width: 75px;
            font-family: 'IBM Plex Mono', monospace;
        }

        .score-high {
            background: rgba(16, 185, 129, 0.2);
            color: var(--accent-positive);
            box-shadow: 0 0 10px rgba(16, 185, 129, 0.2);
        }

        .score-medium {
            background: rgba(245, 158, 11, 0.2);
            color: var(--accent-warning);
            box-shadow: 0 0 10px rgba(245, 158, 11, 0.2);
        }

        .score-low {
            background: rgba(239, 68, 68, 0.2);
            color: var(--accent-negative);
        }

        /* Symbols Grid */
        .symbols-grid {
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-height: 70vh;
            overflow-y: auto;
            position: relative;
        }

        /* Scroll indicator container */
        .scroll-indicator-container {
            position: relative;
        }

        .scroll-indicator-container::after {
            content: '';
            position: sticky;
            bottom: 0;
            left: 0;
            right: 0;
            height: 40px;
            background: linear-gradient(to top, var(--bg-primary) 0%, transparent 100%);
            pointer-events: none;
            display: block;
            margin-top: -40px;
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        .scroll-indicator-container.scrolled-bottom::after {
            opacity: 0;
        }

        /* Scroll hint badge */
        .scroll-hint {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 8px 16px;
            background: rgba(251, 191, 36, 0.15);
            border: 1px solid rgba(251, 191, 36, 0.3);
            border-radius: 20px;
            color: var(--neon-amber);
            font-size: 11px;
            font-weight: 500;
            margin-top: 8px;
            animation: bounce-subtle 2s infinite;
            transition: opacity 0.3s ease;
        }

        .scroll-hint.hidden {
            opacity: 0;
            pointer-events: none;
        }

        @keyframes bounce-subtle {
            0% { transform: translateY(0); }
            15% { transform: translateY(-0.75px); }
            30% { transform: translateY(-1.8px); }
            45% { transform: translateY(-2.7px); }
            50% { transform: translateY(-3px); }
            55% { transform: translateY(-2.7px); }
            70% { transform: translateY(-1.8px); }
            85% { transform: translateY(-0.75px); }
            100% { transform: translateY(0); }
        }

        .symbol-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border-light);
            cursor: pointer;
            transition: all 0.3s ease;
            transform: translate3d(0, 0, 0);
            backface-visibility: hidden;
            will-change: transform;
            contain: layout style;
        }

        .symbol-item:hover {
            border-color: var(--neon-amber);
            box-shadow: 0 0 15px rgba(251, 191, 36, 0.2);
        }

        .symbol-item:active {
            transform: scale(0.98);
            background: rgba(251, 191, 36, 0.1);
            box-shadow: 0 0 20px rgba(251, 191, 36, 0.3), inset 0 0 10px rgba(251, 191, 36, 0.1);
        }

        .symbol-info {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
        }

        .symbol-name {
            font-weight: 700;
            font-size: 16px;
            color: var(--text-accent);
            font-family: 'IBM Plex Mono', monospace;
            letter-spacing: 0.5px;
        }

        .symbol-price {
            font-size: 14px;
            color: var(--text-secondary);
            font-family: 'IBM Plex Mono', monospace;
        }

        .symbol-metrics {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .confluence-score {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 50px;
        }

        .score-value {
            font-size: 18px;
            font-weight: 700;
            font-family: 'IBM Plex Mono', monospace;
        }

        .score-label {
            font-size: 10px;
            color: var(--text-secondary);
            text-transform: uppercase;
            font-family: 'IBM Plex Mono', monospace;
            letter-spacing: 0.5px;
        }

        .symbol-change {
            font-size: 14px;
            font-weight: 700;
            padding: 4px 8px;
            border-radius: 4px;
            font-family: 'IBM Plex Mono', monospace;
        }

        .change-positive {
            color: var(--accent-positive);
            background: rgba(16, 185, 129, 0.1);
        }

        .change-negative {
            color: var(--accent-negative);
            background: rgba(239, 68, 68, 0.1);
        }

        .change-neutral {
            color: var(--text-secondary);
            background: rgba(251, 191, 36, 0.1);
        }

        /* Matrix View */
        .matrix-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin-bottom: 20px;
        }

        .matrix-item {
            background: var(--bg-panel);
            border: 1px solid var(--border-light);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 90px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .matrix-item:hover {
            border-color: var(--neon-amber);
            box-shadow: 0 0 20px rgba(251, 191, 36, 0.2);
        }

        .matrix-item:active {
            transform: scale(0.98);
            background: rgba(251, 191, 36, 0.1);
            box-shadow: 0 0 30px var(--neon-amber), inset 0 0 10px rgba(251, 191, 36, 0.2);
        }

        .matrix-symbol {
            font-size: 16px;
            font-weight: 700;
            color: var(--text-accent);
            margin-bottom: 10px;
            letter-spacing: 0.5px;
            font-family: 'IBM Plex Mono', monospace;
        }

        .matrix-value {
            font-size: 20px;
            font-weight: 700;
            font-family: 'IBM Plex Mono', monospace;
        }

        /* Opportunity List */
        .opportunity-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .opportunity-item {
            background: var(--bg-panel);
            border: 1px solid var(--border-light);
            border-radius: 12px;
            padding: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .opportunity-item:hover {
            border-color: var(--neon-amber);
            box-shadow: 0 0 20px rgba(251, 191, 36, 0.2);
        }

        .opportunity-item:active {
            transform: scale(0.98);
            background: rgba(251, 191, 36, 0.05);
            box-shadow: 0 0 30px var(--neon-amber), inset 0 0 10px rgba(251, 191, 36, 0.2);
        }

        .opportunity-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .opportunity-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .metric-item {
            text-align: center;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            border: 1px solid rgba(251, 191, 36, 0.1);
        }

        .metric-value {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-accent);
            font-family: 'IBM Plex Mono', monospace;
        }

        .metric-label {
            font-size: 8px;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-top: 2px;
            font-family: 'IBM Plex Mono', monospace;
            letter-spacing: 0.5px;
        }

        /* Action Buttons with Neon Glow */
        .action-buttons {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        .action-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'IBM Plex Mono', monospace;
        }

        .btn-primary {
            background: var(--neon-amber);
            color: #0a0a0a;
            border: 1px solid var(--neon-amber);
        }
        
        .btn-primary:hover {
            box-shadow: 0 0 30px var(--neon-amber), inset 0 0 10px rgba(251, 191, 36, 0.2);
        }

        .btn-secondary {
            background: rgba(251, 191, 36, 0.1);
            color: var(--text-accent);
            border: 1px solid var(--neon-amber);
        }
        
        .btn-secondary:hover {
            background: rgba(251, 191, 36, 0.2);
            box-shadow: 0 0 20px rgba(251, 191, 36, 0.3);
        }

        .action-btn:active {
            transform: scale(0.98);
        }

        /* Pull to Refresh */
        .pull-to-refresh {
            position: absolute;
            top: calc(var(--mobile-header-height) + var(--safe-area-top));
            left: 0;
            right: 0;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            font-size: 14px;
            transform: translateY(-60px);
            transition: transform 0.3s;
        }

        .pull-to-refresh.active {
            transform: translateY(0);
        }

        /* Loading States */
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 40px;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border-light);
            border-top-color: var(--neon-amber);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Empty States */
        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-secondary);
        }

        .empty-icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 16px;
            opacity: 0.5;
        }

        .empty-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text-primary);
        }

        .empty-text {
            font-size: 14px;
            line-height: 1.5;
        }

        /* Responsive Typography - Small Phones */
        @media (max-width: 375px) {
            .app-title { font-size: 18px; }
            .card-title { font-size: 16px; }
            .signal-symbol { font-size: 14px; }
            .signal-score { font-size: 18px; }
        }

        /* Tablet Portrait (iPad Mini, iPad) */
        @media (min-width: 768px) {
            :root {
                --content-padding: 24px;
                --card-gap: 20px;
            }

            .main-content {
                max-width: 900px;
                margin: 0 auto;
            }

            .mobile-card {
                padding: 20px;
            }

            .card-title {
                font-size: 18px;
            }

            /* 2-column grid for signal/symbol lists */
            #liveSignalsList,
            #confluenceScoresList,
            #alphaOpportunitiesList {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 12px;
            }

            /* Wider dominance bar labels */
            #btcDomBar, #ethDomBar, #stableDomBar, #altDomBar {
                min-width: 60px;
            }

            /* Better header spacing */
            .mobile-header {
                padding: 0 24px;
            }

            .header-content {
                max-width: 900px;
                margin: 0 auto;
            }

            /* Larger touch targets not needed on tablet */
            button, .nav-item, .tab-btn, .pressable {
                min-height: 40px;
                min-width: 40px;
            }

            /* Bottom nav wider spacing */
            .bottom-nav {
                max-width: 600px;
                margin: 0 auto;
                border-radius: 20px 20px 0 0;
            }
        }

        /* Tablet Landscape / Small Desktop */
        @media (min-width: 1024px) {
            :root {
                --content-padding: 32px;
                --card-gap: 24px;
            }

            .main-content {
                max-width: 1100px;
            }

            .header-content {
                max-width: 1100px;
            }

            .mobile-card {
                padding: 24px;
                border-radius: 16px;
            }

            .card-title {
                font-size: 20px;
            }

            /* 3-column for lists on large tablets */
            #liveSignalsList,
            #confluenceScoresList {
                grid-template-columns: repeat(3, 1fr);
            }

            /* Larger charts */
            #betaChartContainer {
                height: 350px !important;
            }

            .bottom-nav {
                max-width: 700px;
            }
        }

        /* Large Desktop (optional - if accessed on desktop) */
        @media (min-width: 1280px) {
            .main-content {
                max-width: 1200px;
            }

            .header-content {
                max-width: 1200px;
            }
        }

        /* Dark Mode Support (already dark) */
        @media (prefers-color-scheme: dark) {
            :root {
                --bg-primary: #0a0a0a;
                --bg-secondary: #111111;
            }
        }

        /* Landscape Adjustments */
        @media (orientation: landscape) and (max-height: 600px) {
            .mobile-header { height: 50px; }
            .bottom-nav {
                padding: 6px 16px;
                padding-bottom: calc(6px + env(safe-area-inset-bottom, 0px));
            }
            .nav-icon { width: 18px; height: 18px; }
            .nav-label { font-size: 9px; }
            .nav-item {
                padding: 6px 4px;
                min-height: 40px;
                border-radius: 12px;
            }
        }
        
        /* Neon Text Utility */
        .neon-text {
            color: var(--neon-amber);
            text-shadow: 0 0 10px var(--neon-amber);
        }
        
        /* Pulse Animation for Live Indicators */
        @keyframes pulse {
            0% { opacity: 1; }
            10% { opacity: 0.92; }
            20% { opacity: 0.82; }
            30% { opacity: 0.70; }
            40% { opacity: 0.58; }
            50% { opacity: 0.50; }
            60% { opacity: 0.58; }
            70% { opacity: 0.70; }
            80% { opacity: 0.82; }
            90% { opacity: 0.92; }
            100% { opacity: 1; }
        }
        
        .live-indicator {
            animation: pulse 2s infinite;
        }

        /* ============================================
           ZEN MODE - Hidden Easter Egg Feature
           Double-tap title to hide/show header actions
           ============================================ */

        /* Hide header actions with smooth animation */
        .header-actions.zen-hidden {
            transform: translateX(80px);
            opacity: 0;
            pointer-events: none;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Show state with smooth transition */
        .header-actions:not(.zen-hidden) {
            transform: translateX(0);
            opacity: 1;
            pointer-events: auto;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Zen mode: hide price ticker */
        .price-ticker.zen-hidden {
            transform: translateY(-100%);
            opacity: 0;
            pointer-events: none;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .price-ticker:not(.zen-hidden) {
            transform: translateY(0);
            opacity: 1;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Amber glow feedback animation on double-tap */
        @keyframes zen-tap-feedback {
            0% {
                text-shadow: 0 0 10px rgba(251, 191, 36, 0.3);
            }
            50% {
                text-shadow: 0 0 30px rgba(251, 191, 36, 0.8),
                            0 0 40px rgba(251, 191, 36, 0.6),
                            0 0 50px rgba(251, 191, 36, 0.4);
            }
            100% {
                text-shadow: 0 0 10px rgba(251, 191, 36, 0.3);
            }
        }

        .app-title.zen-tapped {
            animation: zen-tap-feedback 0.6s ease-out;
        }

        /* Prevent text selection during double-tap */
        .app-title.zen-interactive {
            user-select: none;
            -webkit-user-select: none;
            cursor: pointer;
        }

        /* ═══════════════════════════════════════════════════════════════════
           MOMENTUM WAVES MOBILE - Native widget optimized for mobile
           ═══════════════════════════════════════════════════════════════════ */

        .momentum-waves-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            padding: 12px;
        }

        .momentum-card-mobile {
            position: relative;
            background: var(--bg-secondary);
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid var(--border-light);
            transition: transform 0.15s ease, border-color 0.15s ease;
        }

        .momentum-card-mobile:active {
            transform: scale(0.98);
            border-color: rgba(255, 255, 255, 0.15);
        }

        .momentum-card-mobile.bullish {
            background: linear-gradient(135deg, var(--bg-secondary) 0%, rgba(16, 185, 129, 0.08) 100%);
        }

        .momentum-card-mobile.bearish {
            background: linear-gradient(135deg, var(--bg-secondary) 0%, rgba(239, 68, 68, 0.08) 100%);
        }

        .momentum-card-mobile.neutral {
            background: linear-gradient(135deg, var(--bg-secondary) 0%, rgba(156, 163, 175, 0.05) 100%);
        }

        .momentum-card-mobile.warming {
            background: linear-gradient(135deg, var(--bg-secondary) 0%, rgba(245, 158, 11, 0.08) 100%);
        }

        /* Card-level pill pulse animation */
        .card-pulse-ring-mobile {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 8px;
            border: 2px solid;
            opacity: 0;
            pointer-events: none;
            will-change: transform, opacity;
        }

        .momentum-card-mobile.bullish .card-pulse-ring-mobile {
            border-color: #10b981;
            animation: cardPulsePill var(--pulse-duration, 3s) ease-out infinite;
        }

        .momentum-card-mobile.bearish .card-pulse-ring-mobile {
            border-color: #ef4444;
            animation: cardPulsePill var(--pulse-duration, 3s) ease-out infinite;
        }

        .momentum-card-mobile.neutral .card-pulse-ring-mobile {
            /* No pulse animation for neutral cards - only circle pulses */
            display: none;
        }

        .momentum-card-mobile.warming .card-pulse-ring-mobile {
            border-color: #f59e0b;
            animation: cardPulsePill var(--pulse-duration, 3.5s) ease-out infinite;
        }

        @keyframes cardPulsePill {
            0% {
                transform: scaleX(1);
                opacity: 0;
            }
            5% {
                opacity: 0.25;
            }
            20% {
                transform: scaleX(1.03);
                opacity: 0.18;
            }
            50% {
                transform: scaleX(1.08);
                opacity: 0.08;
            }
            100% {
                transform: scaleX(1.12);
                opacity: 0;
            }
        }

        .momentum-card-inner-mobile {
            display: flex;
            flex-direction: column;
            padding: 10px;
            position: relative;
            z-index: 2;
        }

        .momentum-card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 8px;
        }

        .momentum-symbol-mobile {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 13px;
            font-weight: 700;
            color: var(--text-primary);
            letter-spacing: -0.02em;
        }

        .momentum-signal-badge-mobile {
            display: inline-flex;
            align-items: center;
            gap: 3px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 8px;
            font-weight: 600;
            padding: 2px 5px;
            border-radius: 3px;
            letter-spacing: 0.04em;
        }

        .momentum-signal-badge-mobile::before {
            content: '';
            width: 4px;
            height: 4px;
            border-radius: 50%;
            animation: momentumSignalPulseMobile 1.5s ease-in-out infinite;
        }

        @keyframes momentumSignalPulseMobile {
            0% { opacity: 1; transform: scale3d(1, 1, 1); }
            5% { opacity: 0.97; transform: scale3d(0.985, 0.985, 1); }
            10% { opacity: 0.94; transform: scale3d(0.97, 0.97, 1); }
            15% { opacity: 0.90; transform: scale3d(0.955, 0.955, 1); }
            20% { opacity: 0.86; transform: scale3d(0.94, 0.94, 1); }
            25% { opacity: 0.82; transform: scale3d(0.928, 0.928, 1); }
            30% { opacity: 0.78; transform: scale3d(0.918, 0.918, 1); }
            35% { opacity: 0.75; transform: scale3d(0.91, 0.91, 1); }
            40% { opacity: 0.73; transform: scale3d(0.905, 0.905, 1); }
            45% { opacity: 0.71; transform: scale3d(0.902, 0.902, 1); }
            50% { opacity: 0.70; transform: scale3d(0.90, 0.90, 1); }
            55% { opacity: 0.71; transform: scale3d(0.902, 0.902, 1); }
            60% { opacity: 0.73; transform: scale3d(0.905, 0.905, 1); }
            65% { opacity: 0.75; transform: scale3d(0.91, 0.91, 1); }
            70% { opacity: 0.78; transform: scale3d(0.918, 0.918, 1); }
            75% { opacity: 0.82; transform: scale3d(0.928, 0.928, 1); }
            80% { opacity: 0.86; transform: scale3d(0.94, 0.94, 1); }
            85% { opacity: 0.90; transform: scale3d(0.955, 0.955, 1); }
            90% { opacity: 0.94; transform: scale3d(0.97, 0.97, 1); }
            95% { opacity: 0.97; transform: scale3d(0.985, 0.985, 1); }
            100% { opacity: 1; transform: scale3d(1, 1, 1); }
        }

        .momentum-signal-badge-mobile.LONG {
            background: rgba(16, 185, 129, 0.15);
            color: #34d399;
            border: 1px solid rgba(16, 185, 129, 0.3);
        }
        .momentum-signal-badge-mobile.LONG::before { background: #10b981; }

        .momentum-signal-badge-mobile.SHORT {
            background: rgba(239, 68, 68, 0.15);
            color: #f87171;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }
        .momentum-signal-badge-mobile.SHORT::before { background: #ef4444; }

        .momentum-signal-badge-mobile.NEUTRAL {
            background: rgba(156, 163, 175, 0.12);
            color: #d1d5db;
            border: 1px solid rgba(156, 163, 175, 0.2);
        }
        .momentum-signal-badge-mobile.NEUTRAL::before {
            background: #9ca3af;
            animation: none;
        }

        .momentum-signal-badge-mobile.WARM {
            background: rgba(245, 158, 11, 0.15);
            color: #fbbf24;
            border: 1px solid rgba(245, 158, 11, 0.3);
        }
        .momentum-signal-badge-mobile.WARM::before { background: #f59e0b; }

        .momentum-signal-badge-mobile.COOL {
            background: rgba(245, 158, 11, 0.15);
            color: #fbbf24;
            border: 1px solid rgba(245, 158, 11, 0.3);
        }
        .momentum-signal-badge-mobile.COOL::before { background: #f59e0b; }

        .momentum-card-body {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .momentum-metrics-mobile {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .momentum-metric-mobile {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .momentum-metric-label-mobile {
            font-size: 9px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.04em;
            width: 28px;
        }

        .momentum-metric-value-mobile {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 11px;
            font-weight: 500;
            color: var(--text-primary);
        }

        .momentum-metric-value-mobile.positive { color: #34d399; }
        .momentum-metric-value-mobile.negative { color: #f87171; }

        .momentum-trend-arrow-mobile {
            display: inline-block;
            font-size: 0.65em;
            margin-left: 1px;
        }

        .momentum-score-container-mobile {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .momentum-sparkline-mobile {
            width: 55px;
            height: 20px;
            opacity: 0.9;
        }

        .sparkline-path-mobile {
            fill: none;
            stroke-width: 1.5;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .momentum-card-mobile.bullish .sparkline-path-mobile { stroke: #10b981; }
        .momentum-card-mobile.bearish .sparkline-path-mobile { stroke: #ef4444; }
        .momentum-card-mobile.neutral .sparkline-path-mobile { stroke: #9ca3af; }
        .momentum-card-mobile.warming .sparkline-path-mobile { stroke: #f59e0b; }

        .momentum-score-circle-mobile {
            position: relative;
            width: 36px;
            height: 36px;
            flex-shrink: 0;
        }

        .momentum-score-ring-mobile {
            transform: rotate(-90deg);
        }

        .momentum-score-ring-bg-mobile {
            fill: none;
            stroke: rgba(255, 255, 255, 0.06);
            stroke-width: 3;
        }

        .momentum-score-ring-progress-mobile {
            fill: none;
            stroke-width: 3;
            stroke-linecap: round;
            transition: stroke-dashoffset 0.5s ease;
        }

        .momentum-card-mobile.bullish .momentum-score-ring-progress-mobile {
            stroke: url(#momentumBullishGradientMobile);
            filter: drop-shadow(0 0 6px rgba(16, 185, 129, 0.4));
        }

        .momentum-card-mobile.bearish .momentum-score-ring-progress-mobile {
            stroke: url(#momentumBearishGradientMobile);
            filter: drop-shadow(0 0 6px rgba(239, 68, 68, 0.4));
        }

        .momentum-card-mobile.neutral .momentum-score-ring-progress-mobile {
            stroke: #9ca3af;
            filter: drop-shadow(0 0 4px rgba(156, 163, 175, 0.3));
        }

        .momentum-card-mobile.warming .momentum-score-ring-progress-mobile {
            stroke: #f59e0b;
            filter: drop-shadow(0 0 6px rgba(245, 158, 11, 0.4));
        }

        .momentum-score-inner-mobile {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }

        .momentum-score-value-mobile {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 11px;
            font-weight: 700;
            line-height: 1;
        }

        .momentum-card-mobile.bullish .momentum-score-value-mobile { color: #34d399; }
        .momentum-card-mobile.bearish .momentum-score-value-mobile { color: #f87171; }
        .momentum-card-mobile.neutral .momentum-score-value-mobile { color: #d1d5db; }
        .momentum-card-mobile.warming .momentum-score-value-mobile { color: #fbbf24; }

        .momentum-pulse-ring-mobile {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 2px solid;
            opacity: 0;
            will-change: transform, opacity;
        }

        .momentum-card-mobile.bullish .momentum-pulse-ring-mobile {
            border-color: #10b981;
            animation: momentumPulseGlowMobile var(--pulse-duration, 2.5s) cubic-bezier(0.4, 0, 0.2, 1) infinite;
        }

        .momentum-card-mobile.bearish .momentum-pulse-ring-mobile {
            border-color: #ef4444;
            animation: momentumPulseGlowMobile var(--pulse-duration, 2.5s) cubic-bezier(0.4, 0, 0.2, 1) infinite;
        }

        .momentum-card-mobile.neutral .momentum-pulse-ring-mobile {
            border-color: #6b7280;
            animation: momentumPulseGlowMobile var(--pulse-duration, 4s) cubic-bezier(0.4, 0, 0.2, 1) infinite;
            opacity: 0.3;
        }

        .momentum-card-mobile.warming .momentum-pulse-ring-mobile {
            border-color: #f59e0b;
            animation: momentumPulseGlowMobile var(--pulse-duration, 3s) cubic-bezier(0.4, 0, 0.2, 1) infinite;
        }

        @keyframes momentumPulseGlowMobile {
            0% { transform: translate(-50%, -50%) scale3d(1, 1, 1); opacity: 0; }
            2% { transform: translate(-50%, -50%) scale3d(1.005, 1.005, 1); opacity: 0.05; }
            4% { transform: translate(-50%, -50%) scale3d(1.012, 1.012, 1); opacity: 0.12; }
            6% { transform: translate(-50%, -50%) scale3d(1.02, 1.02, 1); opacity: 0.19; }
            8% { transform: translate(-50%, -50%) scale3d(1.03, 1.03, 1); opacity: 0.26; }
            10% { transform: translate(-50%, -50%) scale3d(1.04, 1.04, 1); opacity: 0.32; }
            12% { transform: translate(-50%, -50%) scale3d(1.052, 1.052, 1); opacity: 0.38; }
            15% { transform: translate(-50%, -50%) scale3d(1.07, 1.07, 1); opacity: 0.44; }
            18% { transform: translate(-50%, -50%) scale3d(1.09, 1.09, 1); opacity: 0.48; }
            22% { transform: translate(-50%, -50%) scale3d(1.115, 1.115, 1); opacity: 0.50; }
            26% { transform: translate(-50%, -50%) scale3d(1.14, 1.14, 1); opacity: 0.49; }
            30% { transform: translate(-50%, -50%) scale3d(1.17, 1.17, 1); opacity: 0.47; }
            35% { transform: translate(-50%, -50%) scale3d(1.205, 1.205, 1); opacity: 0.44; }
            40% { transform: translate(-50%, -50%) scale3d(1.24, 1.24, 1); opacity: 0.40; }
            45% { transform: translate(-50%, -50%) scale3d(1.275, 1.275, 1); opacity: 0.36; }
            50% { transform: translate(-50%, -50%) scale3d(1.31, 1.31, 1); opacity: 0.32; }
            55% { transform: translate(-50%, -50%) scale3d(1.345, 1.345, 1); opacity: 0.28; }
            60% { transform: translate(-50%, -50%) scale3d(1.38, 1.38, 1); opacity: 0.24; }
            65% { transform: translate(-50%, -50%) scale3d(1.415, 1.415, 1); opacity: 0.20; }
            70% { transform: translate(-50%, -50%) scale3d(1.45, 1.45, 1); opacity: 0.16; }
            75% { transform: translate(-50%, -50%) scale3d(1.485, 1.485, 1); opacity: 0.12; }
            80% { transform: translate(-50%, -50%) scale3d(1.52, 1.52, 1); opacity: 0.09; }
            85% { transform: translate(-50%, -50%) scale3d(1.55, 1.55, 1); opacity: 0.06; }
            90% { transform: translate(-50%, -50%) scale3d(1.575, 1.575, 1); opacity: 0.03; }
            95% { transform: translate(-50%, -50%) scale3d(1.59, 1.59, 1); opacity: 0.01; }
            100% { transform: translate(-50%, -50%) scale3d(1.6, 1.6, 1); opacity: 0; }
        }

        /* SVG definitions - hidden */
        .momentum-svg-defs-mobile {
            position: absolute;
            width: 0;
            height: 0;
            overflow: hidden;
        }

        /* ===================================
           SIGNAL PILLS (Phase 2 - Mobile)
           =================================== */

        .signal-pill-mobile {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            border: 1px solid transparent;
            transition: all 0.2s ease;
        }

        /* Signal Direction Colors */
        .signal-pill-mobile.bullish {
            background: rgba(0, 214, 143, 0.15);
            color: var(--accent-positive);
            border-color: rgba(0, 214, 143, 0.25);
        }

        .signal-pill-mobile.bearish {
            background: rgba(255, 82, 82, 0.15);
            color: var(--accent-negative);
            border-color: rgba(255, 82, 82, 0.25);
        }

        /* Signal Strength Intensity */
        .signal-pill-mobile.extreme {
            font-weight: 700;
            border-width: 1.5px;
        }

        .signal-pill-mobile.strong {
            opacity: 0.95;
        }

        .signal-pill-mobile.moderate {
            opacity: 0.85;
        }

        .signal-pill-mobile.weak {
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <!-- SVG Definitions for Alpha Pulse Mobile -->
    <svg class="momentum-svg-defs-mobile" aria-hidden="true">
        <defs>
            <linearGradient id="momentumBullishGradientMobile" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" style="stop-color:#10b981" />
                <stop offset="100%" style="stop-color:#34d399" />
            </linearGradient>
            <linearGradient id="momentumBearishGradientMobile" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" style="stop-color:#ef4444" />
                <stop offset="100%" style="stop-color:#f87171" />
            </linearGradient>
        </defs>
    </svg>

    <!-- Mobile Header -->
    <header class="mobile-header">
        <div class="header-content">
            <h1 id="appTitle" class="app-title zen-interactive" style="display: flex; align-items: center; position: relative;">
                <i data-lucide="trending-up" style="width: 24px; height: 24px; margin-right: 8px; color: var(--accent-warning);"></i>
                VIRTUOSO
            </h1>
            <div class="header-actions" id="headerActions">
                <button class="header-btn" onclick="refreshData()">
                    <i data-lucide="refresh-cw" class="header-icon"></i>
                </button>
                <button class="header-btn" onclick="toggleSettings()">
                    <i data-lucide="settings" class="header-icon"></i>
                </button>
            </div>
        </div>
    </header>

    <!-- Price Ticker Bar -->
    <div class="price-ticker" id="priceTicker">
        <div class="ticker-track" id="tickerTrack">
            <!-- Ticker items populated by JavaScript -->
        </div>
    </div>

    <!-- News Ticker Bar -->
    <div class="news-ticker" id="newsTicker">
        <div class="news-ticker-label">News</div>
        <div class="news-track" id="newsTrack">
            <!-- News items populated by JavaScript -->
        </div>
    </div>

    <!-- Pull to Refresh -->
    <div class="pull-to-refresh" id="pullToRefresh">
        <i data-lucide="refresh-cw" style="width: 16px; height: 16px; margin-right: 8px;"></i>
        <span>Pull to refresh</span>
    </div>

    <!-- Main Content -->
    <main class="main-content">
        <!-- Dashboard Tab -->
        <div class="tab-content active" id="dashboardTab">
            <!-- Market Overview -->
            <div class="mobile-card">
                <div class="card-header">
                    <h2 class="card-title">Market Overview</h2>
                    <span class="card-badge" style="background: rgba(76, 175, 80, 0.2); color: var(--accent-positive);">
                        LIVE
                    </span>
                </div>

                <!-- HERO: Market Regime (Primary Focus) -->
                <div style="background: linear-gradient(135deg, rgba(0,0,0,0.3) 0%, rgba(0,0,0,0.15) 100%); padding: 10px 12px; border-radius: 10px; margin-bottom: 12px; border: 1px solid rgba(255,255,255,0.05);">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <div style="font-size: 10px; color: var(--text-secondary); margin-bottom: 2px; text-transform: uppercase; letter-spacing: 0.5px;">Market Regime</div>
                            <div id="marketRegime" style="padding: 6px 10px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.08); max-width: 180px;">
                                <div id="regimeCategory" style="font-size: 14px; font-weight: 700; letter-spacing: 0.2px; color: var(--text-primary); line-height: 1.2;">Loading</div>
                                <div id="regimeLabel" style="font-size: 11px; font-weight: 500; color: var(--text-secondary); margin-top: 2px; line-height: 1.2;"></div>
                            </div>
                        </div>
                        <!-- Fear & Greed (Compact) -->
                        <div style="text-align: right;">
                            <div style="font-size: 10px; color: var(--text-secondary); margin-bottom: 2px; text-transform: uppercase;">Fear & Greed</div>
                            <div style="display: flex; align-items: center; gap: 6px; justify-content: flex-end;">
                                <div id="fearGreedValue" style="font-size: 22px; font-weight: 800; color: var(--accent-warning);">50</div>
                                <div id="fearGreedLabel" style="font-size: 10px; font-weight: 600; color: var(--text-secondary); max-width: 50px; line-height: 1.2;">Neutral</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Total Market Cap (Simplified - removed Vol/MCap per UX review) -->
                <div style="background: rgba(0,0,0,0.15); padding: 12px 14px; border-radius: 10px; margin-bottom: 14px;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <div style="font-size: 10px; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.3px;">Total Market Cap</div>
                            <div style="display: flex; align-items: baseline; gap: 8px; margin-top: 2px;">
                                <span id="totalMarketCap" style="font-size: 24px; font-weight: 700; color: var(--text-primary);">$0</span>
                                <span id="marketCapChange" style="font-size: 12px; font-weight: 600; padding: 2px 8px; border-radius: 4px; background: rgba(76, 175, 80, 0.2); color: var(--accent-positive);">+0%</span>
                            </div>
                        </div>
                        <div style="text-align: right;">
                            <div style="font-size: 10px; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.3px;">24H Volume</div>
                            <div id="totalVolume" style="font-size: 16px; font-weight: 600; color: var(--text-primary); margin-top: 2px;">$0</div>
                        </div>
                    </div>
                </div>

                <!-- Dominance Breakdown Bar (Enhanced per Frontend Dev) -->
                <div style="margin-bottom: 14px;">
                    <div style="font-size: 10px; color: var(--text-secondary); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.3px;">Market Dominance</div>
                    <div style="height: 28px; border-radius: 6px; overflow: hidden; display: flex; background: rgba(0,0,0,0.3); box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);">
                        <div id="btcDomBar" style="background: linear-gradient(180deg, #f7931a 0%, #e67b00 100%); height: 100%; display: flex; align-items: center; justify-content: center; transition: width 0.5s ease; min-width: 40px;">
                            <span style="font-size: 9px; font-weight: 700; color: white; text-shadow: 0 1px 2px rgba(0,0,0,0.3);">BTC</span>
                        </div>
                        <div id="ethDomBar" style="background: linear-gradient(180deg, #627eea 0%, #4a66d4 100%); height: 100%; display: flex; align-items: center; justify-content: center; transition: width 0.5s ease; min-width: 32px;">
                            <span style="font-size: 9px; font-weight: 700; color: white; text-shadow: 0 1px 2px rgba(0,0,0,0.3);">ETH</span>
                        </div>
                        <div id="stableDomBar" style="background: linear-gradient(180deg, #26a17b 0%, #1d8a68 100%); height: 100%; display: flex; align-items: center; justify-content: center; transition: width 0.5s ease; min-width: 38px;">
                            <span style="font-size: 9px; font-weight: 700; color: white; text-shadow: 0 1px 2px rgba(0,0,0,0.3);">STBL</span>
                        </div>
                        <div id="altDomBar" style="background: linear-gradient(180deg, #8b5cf6 0%, #7244e8 100%); height: 100%; display: flex; align-items: center; justify-content: center; transition: width 0.5s ease; flex: 1; min-width: 36px;">
                            <span style="font-size: 9px; font-weight: 700; color: white; text-shadow: 0 1px 2px rgba(0,0,0,0.3);">ALTS</span>
                        </div>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-top: 6px; font-size: 11px;">
                        <span style="color: #f7931a;"><span id="btcDominance" style="font-weight: 700;">57.2%</span> BTC</span>
                        <span style="color: #627eea;"><span id="ethDominance" style="font-weight: 700;">11.4%</span> ETH</span>
                        <span style="color: #26a17b;"><span id="stableDominance" style="font-weight: 700;">8.3%</span> Stable</span>
                        <span style="color: #8b5cf6;"><span id="altDominance" style="font-weight: 700;">23.1%</span> Alts</span>
                    </div>
                </div>

                <!-- Trend & Volatility Row -->
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; margin-bottom: 12px;">
                    <!-- Trend Strength -->
                    <div class="overview-metric">
                        <div style="font-size: 10px; color: var(--text-secondary); margin-bottom: 4px; text-transform: uppercase;">Trend Strength</div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <div id="trendStrength" style="font-size: 18px; font-weight: 700;">0</div>
                            <div style="flex: 1; height: 8px; background: rgba(255, 255, 255, 0.1); border-radius: 4px; overflow: hidden;">
                                <div id="trendStrengthBar" style="height: 100%; width: 0%; background: var(--accent-primary); transition: width 0.3s ease;"></div>
                            </div>
                        </div>
                    </div>

                    <!-- Market Volatility -->
                    <div class="overview-metric">
                        <div style="font-size: 10px; color: var(--text-secondary); margin-bottom: 4px; text-transform: uppercase;">Volatility</div>
                        <div style="font-size: 14px;">
                            <span id="currentVolatility" style="font-weight: 700; color: var(--text-primary);">0%</span>
                            <span style="color: var(--text-secondary); font-size: 11px;"> vs </span>
                            <span id="avgVolatility" style="color: var(--text-secondary); font-size: 12px;">0%</span>
                        </div>
                        <div style="font-size: 10px; margin-top: 2px;">
                            <span id="volatilityDescriptor" style="font-weight: 600; text-transform: uppercase;">-</span>
                        </div>
                    </div>
                </div>

                <!-- Market Sentiment Breadth -->
                <div class="breadth-visual" style="padding-top: 12px; border-top: 1px solid var(--border-light);">
                    <div class="breadth-title" style="font-size: 10px; color: var(--text-secondary); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px;">Market Sentiment <span class="live-indicator" style="display: inline-block; width: 6px; height: 6px; background: var(--accent-positive); border-radius: 50%; margin-left: 6px; animation: pulse 2s infinite;"></span></div>
                    <div class="breadth-main" style="display: flex; align-items: center; gap: 12px; margin-bottom: 8px;">
                        <div class="market-icon" id="marketIcon" style="width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; transition: all 0.3s ease; background: rgba(76, 175, 80, 0.2); color: var(--accent-positive);">
                            <i data-lucide="trending-up" style="width: 24px; height: 24px;"></i>
                        </div>
                        <div class="breadth-details" style="flex: 1;">
                            <div class="breadth-label" id="marketLabel" style="font-size: 14px; font-weight: 600; margin-bottom: 4px;">Loading...</div>
                            <div class="breadth-bar-container" style="height: 24px; background: #0a1018; border-radius: 12px; overflow: hidden; position: relative; margin-bottom: 6px;">
                                <div class="breadth-bar-fill" style="height: 100%; display: flex; align-items: center; transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);">
                                    <div class="bull-section" id="bullSection" style="background: var(--accent-positive); height: 100%; display: flex; align-items: center; justify-content: center; color: white; font-size: 11px; font-weight: 700; transition: width 0.5s ease; width: 50%;">50%</div>
                                    <div class="bear-section" id="bearSection" style="background: var(--accent-negative); height: 100%; display: flex; align-items: center; justify-content: center; color: white; font-size: 11px; font-weight: 700; transition: width 0.5s ease; width: 50%;">50%</div>
                                </div>
                            </div>
                            <div class="breadth-stats" style="display: flex; justify-content: space-between; font-size: 12px; color: var(--text-muted);">
                                <span class="stat-item" style="display: flex; align-items: center; gap: 4px;">
                                    <i data-lucide="arrow-up" style="width: 12px; height: 12px; color: var(--accent-positive);"></i>
                                    <span class="stat-value" id="upCount" style="font-weight: 600; color: var(--text-primary);">0</span>
                                    <span>rising</span>
                                </span>
                                <span class="stat-item" style="display: flex; align-items: center; gap: 4px;">
                                    <i data-lucide="arrow-down" style="width: 12px; height: 12px; color: var(--accent-negative);"></i>
                                    <span class="stat-value" id="downCount" style="font-weight: 600; color: var(--text-primary);">0</span>
                                    <span>falling</span>
                                </span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Altcoin Season Indicator (Tertiary) -->
                <div style="display: flex; justify-content: flex-end; margin-top: 8px;">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span style="font-size: 10px; color: var(--text-secondary); text-transform: uppercase;">Altcoin Season</span>
                        <div id="altcoinSeason" style="font-size: 12px; font-weight: 700; padding: 4px 12px; border-radius: 12px; background: rgba(139, 92, 246, 0.2); color: #a78bfa;">
                            Dormant
                        </div>
                    </div>
                </div>
            </div>

            <!-- Perpetuals Pulse (Derivatives Intelligence) -->
            <div class="mobile-card" id="perpsPulseCard">
                <div class="card-header">
                    <h2 class="card-title">Perpetuals Pulse</h2>
                    <span class="card-badge" id="perpsExchangeCount" style="background: rgba(255, 165, 0, 0.2); color: #ffa500;">
                        8 CEX/DEX
                    </span>
                </div>

                <!-- Row 1: Funding Rate + Long/Short + Basis -->
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-bottom: 12px;">
                    <!-- Funding Rate -->
                    <div style="background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px; text-align: center;">
                        <div style="font-size: 10px; color: var(--text-secondary); margin-bottom: 4px; text-transform: uppercase;">Funding Rate</div>
                        <div id="perpsFundingRate" style="font-size: 18px; font-weight: 800; color: var(--text-primary);">0.000%</div>
                        <div id="perpsFundingSentiment" style="font-size: 10px; font-weight: 600; color: var(--text-secondary); margin-top: 2px;">NEUTRAL</div>
                    </div>

                    <!-- Long/Short Ratio -->
                    <div style="background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px; text-align: center;">
                        <div style="font-size: 10px; color: var(--text-secondary); margin-bottom: 4px; text-transform: uppercase;">Long / Short</div>
                        <div style="display: flex; justify-content: center; gap: 4px; align-items: baseline;">
                            <span id="perpsLongPct" style="font-size: 16px; font-weight: 700; color: var(--accent-positive);">50%</span>
                            <span style="color: var(--text-secondary); font-size: 12px;">/</span>
                            <span id="perpsShortPct" style="font-size: 16px; font-weight: 700; color: var(--accent-negative);">50%</span>
                        </div>
                        <div id="perpsLSLabel" style="font-size: 10px; font-weight: 600; color: var(--text-secondary); margin-top: 2px;">BALANCED</div>
                    </div>

                    <!-- Basis Status -->
                    <div style="background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px; text-align: center; min-width: 95px; display: flex; flex-direction: column; align-items: center;">
                        <div style="font-size: 10px; color: var(--text-secondary); margin-bottom: 4px; text-transform: uppercase;">Basis</div>
                        <div id="perpsBasisStatus" style="font-size: 8px; font-weight: 700; padding: 3px 6px; border-radius: 4px; background: rgba(255, 191, 0, 0.15); color: var(--text-primary); white-space: nowrap; letter-spacing: 0.3px;">NEUTRAL</div>
                        <div id="perpsBasisPct" style="font-size: 10px; color: var(--text-secondary); margin-top: 2px;">+0.00%</div>
                    </div>
                </div>

                <!-- Row 2: Open Interest + CEX/DEX Bar -->
                <div style="background: rgba(0,0,0,0.15); padding: 12px; border-radius: 10px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <div>
                            <div style="font-size: 10px; color: var(--text-secondary); text-transform: uppercase;">Open Interest</div>
                            <div id="perpsOpenInterest" style="font-size: 20px; font-weight: 700; color: var(--text-primary);">$0B</div>
                        </div>
                        <div style="text-align: right;">
                            <div style="font-size: 10px; color: var(--text-secondary); text-transform: uppercase;">24H Volume</div>
                            <div id="perpsVolume" style="font-size: 16px; font-weight: 600; color: var(--text-secondary);">$0B</div>
                        </div>
                    </div>

                    <!-- CEX/DEX Distribution Bar -->
                    <div style="margin-top: 8px;">
                        <div style="font-size: 10px; color: var(--text-secondary); margin-bottom: 4px; text-transform: uppercase;">CEX vs DEX Distribution</div>
                        <div style="height: 20px; border-radius: 6px; overflow: hidden; display: flex; background: rgba(0,0,0,0.3);">
                            <div id="perpsCexBar" style="background: linear-gradient(180deg, #ffa500 0%, #e67b00 100%); height: 100%; display: flex; align-items: center; justify-content: center; transition: width 0.5s ease; width: 90%;">
                                <span style="font-size: 10px; font-weight: 700; color: white;">CEX 90%</span>
                            </div>
                            <div id="perpsDexBar" style="background: linear-gradient(180deg, #8b5cf6 0%, #7244e8 100%); height: 100%; display: flex; align-items: center; justify-content: center; transition: width 0.5s ease; flex: 1;">
                                <span style="font-size: 10px; font-weight: 700; color: white;">DEX</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Row 3: Advanced Metrics (Phase 2) -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 12px; margin-bottom: 12px;">
                    <!-- Funding Z-Score -->
                    <div style="background: rgba(0,0,0,0.15); padding: 10px; border-radius: 8px; display: flex; align-items: center; justify-content: space-between;">
                        <div style="font-size: 10px; color: var(--text-secondary); text-transform: uppercase;">Funding σ</div>
                        <div id="perpsFundingZScore" style="font-size: 16px; font-weight: 700; color: var(--text-secondary);">+0.00σ</div>
                    </div>
                    <!-- L/S Entropy (Health Indicator) -->
                    <div style="background: rgba(0,0,0,0.15); padding: 10px; border-radius: 8px; display: flex; align-items: center; justify-content: space-between;">
                        <div style="font-size: 10px; color: var(--text-secondary); text-transform: uppercase;">L/S Health</div>
                        <div id="perpsLSEntropy" style="font-size: 16px; font-weight: 700; color: var(--text-secondary);">50%</div>
                    </div>
                </div>

                <!-- Row 4: Active Signals (Phase 2) -->
                <div id="perpsSignalsContainer" style="display: none; background: rgba(0,0,0,0.15); padding: 12px; border-radius: 10px; margin-bottom: 12px;">
                    <div style="font-size: 11px; color: var(--text-secondary); text-transform: uppercase; margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
                        <span style="font-size: 16px;">⚡</span>
                        <span>Active Signals</span>
                    </div>
                    <div id="perpsSignalsList" style="display: flex; flex-wrap: wrap; gap: 6px;">
                        <!-- Signal pills will be dynamically inserted here -->
                    </div>
                </div>

                <!-- Loading/Error State -->
                <div id="perpsLoadingState" style="display: none; text-align: center; padding: 20px; color: var(--text-secondary);">
                    <div class="spinner" style="width: 24px; height: 24px; margin: 0 auto 8px;"></div>
                    Loading perpetuals data...
                </div>
            </div>

            <!-- Winners & Losers Section -->
            <div class="mobile-card">
                <div class="card-header">
                    <h2 class="card-title">Top Movers - All Markets</h2>
                    <span class="card-badge" style="background: rgba(255, 191, 0, 0.2); color: var(--text-primary);">
                        24H
                    </span>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
                    <!-- Winners Column -->
                    <div>
                        <h4 style="font-size: 13px; font-weight: 600; color: var(--accent-positive); margin-bottom: 12px; text-transform: uppercase; letter-spacing: 0.5px;">
                            🔥 TOP GAINERS
                        </h4>
                        <div id="topGainersList" style="display: flex; flex-direction: column; gap: 8px;">
                            <!-- Winners will be populated here - skeleton loaders -->
                            <div class="skeleton-card"><div class="skeleton skeleton-avatar"></div><div style="flex:1"><div class="skeleton skeleton-text" style="margin-bottom:6px"></div><div class="skeleton skeleton-text-sm"></div></div></div>
                            <div class="skeleton-card"><div class="skeleton skeleton-avatar"></div><div style="flex:1"><div class="skeleton skeleton-text" style="margin-bottom:6px"></div><div class="skeleton skeleton-text-sm"></div></div></div>
                            <div class="skeleton-card"><div class="skeleton skeleton-avatar"></div><div style="flex:1"><div class="skeleton skeleton-text" style="margin-bottom:6px"></div><div class="skeleton skeleton-text-sm"></div></div></div>
                        </div>
                    </div>
                    
                    <!-- Losers Column -->
                    <div>
                        <h4 style="font-size: 13px; font-weight: 600; color: var(--accent-negative); margin-bottom: 12px; text-transform: uppercase; letter-spacing: 0.5px;">
                            📉 TOP LOSERS
                        </h4>
                        <div id="topLosersList" style="display: flex; flex-direction: column; gap: 8px;">
                            <!-- Losers will be populated here - skeleton loaders -->
                            <div class="skeleton-card"><div class="skeleton skeleton-avatar"></div><div style="flex:1"><div class="skeleton skeleton-text" style="margin-bottom:6px"></div><div class="skeleton skeleton-text-sm"></div></div></div>
                            <div class="skeleton-card"><div class="skeleton skeleton-avatar"></div><div style="flex:1"><div class="skeleton skeleton-text" style="margin-bottom:6px"></div><div class="skeleton skeleton-text-sm"></div></div></div>
                            <div class="skeleton-card"><div class="skeleton skeleton-avatar"></div><div style="flex:1"><div class="skeleton skeleton-text" style="margin-bottom:6px"></div><div class="skeleton skeleton-text-sm"></div></div></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Signals Tab -->
        <div class="tab-content" id="signalsTab">
            <!-- Signal Overview -->
            <div class="mobile-card" style="margin-bottom: 12px;">
                <div class="card-header" style="margin-bottom: 12px;">
                    <h2 class="card-title">Signal Overview</h2>
                    <span class="card-badge" id="signalCount" style="background: rgba(255, 191, 0, 0.2); color: var(--text-primary);">
                        0
                    </span>
                </div>
                <!-- Performance Stats Row -->
                <div id="signalSummary" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px;">
                    <div style="background: rgba(0,0,0,0.2); padding: 8px; border-radius: 6px; text-align: center;">
                        <div style="font-size: 9px; color: var(--text-secondary); text-transform: uppercase; margin-bottom: 2px;">Long</div>
                        <div id="longCount" style="font-size: 16px; font-weight: 700; color: var(--accent-positive);">0</div>
                    </div>
                    <div style="background: rgba(0,0,0,0.2); padding: 8px; border-radius: 6px; text-align: center;">
                        <div style="font-size: 9px; color: var(--text-secondary); text-transform: uppercase; margin-bottom: 2px;">Short</div>
                        <div id="shortCount" style="font-size: 16px; font-weight: 700; color: var(--accent-negative);">0</div>
                    </div>
                    <div style="background: rgba(0,0,0,0.2); padding: 8px; border-radius: 6px; text-align: center;">
                        <div style="font-size: 9px; color: var(--text-secondary); text-transform: uppercase; margin-bottom: 2px;">Win Rate</div>
                        <div id="winRate" style="font-size: 16px; font-weight: 700; color: var(--neon-amber);">--</div>
                    </div>
                    <div style="background: rgba(0,0,0,0.2); padding: 8px; border-radius: 6px; text-align: center;">
                        <div style="font-size: 9px; color: var(--text-secondary); text-transform: uppercase; margin-bottom: 2px;">24h W/L</div>
                        <div id="winLoss" style="font-size: 16px; font-weight: 700; color: var(--text-primary);">0/0</div>
                    </div>
                </div>
                <!-- Risk Parameters -->
                <div style="margin-top: 10px; padding: 8px 10px; background: rgba(251, 191, 36, 0.08); border-radius: 6px; display: flex; justify-content: space-between; align-items: center;">
                    <span style="font-size: 11px; color: var(--text-secondary);">Risk: <span style="color: var(--text-primary); font-weight: 500;">3.5% SL</span></span>
                    <span style="font-size: 11px; color: var(--text-secondary);">R:R <span style="color: var(--neon-amber); font-weight: 500;">2:1</span></span>
                    <span style="font-size: 11px; color: var(--text-secondary);">Expiry: <span style="color: var(--text-primary); font-weight: 500;">24h</span></span>
                </div>
            </div>
            <!-- Alerted Trade Signals Section - Thanks to Mike Reyes for the UX feedback that led to this feature -->
            <!-- These are high-conviction signals that get pushed to Discord -->
            <div class="mobile-card" id="alertedSignalsCard" style="margin-bottom: 12px;">
                <div class="card-header">
                    <h2 class="card-title" style="font-size: 14px; display: flex; align-items: center; gap: 8px;">
                        <i data-lucide="bell-ring" style="width: 16px; height: 16px; color: var(--accent-positive);"></i>
                        Alerted Trade Signals
                    </h2>
                    <span class="card-badge" id="alertedSignalCount" style="background: rgba(16, 185, 129, 0.2); color: var(--accent-positive);">
                        0
                    </span>
                </div>
                <div style="font-size: 10px; color: var(--text-secondary); margin-bottom: 10px; padding: 0 2px;">
                    High-conviction signals that crossed the alert threshold
                </div>
                <div id="alertedSignalsList">
                    <!-- Alerted signals will be populated here -->
                </div>
            </div>
            <!-- Trade Ideas -->
            <div class="mobile-card">
                <div class="card-header">
                    <h2 class="card-title" style="font-size: 14px;">Trade Ideas</h2>
                </div>
                <div id="signalsList">
                    <!-- Signals will be populated here -->
                </div>
            </div>
        </div>

        <!-- Alpha Tab -->
        <div class="tab-content" id="alphaTab">
            <!-- Alpha Pulse Native Widget -->
            <div class="mobile-card" style="padding: 0; overflow: hidden;">
                <div class="card-header" style="padding: 12px 16px; border-bottom: 1px solid var(--border-light);">
                    <h2 class="card-title" style="display: flex; align-items: center; gap: 8px;">
                        <i data-lucide="activity" style="width: 18px; height: 18px; color: var(--neon-amber);"></i>
                        Alpha Pulse
                    </h2>
                    <span id="momentumWavesCount" class="card-badge" style="background: rgba(255, 191, 0, 0.15); color: var(--neon-amber);">
                        0
                    </span>
                </div>
                <div id="momentumWavesContainer" class="momentum-waves-container">
                    <!-- Momentum cards will be populated here by JavaScript -->
                    <div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: var(--text-muted);">
                        <div class="spinner" style="width: 24px; height: 24px; margin: 0 auto 12px;"></div>
                        <div style="font-size: 12px;">Loading momentum data...</div>
                    </div>
                </div>
            </div>

            <!-- Alpha Scores - COMMENTED OUT (Legacy: Confluence Scores)
            <div class="mobile-card">
                <div class="card-header">
                    <h2 class="card-title">Alpha Scores</h2>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span class="card-badge" id="symbolsCount" style="background: rgba(255, 191, 0, 0.2); color: var(--text-primary);">
                            0
                        </span>
                        <select id="sortSelector" style="background: var(--bg-secondary); border: 1px solid var(--border-light); border-radius: 6px; padding: 6px 12px; color: var(--text-primary); font-size: 12px;" onchange="sortSymbols()">
                            <option value="score">Sort by Score</option>
                            <option value="change">Sort by Change</option>
                            <option value="volume">Sort by Volume</option>
                            <option value="symbol">Sort by Symbol</option>
                        </select>
                    </div>
                </div>

                <div class="symbols-grid scroll-indicator-container" id="confluenceScrollContainer" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(170px, 1fr)); gap: 16px; padding: 4px;">
                    <div id="analyzedSymbolsList">
                        <div class="loading" style="text-align: center; padding: 40px; grid-column: 1 / -1;">
                            <div class="spinner" style="width: 32px; height: 32px; margin: 0 auto;"></div>
                        </div>
                    </div>
                </div>
                <div class="scroll-hint" id="confluenceScrollHint">
                    <i data-lucide="chevrons-down" style="width: 14px; height: 14px;"></i>
                    <span>Scroll for more</span>
                </div>
            </div>
            END Alpha Scores -->

            <!-- Alpha Opportunities - COMMENTED OUT
            <div class="mobile-card">
                <div class="card-header">
                    <h2 class="card-title">Alpha Opportunities</h2>
                    <span class="card-badge" style="background: rgba(76, 175, 80, 0.2); color: var(--accent-positive);">
                        ALPHA
                    </span>
                </div>
                <div id="alphaList">
                </div>
            </div>
            END Alpha Opportunities -->
        </div>

        <!-- Alerts Tab -->
        <div class="tab-content" id="alertsTab">
            <div class="mobile-card">
                <div class="card-header">
                    <h2 class="card-title">Recent Alerts</h2>
                    <span class="card-badge" id="alertCount" style="background: rgba(244, 67, 54, 0.2); color: var(--accent-negative);">
                        0
                    </span>
                </div>
                <!-- Alert Filter Pills -->
                <div id="alertFilters" style="display: flex; gap: 8px; padding: 0 0 12px 0; overflow-x: auto; -webkit-overflow-scrolling: touch; align-items: center;">
                    <button class="alert-filter-pill active" data-filter="all" onclick="filterAlerts('all')">
                        <i data-lucide="layers" style="width: 12px; height: 12px; flex-shrink: 0;"></i>
                        <span>All</span>
                    </button>
                    <button class="alert-filter-pill" data-filter="whale_trade" onclick="filterAlerts('whale_trade')">
                        <i data-lucide="fish" style="width: 12px; height: 12px; flex-shrink: 0;"></i>
                        <span>Whales</span>
                    </button>
                    <button class="alert-filter-pill" data-filter="liquidation_cascade" onclick="filterAlerts('liquidation_cascade')">
                        <i data-lucide="droplets" style="width: 12px; height: 12px; flex-shrink: 0;"></i>
                        <span>Liqs</span>
                    </button>
                    <button class="alert-filter-pill" data-filter="signal" onclick="filterAlerts('signal')">
                        <i data-lucide="target" style="width: 12px; height: 12px; flex-shrink: 0;"></i>
                        <span>Signals</span>
                    </button>
                    <button class="alert-filter-pill" data-filter="regime_change" onclick="filterAlerts('regime_change')">
                        <i data-lucide="activity" style="width: 12px; height: 12px; flex-shrink: 0;"></i>
                        <span>Regime</span>
                    </button>
                </div>
                <div id="alertsList">
                    <!-- Alerts will be populated here -->
                </div>
            </div>
        </div>

        <!-- Crypto Performance Tracker Tab -->
        <div class="tab-content" id="performanceTab">
            <!-- Performance Controls -->
            <!-- Bitcoin Beta Chart with Timeframe Controls -->
            <div class="mobile-card" id="betaChartCard">
                <div class="card-header" style="display: flex; justify-content: space-between; align-items: center;">
                    <h2 class="card-title"><span id="chartTimeframeLabel">4H</span> Bitcoin Beta</h2>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <button id="fullscreenBtn" onclick="toggleChartFullscreen()" style="
                            padding: 8px;
                            background: rgba(251, 191, 36, 0.15);
                            border: 1px solid rgba(251, 191, 36, 0.4);
                            border-radius: 6px;
                            color: #fbbf24;
                            cursor: pointer;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            transition: all 0.2s ease;
                            min-width: 40px;
                            min-height: 40px;
                        " onmouseover="this.style.background='rgba(251, 191, 36, 0.25)'" onmouseout="this.style.background='rgba(251, 191, 36, 0.15)'">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
                            </svg>
                        </button>
                    </div>
                </div>

                <!-- Timeframe & Auto-Refresh Controls -->
                <div id="timeframeControlsWrapper" style="padding: 12px 0; border-bottom: 1px solid rgba(255,255,255,0.05);">
                    <!-- Horizontal Timeframe Chips (Perfect Grid Alignment) -->
                    <div id="timeframeScroller" style="
                        display: flex;
                        gap: 4px;
                        justify-content: space-between;
                        padding: 0 0 12px 0;
                        margin-bottom: 12px;
                        align-items: center;
                    ">
                        <button onclick="selectTimeframe(this, 0.0833)" class="tf-chip" data-tf="0.0833">5m</button>
                        <button onclick="selectTimeframe(this, 0.25)" class="tf-chip" data-tf="0.25">15m</button>
                        <button onclick="selectTimeframe(this, 0.5)" class="tf-chip" data-tf="0.5">30m</button>
                        <button onclick="selectTimeframe(this, 1)" class="tf-chip" data-tf="1">1H</button>
                        <button onclick="selectTimeframe(this, 4)" class="tf-chip tf-chip-active" data-tf="4">4H</button>
                        <button onclick="selectTimeframe(this, 12)" class="tf-chip" data-tf="12">12H</button>
                        <button onclick="selectTimeframe(this, 24)" class="tf-chip" data-tf="24">24H</button>
                    </div>

                    <!-- Auto-Refresh Status Row (Perfect Alignment) -->
                    <div style="
                        display: flex;
                        align-items: center;
                        justify-content: space-between;
                        gap: 12px;
                        height: 28px;
                    ">
                        <div style="
                            display: flex;
                            align-items: center;
                            gap: 8px;
                            flex-grow: 1;
                            min-width: 0;
                        ">
                            <span id="refreshIndicator" style="
                                width: 6px;
                                height: 6px;
                                border-radius: 50%;
                                background: var(--accent-positive);
                                animation: pulse 2s infinite;
                                flex-shrink: 0;
                            "></span>
                            <span style="
                                font-size: 10px;
                                color: var(--text-secondary);
                                font-family: 'IBM Plex Mono', monospace;
                                white-space: nowrap;
                                overflow: hidden;
                                text-overflow: ellipsis;
                                line-height: 1.4;
                            ">
                                <span id="refreshStatus" style="color: var(--accent-positive); font-weight: 600;">ON</span>
                                <span style="opacity: 0.6;"> · 2m · </span>
                                <span id="lastUpdated" style="color: var(--text-accent); font-weight: 500;">--:--</span>
                            </span>
                        </div>
                        <button onclick="toggleAutoRefresh()" id="refreshToggle" style="
                            padding: 6px 16px;
                            font-size: 10px;
                            font-family: 'IBM Plex Mono', monospace;
                            background: rgba(16, 185, 129, 0.15);
                            border: 1px solid var(--accent-positive);
                            border-radius: 6px;
                            color: var(--accent-positive);
                            cursor: pointer;
                            font-weight: 600;
                            min-height: 28px;
                            flex-shrink: 0;
                            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
                            line-height: 1;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                        ">ON</button>
                    </div>
                </div>
                <style>
                    /* ========================================
                       TIMEFRAME CHIP ANIMATION
                       ======================================== */
                    @keyframes pulse {
                        0%, 100% { opacity: 1; }
                        50% { opacity: 0.4; }
                    }

                    @keyframes glow-pulse {
                        0%, 100% {
                            box-shadow: 0 0 12px rgba(251, 191, 36, 0.3),
                                        0 0 4px rgba(251, 191, 36, 0.2) inset;
                        }
                        50% {
                            box-shadow: 0 0 16px rgba(251, 191, 36, 0.5),
                                        0 0 6px rgba(251, 191, 36, 0.3) inset;
                        }
                    }

                    /* ========================================
                       TIMEFRAME CHIP STYLES
                       Pixel-perfect alignment for all 7 chips
                       ======================================== */
                    .tf-chip {
                        /* Layout & Sizing */
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        padding: 0 8px;
                        min-height: 28px;
                        min-width: 40px;
                        flex: 1 1 0; /* Equal width distribution */

                        /* Typography */
                        font-size: 10px;
                        font-family: 'IBM Plex Mono', monospace;
                        font-weight: 600;
                        letter-spacing: 0.3px;
                        line-height: 1;
                        white-space: nowrap;

                        /* Visual Design */
                        background: rgba(255, 255, 255, 0.05);
                        border: 1px solid rgba(255, 255, 255, 0.1);
                        border-radius: 14px;
                        color: var(--text-secondary);

                        /* Behavior */
                        cursor: pointer;
                        user-select: none;
                        -webkit-tap-highlight-color: transparent;

                        /* Transitions */
                        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
                    }

                    /* Active State - Amber Glow */
                    .tf-chip-active {
                        background: linear-gradient(135deg,
                            rgba(251, 191, 36, 0.25) 0%,
                            rgba(251, 191, 36, 0.15) 100%
                        );
                        border: 1px solid #fbbf24;
                        color: #fbbf24;
                        font-weight: 700;
                        animation: glow-pulse 2s ease-in-out infinite;
                    }

                    /* Hover State (Desktop) */
                    @media (hover: hover) {
                        .tf-chip:not(.tf-chip-active):hover {
                            background: rgba(255, 255, 255, 0.08);
                            border-color: rgba(251, 191, 36, 0.4);
                            color: rgba(251, 191, 36, 0.9);
                            transform: translateY(-1px);
                        }
                    }

                    /* Touch Feedback */
                    .tf-chip:active {
                        transform: scale(0.95);
                    }

                    .tf-chip-active:active {
                        transform: scale(0.97);
                    }

                    /* Hide scrollbar (fallback for overflow) */
                    #timeframeScroller::-webkit-scrollbar {
                        display: none;
                    }

                    #timeframeScroller {
                        -ms-overflow-style: none;
                        scrollbar-width: none;
                    }

                    /* ========================================
                       FULLSCREEN TIMEFRAME CONTROLS
                       Compact chips below header
                       ======================================== */
                    .fullscreen-chart #timeframeControlsWrapper {
                        padding: 8px 16px 12px;
                        border-bottom: 1px solid rgba(255,255,255,0.05);
                        background: var(--bg-primary);
                    }

                    /* Hide auto-refresh status in fullscreen to save space */
                    .fullscreen-chart #timeframeControlsWrapper > div:last-child {
                        display: none !important;
                    }

                    /* Make chips slightly smaller in fullscreen for compact fit */
                    .fullscreen-chart .tf-chip {
                        min-height: 24px;
                        padding: 0 6px;
                        font-size: 9px;
                        min-width: 36px;
                    }

                    /* ========================================
                       RESPONSIVE ADJUSTMENTS
                       ======================================== */
                    @media (max-width: 360px) {
                        /* Tighter spacing for very small screens */
                        #timeframeScroller {
                            gap: 3px;
                        }

                        .tf-chip {
                            padding: 0 6px;
                            min-width: 36px;
                            font-size: 9px;
                        }
                    }

                    @media (min-width: 768px) {
                        /* More comfortable spacing on tablets */
                        #timeframeScroller {
                            gap: 8px;
                        }

                        .tf-chip {
                            padding: 0 12px;
                            min-width: 48px;
                            font-size: 11px;
                        }
                    }
                </style>
                <div id="performanceChart" style="width: 100%; height: 350px;">
                    <!-- Chart will be rendered here - skeleton loader -->
                    <div class="skeleton skeleton-chart" style="margin: 10px 0;"></div>
                </div>
                <!-- Chart Label Controls -->
                <div id="chartLabelControls" style="display: flex; gap: 8px; margin-top: 10px; justify-content: flex-end;">
                    <button id="toggleLabelsBtn" onclick="toggleChartLabels()" style="
                        padding: 6px 12px;
                        background: rgba(251, 191, 36, 0.15);
                        border: 1px solid rgba(251, 191, 36, 0.4);
                        border-radius: 6px;
                        color: #fbbf24;
                        font-family: 'IBM Plex Mono', monospace;
                        font-size: 10px;
                        cursor: pointer;
                        transition: all 0.2s ease;
                    " onmouseover="this.style.background='rgba(251, 191, 36, 0.25)'" onmouseout="this.style.background='rgba(251, 191, 36, 0.15)'">
                        <span id="toggleLabelsIcon">👁</span> LABELS: ON
                    </button>
                    <button id="toggleTopBottomBtn" onclick="toggleTopBottomOnly()" style="
                        padding: 6px 12px;
                        background: rgba(6, 182, 212, 0.15);
                        border: 1px solid rgba(6, 182, 212, 0.4);
                        border-radius: 6px;
                        color: #06b6d4;
                        font-family: 'IBM Plex Mono', monospace;
                        font-size: 10px;
                        cursor: pointer;
                        transition: all 0.2s ease;
                    " onmouseover="this.style.background='rgba(6, 182, 212, 0.25)'" onmouseout="this.style.background='rgba(6, 182, 212, 0.15)'">
                        TOP/BOTTOM 5: OFF
                    </button>
                </div>
                <!-- Collapsible Legend -->
                <div id="performanceChartLegend" style="margin-top: 12px;">
                    <!-- Legend will be rendered here -->
                </div>
            </div>

            <!-- Beta Performance (Combined Overview + Beta Analysis) -->
            <div class="mobile-card">
                <div class="card-header">
                    <h2 class="card-title">Beta Performance</h2>
                    <div style="display: flex; gap: 6px;">
                        <span id="timeframeBadge" class="card-badge" style="background: rgba(251, 191, 36, 0.2); color: var(--accent-warning);">
                            4H
                        </span>
                        <span class="card-badge" style="background: rgba(255, 191, 0, 0.2); color: var(--accent-warning);">
                            ₿
                        </span>
                    </div>
                </div>

                <!-- Performance Metrics -->
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; margin-bottom: 16px;">
                    <div class="overview-metric">
                        <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">BTC <span id="btcTimeframeLabel">4H</span> CHANGE</div>
                        <div id="perfBtcChange" style="font-size: 20px; font-weight: 700; color: var(--text-primary);">--</div>
                    </div>
                    <div class="overview-metric">
                        <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">SYMBOLS TRACKED</div>
                        <div id="perfSymbolCount" style="font-size: 20px; font-weight: 700; color: var(--text-primary);">--</div>
                    </div>
                    <div class="overview-metric">
                        <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">OUTPERFORMERS</div>
                        <div id="perfOutperformers" style="font-size: 20px; font-weight: 700; color: var(--accent-positive);">--</div>
                    </div>
                    <div class="overview-metric">
                        <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">UNDERPERFORMERS</div>
                        <div id="perfUnderperformers" style="font-size: 20px; font-weight: 700; color: var(--accent-negative);">--</div>
                    </div>
                </div>

                <!-- Divider -->
                <div style="height: 1px; background: linear-gradient(90deg, transparent, var(--border-light), transparent); margin: 16px 0;"></div>

                <!-- Beta Statistics -->
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; margin-bottom: 16px;">
                    <div class="overview-metric">
                        <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">BETA COEFFICIENT</div>
                        <div id="betaCoefficient" style="font-size: 20px; font-weight: 700; color: var(--text-primary);">--</div>
                    </div>
                    <div class="overview-metric">
                        <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">CORRELATION</div>
                        <div id="btcCorrelation" style="font-size: 20px; font-weight: 700; color: var(--text-primary);">--</div>
                    </div>
                    <div class="overview-metric">
                        <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">MARKET REGIME</div>
                        <div id="betaMarketRegime" style="font-size: 14px; font-weight: 600; padding: 4px 8px; border-radius: 6px; text-align: center; background: rgba(255, 191, 0, 0.1); color: var(--text-primary);">--</div>
                    </div>
                    <div class="overview-metric">
                        <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">VOLATILITY RATIO</div>
                        <div id="volatilityRatio" style="font-size: 20px; font-weight: 700; color: var(--text-primary);">--</div>
                    </div>
                </div>
            </div>

            <!-- Beta Rankings -->
            <div class="mobile-card">
                <div class="card-header" style="display: flex; justify-content: space-between; align-items: center; gap: 12px;">
                    <h2 class="card-title" style="margin: 0;">Beta Rankings</h2>
                    <select id="mtfClusterSelector" style="background: var(--bg-secondary); border: 1px solid var(--border-light); border-radius: 6px; padding: 6px 12px; color: var(--text-primary); font-size: 12px;" onchange="loadMTFRankings()">
                        <option value="day_trading">Day Trading</option>
                        <option value="scalping">Scalping</option>
                        <option value="swing_trading">Swing Trading</option>
                        <option value="comprehensive">Comprehensive</option>
                    </select>
                </div>
                <div id="mtfRankingsList" style="display: flex; flex-direction: column; gap: 8px;">
                    <!-- Beta rankings will be populated here -->
                    <div class="loading" style="text-align: center; padding: 40px;">
                        <div class="spinner" style="width: 32px; height: 32px; margin: 0 auto;"></div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Bottom Navigation -->
    <nav class="bottom-nav">
        <button class="nav-item active" onclick="switchTab('dashboard')">
            <i data-lucide="bar-chart-2" class="nav-icon"></i>
            <span class="nav-label">Market</span>
        </button>
        <button class="nav-item" onclick="switchTab('alpha')">
            <i data-lucide="trending-up" class="nav-icon"></i>
            <span class="nav-label">Alpha</span>
        </button>
        <button class="nav-item" onclick="switchTab('performance')">
            <span class="nav-icon" style="font-size: 20px; font-weight: 700;">₿</span>
            <span class="nav-label">Beta</span>
        </button>
        <button class="nav-item" onclick="switchTab('signals')">
            <i data-lucide="activity" class="nav-icon"></i>
            <span class="nav-label">Signals</span>
        </button>
        <button class="nav-item" onclick="switchTab('alerts')" id="alertsNavBtn">
            <i data-lucide="bell" class="nav-icon"></i>
            <span class="nav-label">Alerts</span>
            <span id="alertsBadge" class="notification-badge hidden">0</span>
        </button>
    </nav>

    <!-- Settings Panel -->
    <div id="settingsPanel" class="settings-panel" style="position: fixed; top: 0; right: -100%; width: 320px; height: 100vh; background: var(--bg-primary); border-left: 1px solid var(--border-light); z-index: 1000; transition: right 0.3s ease; overflow-y: auto;">
        <div class="settings-header" style="padding: 20px; border-bottom: 1px solid var(--border-light); display: flex; justify-content: space-between; align-items: center;">
            <h3 style="color: var(--text-primary); font-size: 18px; font-weight: 700; margin: 0;">Settings</h3>
            <button onclick="toggleSettings()" style="background: none; border: none; cursor: pointer;">
                <i data-lucide="x" style="width: 20px; height: 20px; color: var(--text-secondary);"></i>
            </button>
        </div>
        
        <div class="settings-content" style="padding: 20px;">
            <!-- Display Preferences -->
            <div class="settings-section" style="margin-bottom: 24px;">
                <h4 style="color: var(--text-primary); font-size: 14px; font-weight: 600; margin-bottom: 12px; text-transform: uppercase; letter-spacing: 0.5px;">Display</h4>
                
                <div class="setting-item" style="margin-bottom: 12px;">
                    <label style="display: flex; justify-content: space-between; align-items: center; color: var(--text-secondary); font-size: 13px;">
                        Auto Refresh
                        <select id="refreshRate" style="background: var(--bg-secondary); border: 1px solid var(--border-light); border-radius: 4px; padding: 4px 8px; color: var(--text-primary); font-size: 12px;" onchange="updateRefreshRate()">
                            <option value="0">Manual</option>
                            <option value="30000">30 seconds</option>
                            <option value="60000" selected>1 minute</option>
                            <option value="120000">2 minutes</option>
                            <option value="300000">5 minutes</option>
                        </select>
                    </label>
                </div>
                
                <div class="setting-item" style="margin-bottom: 12px;">
                    <label style="display: flex; justify-content: space-between; align-items: center; color: var(--text-secondary); font-size: 13px;">
                        Default Sort
                        <select id="defaultSort" style="background: var(--bg-secondary); border: 1px solid var(--border-light); border-radius: 4px; padding: 4px 8px; color: var(--text-primary); font-size: 12px;" onchange="updateDefaultSort()">
                            <option value="score" selected>Alpha Score</option>
                            <option value="change">Price Change</option>
                            <option value="symbol">Symbol Name</option>
                        </select>
                    </label>
                </div>
                
                <div class="setting-item" style="margin-bottom: 12px;">
                    <label style="display: flex; justify-content: space-between; align-items: center; color: var(--text-secondary); font-size: 13px;">
                        Symbols Limit
                        <select id="symbolsLimit" style="background: var(--bg-secondary); border: 1px solid var(--border-light); border-radius: 4px; padding: 4px 8px; color: var(--text-primary); font-size: 12px;" onchange="updateSymbolsLimit()">
                            <option value="10">10 symbols</option>
                            <option value="20" selected>20 symbols</option>
                            <option value="50">50 symbols</option>
                            <option value="100">All symbols</option>
                        </select>
                    </label>
                </div>

                <div class="setting-item" style="margin-bottom: 12px;">
                    <label style="display: flex; justify-content: space-between; align-items: center; color: var(--text-secondary); font-size: 13px;">
                        Show News Ticker
                        <input type="checkbox" id="showNewsTicker" checked style="accent-color: var(--accent-primary);" onchange="toggleNewsTicker()">
                    </label>
                </div>
            </div>

            <!-- Alert Settings -->
            <div class="settings-section" style="margin-bottom: 24px;">
                <h4 style="color: var(--text-primary); font-size: 14px; font-weight: 600; margin-bottom: 12px; text-transform: uppercase; letter-spacing: 0.5px;">Alerts</h4>
                
                <div class="setting-item" style="margin-bottom: 12px;">
                    <label style="display: flex; justify-content: space-between; align-items: center; color: var(--text-secondary); font-size: 13px;">
                        Min Alpha Score
                        <select id="minConfluence" style="background: var(--bg-secondary); border: 1px solid var(--border-light); border-radius: 4px; padding: 4px 8px; color: var(--text-primary); font-size: 12px;" onchange="updateMinConfluence()">
                            <option value="50">50+</option>
                            <option value="60">60+</option>
                            <option value="70" selected>70+</option>
                            <option value="80">80+</option>
                        </select>
                    </label>
                </div>
                
                <div class="setting-item" style="margin-bottom: 12px;">
                    <label style="display: flex; justify-content: space-between; align-items: center; color: var(--text-secondary); font-size: 13px;">
                        Sound Alerts
                        <input type="checkbox" id="soundAlerts" style="accent-color: var(--accent-primary);" onchange="updateSoundAlerts()">
                    </label>
                </div>
            </div>
            
            <!-- Dashboard Cards -->
            <div class="settings-section" style="margin-bottom: 24px;">
                <h4 style="color: var(--text-primary); font-size: 14px; font-weight: 600; margin-bottom: 12px; text-transform: uppercase; letter-spacing: 0.5px;">Visible Cards</h4>
                
                <div class="setting-item" style="margin-bottom: 8px;">
                    <label style="display: flex; justify-content: space-between; align-items: center; color: var(--text-secondary); font-size: 13px;">
                        Market Overview
                        <input type="checkbox" id="showMarketOverview" checked style="accent-color: var(--accent-primary);" onchange="toggleCard('marketOverview')">
                    </label>
                </div>
                
                <div class="setting-item" style="margin-bottom: 8px;">
                    <label style="display: flex; justify-content: space-between; align-items: center; color: var(--text-secondary); font-size: 13px;">
                        Top Movers
                        <input type="checkbox" id="showTopMovers" checked style="accent-color: var(--accent-primary);" onchange="toggleCard('topMovers')">
                    </label>
                </div>
            </div>

            <!-- Actions -->
            <div class="settings-section">
                <button onclick="resetSettings()" style="width: 100%; background: var(--bg-secondary); border: 1px solid var(--border-light); border-radius: 8px; padding: 12px; color: var(--text-primary); font-size: 13px; cursor: pointer; margin-bottom: 12px;">
                    Reset to Defaults
                </button>
                <button onclick="exportSettings()" style="width: 100%; background: var(--accent-primary); border: none; border-radius: 8px; padding: 12px; color: white; font-size: 13px; cursor: pointer;">
                    Export Settings
                </button>
            </div>

            <!-- Help Link -->
            <div class="settings-section" style="margin-top: 24px; padding-top: 16px; border-top: 1px solid var(--border-light);">
                <a href="https://virtuosocrypto.com/academy/dash101" target="_blank" rel="noopener noreferrer" style="display: flex; align-items: center; justify-content: center; gap: 8px; color: var(--accent-warning); text-decoration: none; font-size: 13px; font-weight: 600; padding: 10px; border-radius: 8px; transition: all 0.2s ease; background: rgba(251, 191, 36, 0.08);" onmouseover="this.style.background='rgba(251, 191, 36, 0.15)'" onmouseout="this.style.background='rgba(251, 191, 36, 0.08)'">
                    <i data-lucide="book-open" style="width: 16px; height: 16px;"></i>
                    Dashboard Guide
                    <i data-lucide="external-link" style="width: 14px; height: 14px; opacity: 0.7;"></i>
                </a>
            </div>
        </div>
    </div>
    
    <!-- Settings Overlay -->
    <div id="settingsOverlay" class="settings-overlay" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.5); z-index: 999; opacity: 0; visibility: hidden; transition: all 0.3s ease;" onclick="toggleSettings()"></div>

    <script>
        // Initialize Lucide icons - wrapped in try-catch to prevent breaking the app if CDN fails
        try {
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            } else {
                console.warn('Lucide not loaded yet, icons will be initialized later');
            }
        } catch (e) {
            console.warn('Lucide icon initialization failed:', e);
        }

        // Tab switching
        function switchTab(tabName) {
            // Update nav items
            document.querySelectorAll('.nav-item').forEach(item => {
                item.classList.remove('active');
            });

            // Find and activate the clicked nav item
            const navItems = document.querySelectorAll('.nav-item');
            navItems.forEach(item => {
                const onclick = item.getAttribute('onclick');
                if (onclick && onclick.includes(`'${tabName}'`)) {
                    item.classList.add('active');
                }
            });

            // Update content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(tabName + 'Tab').classList.add('active');

            // Clear alert badge when viewing alerts tab
            if (tabName === 'alerts') {
                // Mark current time as last seen to clear badge
                lastSeenAlertTimestamp = Math.floor(Date.now() / 1000);
                localStorage.setItem('lastSeenAlertTimestamp', lastSeenAlertTimestamp.toString());
                updateAlertBadge(0);
            }

            // Load tab-specific data
            loadTabData(tabName);
        }

        // Navigate to Alerted Signals section in Signals tab
        function navigateToAlertedSignals() {
            // Switch to Signals tab
            switchTab('signals');

            // Scroll to the Alerted Signals card after a brief delay for tab switch
            setTimeout(() => {
                const alertedCard = document.getElementById('alertedSignalsCard');
                if (alertedCard && alertedCard.style.display !== 'none') {
                    alertedCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    // Add a brief highlight effect
                    alertedCard.style.boxShadow = '0 0 0 2px var(--accent-positive)';
                    setTimeout(() => {
                        alertedCard.style.boxShadow = '';
                    }, 1500);
                }
            }, 100);
        }

        // Load tab data
        function loadTabData(tabName) {
            switch(tabName) {
                case 'dashboard':
                    loadDashboardData();
                    break;
                case 'signals':
                    loadSignalsData();
                    break;
                case 'alpha':
                    loadAlphaData();
                    break;
                case 'alerts':
                    loadAlertsData();
                    break;
                case 'performance':
                    loadPerformanceData();
                    loadBetaData();
                    loadMTFRankings();
                    break;
            }
        }

        // Performance-optimized pull to refresh
        let startY = 0;
        let isPulling = false;
        let rafId = null;
        const pullToRefresh = document.getElementById('pullToRefresh');
        const mainContent = document.querySelector('.main-content');

        // Use passive event listeners for better performance
        mainContent.addEventListener('touchstart', (e) => {
            if (window.scrollY === 0) {
                startY = e.touches[0].pageY;
                isPulling = true;
            }
        }, { passive: true });

        mainContent.addEventListener('touchmove', (e) => {
            if (!isPulling) return;
            
            // Cancel previous animation frame
            if (rafId) {
                cancelAnimationFrame(rafId);
            }
            
            rafId = requestAnimationFrame(() => {
                const currentY = e.touches[0].pageY;
                const pullDistance = currentY - startY;
                
                if (pullDistance > 0 && pullDistance < 100) {
                    pullToRefresh.classList.add('active');
                    // Use transform for better performance
                    pullToRefresh.style.transform = `translate3d(0, ${Math.min(pullDistance - 60, 0)}px, 0)`;
                }
            });
        }, { passive: true });

        mainContent.addEventListener('touchend', () => {
            if (rafId) {
                cancelAnimationFrame(rafId);
                rafId = null;
            }
            if (isPulling && pullToRefresh.classList.contains('active')) {
                refreshData();
            }
            isPulling = false;
            pullToRefresh.classList.remove('active');
            pullToRefresh.style.transform = '';
        }, { passive: true });

        // Data validation helper functions
        function safeExtractValue(data, fallback = '', debug = false) {
            if (debug) console.log('Extracting value from:', data);
            
            if (data === null || data === undefined) return fallback;
            
            // If it's already a primitive value
            if (typeof data === 'string' || typeof data === 'number' || typeof data === 'boolean') {
                return String(data).replace(/[{}",]/g, '').trim();
            }
            
            // If it's an object, try to extract meaningful value
            if (typeof data === 'object') {
                // Try common property names for regime/status
                if (data.regime) return String(data.regime).replace(/[{}",]/g, '').trim();
                if (data.status) return String(data.status).replace(/[{}",]/g, '').trim();
                if (data.value) return String(data.value).replace(/[{}",]/g, '').trim();
                
                // Get first non-null value from object
                const values = Object.values(data).filter(v => v !== null && v !== undefined);
                if (values.length > 0) {
                    return String(values[0]).replace(/[{}",]/g, '').trim();
                }
            }
            
            return fallback;
        }

        // Perpetuals Pulse - Fetch and Update from crypto-perps-tracker
        async function fetchPerpetualsPulse() {
            try {
                // Proxy through Virtuoso API to avoid CORS issues
                // The API endpoint proxies to perps-tracker on port 8050
                const response = await fetch('/api/dashboard/perpetuals-pulse');

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const data = await response.json();
                console.log('[PERPS] Received data:', data);

                if (data.status === 'success') {
                    updatePerpetualsPulse(data);
                } else {
                    console.warn('[PERPS] API returned non-success:', data);
                }
            } catch (error) {
                console.error('[PERPS] Failed to fetch perpetuals pulse:', error);
                // Show error state but don't hide the card
                document.getElementById('perpsLoadingState').style.display = 'none';
            }
        }

        function updatePerpetualsPulse(data) {
            // === FUNDING RATE ===
            const fundingRate = data.funding_rate || 0;
            const fundingEl = document.getElementById('perpsFundingRate');
            const fundingSentimentEl = document.getElementById('perpsFundingSentiment');

            fundingEl.textContent = (fundingRate >= 0 ? '+' : '') + fundingRate.toFixed(4) + '%';

            // Color based on sentiment
            if (fundingRate > 0.02) {
                fundingEl.style.color = 'var(--accent-positive)';
            } else if (fundingRate < -0.02) {
                fundingEl.style.color = 'var(--accent-negative)';
            } else {
                fundingEl.style.color = 'var(--text-primary)';
            }

            fundingSentimentEl.textContent = data.funding_sentiment || 'NEUTRAL';
            if (data.funding_strength && data.funding_strength !== 'WEAK') {
                fundingSentimentEl.textContent += ' (' + data.funding_strength + ')';
            }

            // === LONG/SHORT RATIO ===
            const longPct = data.long_pct || 50;
            const shortPct = data.short_pct || 50;

            document.getElementById('perpsLongPct').textContent = longPct.toFixed(0) + '%';
            document.getElementById('perpsShortPct').textContent = shortPct.toFixed(0) + '%';

            const lsLabelEl = document.getElementById('perpsLSLabel');
            if (longPct > 55) {
                lsLabelEl.textContent = 'LONGS HEAVY';
                lsLabelEl.style.color = 'var(--accent-positive)';
            } else if (shortPct > 55) {
                lsLabelEl.textContent = 'SHORTS HEAVY';
                lsLabelEl.style.color = 'var(--accent-negative)';
            } else {
                lsLabelEl.textContent = 'BALANCED';
                lsLabelEl.style.color = 'var(--text-secondary)';
            }

            // === BASIS STATUS ===
            const basisStatus = data.basis_status || 'NEUTRAL';
            const basisPct = data.basis_pct || 0;
            const basisStatusEl = document.getElementById('perpsBasisStatus');
            const basisPctEl = document.getElementById('perpsBasisPct');

            basisStatusEl.textContent = basisStatus;
            basisPctEl.textContent = (basisPct >= 0 ? '+' : '') + basisPct.toFixed(3) + '%';

            if (basisStatus === 'CONTANGO') {
                basisStatusEl.style.background = 'rgba(76, 175, 80, 0.2)';
                basisStatusEl.style.color = 'var(--accent-positive)';
            } else if (basisStatus === 'BACKWARDATION') {
                basisStatusEl.style.background = 'rgba(244, 67, 54, 0.2)';
                basisStatusEl.style.color = 'var(--accent-negative)';
            } else {
                basisStatusEl.style.background = 'rgba(255, 191, 0, 0.15)';
                basisStatusEl.style.color = 'var(--text-primary)';
            }

            // === OPEN INTEREST & VOLUME ===
            const oi = data.total_open_interest || 0;
            const vol = data.total_volume_24h || 0;

            document.getElementById('perpsOpenInterest').textContent = formatMarketCap(oi);
            document.getElementById('perpsVolume').textContent = formatMarketCap(vol);

            // === CEX/DEX DISTRIBUTION ===
            const cexPct = data.cex_pct || 90;
            const dexPct = data.dex_pct || 10;

            const cexBar = document.getElementById('perpsCexBar');
            const dexBar = document.getElementById('perpsDexBar');

            cexBar.style.width = cexPct + '%';
            cexBar.querySelector('span').textContent = 'CEX ' + cexPct.toFixed(0) + '%';
            dexBar.querySelector('span').textContent = dexPct.toFixed(0) + '%';

            // === EXCHANGE COUNT ===
            const exchangeCount = data.exchange_count || 8;
            document.getElementById('perpsExchangeCount').textContent = exchangeCount + ' CEX/DEX';

            // === PHASE 2: ADVANCED METRICS ===
            // Funding Z-Score
            const fundingZScore = data.funding_zscore || 0;
            const fundingZScoreEl = document.getElementById('perpsFundingZScore');
            fundingZScoreEl.textContent = (fundingZScore > 0 ? '+' : '') + fundingZScore.toFixed(2) + 'σ';

            if (fundingZScore > 0) {
                fundingZScoreEl.style.color = 'var(--accent-negative)';
            } else if (fundingZScore < 0) {
                fundingZScoreEl.style.color = 'var(--accent-positive)';
            } else {
                fundingZScoreEl.style.color = 'var(--text-secondary)';
            }

            // L/S Entropy (Health)
            const lsEntropy = data.ls_entropy || 0.5;
            const lsEntropyEl = document.getElementById('perpsLSEntropy');
            lsEntropyEl.textContent = (lsEntropy * 100).toFixed(0) + '%';

            if (lsEntropy >= 0.7) {
                lsEntropyEl.style.color = 'var(--accent-positive)';
            } else if (lsEntropy < 0.4) {
                lsEntropyEl.style.color = 'var(--accent-negative)';
            } else {
                lsEntropyEl.style.color = 'var(--text-secondary)';
            }

            // === PHASE 2: ACTIVE SIGNALS ===
            const signals = data.signals || [];
            const signalCount = data.signal_count || 0;
            const signalsContainer = document.getElementById('perpsSignalsContainer');
            const signalsList = document.getElementById('perpsSignalsList');

            if (signalCount > 0 && signals.length > 0) {
                signalsContainer.style.display = 'block';
                signalsList.innerHTML = '';

                signals.forEach(signal => {
                    const pill = document.createElement('div');
                    pill.className = `signal-pill-mobile ${signal.direction} ${signal.strength}`;

                    const signalTypeMap = {
                        'funding_divergence': 'Funding Div',
                        'ls_extreme': 'L/S Extreme',
                        'liquidation_risk': 'Liq Risk',
                        'momentum': 'Momentum'
                    };

                    const label = signalTypeMap[signal.signal_type] || signal.signal_type.replace(/_/g, ' ');
                    const strengthBadge = signal.strength.charAt(0).toUpperCase();

                    pill.innerHTML = `<span>${label}</span><span style="opacity: 0.7; font-size: 10px;">${strengthBadge}</span>`;
                    pill.title = `${signal.description} (confidence: ${(signal.confidence * 100).toFixed(0)}%)`;

                    signalsList.appendChild(pill);
                });
            } else {
                signalsContainer.style.display = 'none';
            }

            console.log('[PERPS] UI updated successfully with Phase 2 data');
        }

        // Market breadth update function
        function updateMarketBreadth(upCount, downCount) {
            const total = upCount + downCount;
            
            // Handle case when no data available
            if (total === 0) {
                document.getElementById('marketLabel').textContent = 'No Data';
                document.getElementById('upCount').textContent = '0';
                document.getElementById('downCount').textContent = '0';
                document.getElementById('bullSection').style.width = '50%';
                document.getElementById('bullSection').textContent = '50%';
                document.getElementById('bearSection').style.width = '50%';
                document.getElementById('bearSection').textContent = '50%';
                return;
            }
            
            const bullPercent = Math.round((upCount / total) * 100);
            const bearPercent = 100 - bullPercent;
            
            // Update visual elements
            document.getElementById('bullSection').style.width = bullPercent + '%';
            document.getElementById('bullSection').textContent = bullPercent + '%';
            document.getElementById('bearSection').style.width = bearPercent + '%';
            document.getElementById('bearSection').textContent = bearPercent + '%';
            document.getElementById('upCount').textContent = upCount;
            document.getElementById('downCount').textContent = downCount;
            
            // Update icon and label based on sentiment
            const iconContainer = document.getElementById('marketIcon');
            const label = document.getElementById('marketLabel');
            
            if (bullPercent > 60) {
                iconContainer.className = 'market-icon bullish';
                iconContainer.innerHTML = '<i data-lucide="trending-up" style="width: 24px; height: 24px;"></i>';
                iconContainer.style.background = 'rgba(76, 175, 80, 0.2)';
                iconContainer.style.color = 'var(--accent-positive)';
                label.textContent = 'Bulls Leading';
            } else if (bullPercent < 40) {
                iconContainer.className = 'market-icon bearish';
                iconContainer.innerHTML = '<i data-lucide="trending-down" style="width: 24px; height: 24px;"></i>';
                iconContainer.style.background = 'rgba(244, 67, 54, 0.2)';
                iconContainer.style.color = 'var(--accent-negative)';
                label.textContent = 'Bears Leading';
            } else {
                iconContainer.className = 'market-icon neutral';
                iconContainer.innerHTML = '<i data-lucide="minus" style="width: 24px; height: 24px;"></i>';
                iconContainer.style.background = 'rgba(255, 191, 0, 0.1)';
                iconContainer.style.color = 'var(--text-primary)';
                label.textContent = 'Market Balanced';
            }
            
            // Re-initialize Lucide icons for the new elements
            try { if (typeof lucide !== 'undefined') lucide.createIcons(); } catch(e) {}
        }

        // Update dashboard with overview data (signals, opportunities)
        function updateDashboard(data) {
            console.log('[DEBUG] updateDashboard called with keys:', Object.keys(data || {}));

            // Update signals if available
            if (data.signals && Array.isArray(data.signals)) {
                updateSignals({ signals: data.signals });
            }

        }

        // Data loading functions
        async function loadDashboardData() {
            console.log('[DEBUG] loadDashboardData() called at', new Date().toISOString());
            try {
                console.log('[DEBUG] Starting individual fetches...');

                // Fetch each endpoint individually with logging
                const fetchWithLog = async (url) => {
                    const start = Date.now();
                    console.log('[DEBUG] Fetching:', url);
                    try {
                        const resp = await fetch(url);
                        console.log('[DEBUG] ✓', url, '- Status:', resp.status, 'Time:', Date.now() - start, 'ms');
                        return resp;
                    } catch (e) {
                        console.error('[DEBUG] ✗', url, '- Error:', e.message);
                        throw e;
                    }
                };

                // Load summary, symbols, market overview, and movers data
                const [summaryResponse, symbolsResponse, marketResponse, mobileDataResponse] = await Promise.all([
                    fetchWithLog('/api/dashboard/overview'),
                    fetchWithLog('/api/dashboard/symbols'),
                    fetchWithLog('/api/dashboard/market-overview'),
                    fetchWithLog('/api/dashboard/mobile-data')
                ]);
                console.log('[DEBUG] All fetches completed!');

                const summaryData = await summaryResponse.json();
                const symbolsData = await symbolsResponse.json();
                const marketData = await marketResponse.json();
                const mobileData = await mobileDataResponse.json();
                console.log('[DEBUG] All JSON parsed successfully');
                console.log('[DEBUG] mobileData.market_overview:', JSON.stringify(mobileData.market_overview).substring(0, 200));

                // DEBUG: Log all data sources
                console.log('[DEBUG] ====== DATA SOURCES ======');
                console.log('[DEBUG] summaryData keys:', Object.keys(summaryData));
                console.log('[DEBUG] summaryData.opportunities:', summaryData.opportunities?.length || 0, 'items');
                console.log('[DEBUG] mobileData.opportunities:', mobileData.opportunities?.length || 0, 'items');
                if (summaryData.opportunities?.length > 0) {
                    console.log('[DEBUG] First opportunity from summaryData:', JSON.stringify(summaryData.opportunities[0]));
                }
                if (mobileData.opportunities?.length > 0) {
                    console.log('[DEBUG] First opportunity from mobileData:', JSON.stringify(mobileData.opportunities[0]));
                }
                console.log('[DEBUG] ============================');

                updateDashboard(summaryData);
                updateSymbols(symbolsData);

                // FIX: Check if mobile-data has REAL data (not cache warmer zeros)
                // Fallback to market-overview endpoint which has real values
                const mo = mobileData.market_overview || {};
                const hasRealMobileData = mobileData.status === 'success' &&
                    mo &&
                    (mo.trend_strength > 0 || mo.gainers > 0 || mo.losers > 0 || mo.total_market_cap > 0);

                console.log('[DEBUG] Mobile data check:', { hasRealMobileData, mo_trend: mo.trend_strength, mo_gainers: mo.gainers, mo_regime: mo.market_regime });

                if (hasRealMobileData) {
                    console.log('[DEBUG] Using mobile-data market_overview');
                    updateMarketOverview(mo);
                } else {
                    console.log('[DEBUG] Using market-overview endpoint (marketData)');
                    console.log('[DEBUG] marketData:', JSON.stringify(marketData).substring(0, 200));
                    updateMarketOverview(marketData);
                }

                // Use our new mobile-data endpoint for top movers
                if (mobileData.status === 'success') {
                    updateTopMovers(mobileData.top_movers);
                    // Update confluence scores if needed - filter out system status entries
                    if (mobileData.confluence_scores) {
                        console.log('Raw confluence scores:', mobileData.confluence_scores);
                        const validScores = mobileData.confluence_scores.filter(score =>
                            score &&
                            score.symbol &&
                            score.symbol !== 'SYSTEM_STATUS' &&
                            score.sentiment !== 'INITIALIZING' &&
                            !score.symbol.includes('SYSTEM')
                        );
                        console.log('Filtered valid scores:', validScores);
                        if (validScores.length > 0) {
                            updateSymbols({ symbols: validScores });
                            // Update native Momentum Waves widget
                            updateMomentumWaves(mobileData.confluence_scores);
                        } else {
                            // If no valid scores, show empty state
                            console.log('No valid confluence scores, showing empty state');
                            updateSymbols({ symbols: [] });
                        }
                    }
                }

                // Update price ticker with confluence scores data
                if (mobileData.confluence_scores) {
                    updatePriceTicker(mobileData.confluence_scores);
                }

                // Fetch Perpetuals Pulse data (separate from main data to avoid blocking)
                fetchPerpetualsPulse();

                // Final summary
                console.log('[DEBUG] ====== LOAD COMPLETE SUMMARY ======');
                console.log('[DEBUG] Signals in DOM:', document.getElementById('signalsList')?.children.length || 0);
                console.log('[DEBUG] Alerts in DOM:', document.getElementById('alertsList')?.children.length || 0);
                console.log('[DEBUG] Gainers in DOM:', document.getElementById('topGainersList')?.children.length || 0);
                console.log('[DEBUG] Losers in DOM:', document.getElementById('topLosersList')?.children.length || 0);
                console.log('[DEBUG] =====================================');
            } catch (error) {
                console.error('[DEBUG] ERROR in loadDashboardData:', error);
                console.error('[DEBUG] Stack trace:', error.stack);
                // Make error visible on page
                const errDiv = document.createElement('div');
                errDiv.style.cssText = 'position:fixed;top:0;left:0;right:0;background:red;color:white;padding:10px;z-index:9999;font-size:12px;';
                errDiv.textContent = 'JS Error: ' + error.message;
                document.body.prepend(errDiv);
            }
        }

        // Price Ticker Functions
        function updatePriceTicker(scores) {
            const tickerTrack = document.getElementById('tickerTrack');
            if (!tickerTrack || !scores || scores.length === 0) return;

            // Filter valid scores and sort by volume
            const validScores = scores.filter(s =>
                s && s.symbol && s.price &&
                s.symbol !== 'SYSTEM_STATUS' &&
                !s.symbol.includes('SYSTEM')
            ).sort((a, b) => (b.volume_24h || 0) - (a.volume_24h || 0));

            if (validScores.length === 0) return;

            // Create ticker items HTML
            const createTickerItem = (score) => {
                const symbol = score.symbol.replace('USDT', '');
                const price = parseFloat(score.price);
                const change = parseFloat(score.change_24h || 0);
                const changeClass = change >= 0 ? 'positive' : 'negative';
                const changePrefix = change >= 0 ? '+' : '';

                // Format price based on magnitude
                let priceStr;
                if (price >= 1000) priceStr = price.toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 });
                else if (price >= 1) priceStr = price.toFixed(2);
                else if (price >= 0.01) priceStr = price.toFixed(4);
                else priceStr = price.toFixed(6);

                return `
                    <div class="ticker-item">
                        <span class="ticker-symbol">${symbol}</span>
                        <span class="ticker-price">$${priceStr}</span>
                        <span class="ticker-change ${changeClass}">${changePrefix}${change.toFixed(1)}%</span>
                    </div>
                    <span class="ticker-separator">•</span>
                `;
            };

            // Generate ticker content (duplicate for seamless loop)
            const tickerContent = validScores.map(createTickerItem).join('');
            tickerTrack.innerHTML = tickerContent + tickerContent;

            // Adjust animation speed based on content width
            const contentWidth = tickerTrack.scrollWidth / 2;
            const speed = Math.max(10, contentWidth / 80); // ~80px per second (fast scan)
            tickerTrack.style.animationDuration = `${speed}s`;
        }

        async function loadSignalsData() {
            try {
                // Fetch trade-ready signals with entry/SL/TP levels
                const response = await fetch('/api/dashboard/trade-signals');
                const data = await response.json();
                updateTradeSignals(data);
            } catch (error) {
                console.error('Error loading trade signals data:', error);
                // Fallback to empty state
                updateTradeSignals({ signals: [], summary: {}, performance_24h: {} });
            }
        }


        async function loadAlphaData() {
            try {
                // Load both APIs in parallel for faster loading
                const [oppResponse, mobileResponse] = await Promise.all([
                    fetch('/api/dashboard/opportunities'),
                    fetch('/api/dashboard/mobile-data')
                ]);

                // Process opportunities
                const data = await oppResponse.json();
                const opportunities = Array.isArray(data) ? data : (data.opportunities || []);
                updateAlpha({ opportunities });

                // Process confluence scores
                const mobileData = await mobileResponse.json();
                if (mobileData.status === 'success' && mobileData.confluence_scores) {
                    const validScores = mobileData.confluence_scores.filter(score =>
                        score &&
                        score.symbol &&
                        score.symbol !== 'SYSTEM_STATUS' &&
                        score.sentiment !== 'INITIALIZING' &&
                        !score.symbol.includes('SYSTEM')
                    );
                    if (validScores.length > 0) {
                        updateSymbols({ symbols: validScores });
                        // Update native Momentum Waves widget
                        updateMomentumWaves(mobileData.confluence_scores);
                    }
                }
            } catch (error) {
                console.error('Error loading alpha data:', error);
            }
        }

        // =====================================================
        // ALERT NOTIFICATION SYSTEM
        // =====================================================

        // Notification state
        let lastSeenAlertTimestamp = parseInt(localStorage.getItem('lastSeenAlertTimestamp') || '0');
        let alertNotificationsEnabled = localStorage.getItem('alertNotifications') !== 'false';
        let alertSoundEnabled = localStorage.getItem('alertSound') !== 'false';
        let pushNotificationsEnabled = false;
        let unreadAlertCount = 0;

        // Create audio element for notification chime (simple 880Hz beep)
        const alertChime = new Audio('data:audio/wav;base64,UklGRl9vT19teleS0NSyeQ8ANZFgQ1LF4DgA1kdDTsHcNADSQz9KvdgwAM4/O0a51CwAyjs3QrXQKADGNzc+scgkAMIzMzqtxCAAvjMvNqnAHAC6Ly8ypbgYALYrKzKhtBQAricnLoWwEACuIyMmfawMAKofHyZ9pAgAphs');
        alertChime.volume = 0.3;

        // Fallback: Use Web Audio API for notification sound
        function playNotificationSound() {
            try {
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);

                oscillator.frequency.value = 880; // A5 note
                oscillator.type = 'sine';

                gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);

                oscillator.start(audioCtx.currentTime);
                oscillator.stop(audioCtx.currentTime + 0.3);
            } catch (e) {
                console.log('Audio playback not available:', e);
            }
        }

        // Request push notification permission
        async function requestNotificationPermission() {
            if (!('Notification' in window)) {
                console.log('Browser does not support notifications');
                return false;
            }

            if (Notification.permission === 'granted') {
                pushNotificationsEnabled = true;
                return true;
            }

            if (Notification.permission !== 'denied') {
                const permission = await Notification.requestPermission();
                pushNotificationsEnabled = permission === 'granted';
                return pushNotificationsEnabled;
            }

            return false;
        }

        // Show push notification
        function showPushNotification(title, body, icon = '🔔') {
            if (!pushNotificationsEnabled || Notification.permission !== 'granted') return;

            try {
                const notification = new Notification(title, {
                    body: body,
                    icon: '/static/img/logo.png',
                    badge: '/static/img/logo.png',
                    tag: 'virtuoso-alert',
                    renotify: true,
                    silent: false
                });

                notification.onclick = () => {
                    window.focus();
                    switchTab('alerts');
                    notification.close();
                };

                // Auto-close after 5 seconds
                setTimeout(() => notification.close(), 5000);
            } catch (e) {
                console.warn('Push notification failed:', e);
            }
        }

        // Play notification sound
        function playAlertSound() {
            if (!alertSoundEnabled) return;

            // Use Web Audio API for reliable notification sound
            playNotificationSound();
        }

        // Update badge count
        function updateAlertBadge(count) {
            const badge = document.getElementById('alertsBadge');
            if (!badge) return;

            unreadAlertCount = count;

            if (count > 0) {
                badge.textContent = count > 99 ? '99+' : count;
                badge.classList.remove('hidden');
            } else {
                badge.classList.add('hidden');
            }
        }

        // Mark alerts as seen (when user views alerts tab)
        function markAlertsAsSeen(alerts) {
            if (!alerts || alerts.length === 0) return;

            // Find the newest alert timestamp
            let newestTimestamp = 0;
            alerts.forEach(alert => {
                const ts = alert.unix_timestamp || (new Date(alert.timestamp).getTime() / 1000) || 0;
                if (ts > newestTimestamp) newestTimestamp = ts;
            });

            if (newestTimestamp > lastSeenAlertTimestamp) {
                lastSeenAlertTimestamp = newestTimestamp;
                localStorage.setItem('lastSeenAlertTimestamp', lastSeenAlertTimestamp.toString());
            }

            updateAlertBadge(0);
        }

        // Check if alert is important (warrants notification)
        function isImportantAlert(alert) {
            const alertType = alert.type || '';
            const details = alert.details || {};
            const message = alert.message || '';
            const level = alert.level || '';

            // 1. High confluence signals / trading signals
            if (alertType === 'high_confluence' || alertType === 'signal') {
                return true;
            }

            // 2. Massive liquidation cascades ($500K+)
            if (alertType === 'liquidation_cascade') {
                const totalValue = details.total_value || 0;
                return totalValue >= 500000;  // $500K minimum
            }

            // 3. Large whale trades ($1M+)
            if (alertType === 'whale_trade') {
                const tradeValue = details.data?.largest_trade_usd || details.total_value || 0;
                return tradeValue >= 1000000;  // $1M minimum
            }

            // 4. Critical level alerts
            if (level === 'critical' || message.includes('🚨') || message.includes('CRITICAL')) {
                return true;
            }

            // 5. Significant regime changes (not minor ranging/sideways)
            if (alertType === 'regime_change') {
                const newRegime = (details.new_regime || '').toLowerCase();
                // Only notify for trend or volatility changes, not ranging/sideways
                return newRegime.includes('trend') || newRegime.includes('volatility');
            }

            return false;
        }

        // Check for new alerts and notify
        function checkForNewAlerts(alerts) {
            if (!alerts || alerts.length === 0) return;

            // Count all new alerts (for badge)
            let newAlertCount = 0;
            // Track important alerts (for sound/push)
            let importantNewAlerts = [];

            alerts.forEach(alert => {
                const ts = alert.unix_timestamp || (new Date(alert.timestamp).getTime() / 1000) || 0;
                if (ts > lastSeenAlertTimestamp) {
                    newAlertCount++;
                    // Only add to important list if it meets criteria
                    if (isImportantAlert(alert)) {
                        importantNewAlerts.push(alert);
                    }
                }
            });

            // Update badge for ALL new alerts
            updateAlertBadge(newAlertCount);

            // Only notify (sound + push) for IMPORTANT new alerts
            if (importantNewAlerts.length > 0 && !document.getElementById('alertsTab')?.classList.contains('active')) {
                // Play sound once for important alerts
                if (alertSoundEnabled) {
                    playAlertSound();
                }

                // Show push notification for the most important alert
                const newestImportant = importantNewAlerts.sort((a, b) =>
                    (b.unix_timestamp || 0) - (a.unix_timestamp || 0)
                )[0];

                if (pushNotificationsEnabled && newestImportant) {
                    const symbol = newestImportant.symbol || 'Market';
                    const alertType = newestImportant.type || 'Alert';
                    const typeLabel = alertType.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
                    showPushNotification(
                        `🔔 ${symbol} - ${typeLabel}`,
                        newestImportant.message || 'Important alert received',
                        '🔔'
                    );
                }
            }
        }

        // Initialize notification system
        function initNotifications() {
            // Request permission on first user interaction
            document.addEventListener('click', function initPushOnClick() {
                requestNotificationPermission();
                document.removeEventListener('click', initPushOnClick);
            }, { once: true });

            // Check for notification support
            if ('Notification' in window && Notification.permission === 'granted') {
                pushNotificationsEnabled = true;
            }
        }

        async function loadAlertsData() {
            try {
                const response = await fetch('/api/dashboard/alerts');
                const data = await response.json();
                // API returns array directly, wrap it for updateAlerts
                const alerts = Array.isArray(data) ? data : (data.alerts || []);

                // Check for new alerts and update badge/notifications
                checkForNewAlerts(alerts);

                // If alerts tab is active, mark as seen
                if (document.getElementById('alertsTab')?.classList.contains('active')) {
                    markAlertsAsSeen(alerts);
                }

                updateAlerts({ alerts });
            } catch (error) {
                console.error('Error loading alerts data:', error);
            }
        }

        // =====================================================
        // CRYPTO PERFORMANCE TRACKER FUNCTIONS (BYBIT DATA)
        // =====================================================

        // Performance tracker state
        let currentTimeframe = 4;  // Default to 4H (recommended for day trading)
        let perfAutoRefreshEnabled = true;
        let perfAutoRefreshInterval = null;
        const PERF_AUTO_REFRESH_MS = 120000;  // 2 minutes

        // Chip-based timeframe selector with auto-scroll
        function selectTimeframe(buttonEl, hours) {
            // Remove active state from all chips
            document.querySelectorAll('.tf-chip').forEach(btn => {
                btn.classList.remove('tf-chip-active');
            });

            // Add active state to clicked chip
            buttonEl.classList.add('tf-chip-active');

            // Auto-scroll selected chip to center
            const scroller = document.getElementById('timeframeScroller');
            if (scroller && buttonEl) {
                const chipOffset = buttonEl.offsetLeft - (scroller.offsetWidth / 2) + (buttonEl.offsetWidth / 2);
                scroller.scrollTo({ left: chipOffset, behavior: 'smooth' });
            }

            // Update timeframe label
            const timeframeLabels = {
                0.0833: '5m', 0.25: '15m', 0.5: '30m',
                1: '1H', 4: '4H', 12: '12H', 24: '24H'
            };
            const labelText = timeframeLabels[hours] || hours + 'H';
            const chartTimeframeLabel = document.getElementById('chartTimeframeLabel');
            if (chartTimeframeLabel) {
                chartTimeframeLabel.textContent = labelText;
            }

            // Call existing setTimeframe to fetch new data
            setTimeframe(hours);
        }

        // Timeframe selector (legacy - now called by selectTimeframe)
        function setTimeframe(hours) {
            currentTimeframe = hours;

            // Update button styles
            document.querySelectorAll('.tf-btn').forEach(btn => {
                const btnTf = parseFloat(btn.getAttribute('data-tf'));
                if (btnTf === hours) {
                    btn.style.background = 'rgba(251, 191, 36, 0.2)';
                    btn.style.borderColor = 'var(--accent-amber)';
                    btn.style.color = 'var(--accent-amber)';
                } else {
                    btn.style.background = 'var(--bg-secondary)';
                    btn.style.borderColor = 'var(--border-light)';
                    btn.style.color = 'var(--text-secondary)';
                }
            });

            // Update labels - format as minutes for sub-hour timeframes
            let tfLabel;
            if (hours < 1) {
                tfLabel = Math.round(hours * 60) + 'm';
            } else {
                tfLabel = hours + 'H';
            }
            const timeframeBadge = document.getElementById('timeframeBadge');
            const btcTimeframeLabel = document.getElementById('btcTimeframeLabel');
            const chartTimeframeLabel = document.getElementById('chartTimeframeLabel');

            if (timeframeBadge) timeframeBadge.textContent = tfLabel;
            if (btcTimeframeLabel) btcTimeframeLabel.textContent = tfLabel;
            if (chartTimeframeLabel) chartTimeframeLabel.textContent = tfLabel;

            // Save preference
            localStorage.setItem('perfTimeframe', hours);

            // Reset zoom state when changing timeframe (new data should fit-to-content)
            lwChartVisibleRange = null;

            // Reload data
            loadPerformanceData();
        }

        // Auto-refresh toggle for Performance tab
        function toggleAutoRefresh() {
            perfAutoRefreshEnabled = !perfAutoRefreshEnabled;

            const refreshStatus = document.getElementById('refreshStatus');
            const refreshToggle = document.getElementById('refreshToggle');
            const refreshIndicator = document.getElementById('refreshIndicator');

            if (perfAutoRefreshEnabled) {
                refreshStatus.textContent = 'ON';
                refreshStatus.style.color = 'var(--accent-positive)';
                refreshToggle.textContent = 'ON';
                refreshToggle.style.background = 'rgba(16, 185, 129, 0.2)';
                refreshToggle.style.borderColor = 'var(--accent-positive)';
                refreshToggle.style.color = 'var(--accent-positive)';
                refreshIndicator.style.background = 'var(--accent-positive)';
                refreshIndicator.style.animation = 'pulse 2s infinite';
                startPerfAutoRefresh();
            } else {
                refreshStatus.textContent = 'OFF';
                refreshStatus.style.color = 'var(--accent-negative)';
                refreshToggle.textContent = 'OFF';
                refreshToggle.style.background = 'rgba(239, 68, 68, 0.2)';
                refreshToggle.style.borderColor = 'var(--accent-negative)';
                refreshToggle.style.color = 'var(--accent-negative)';
                refreshIndicator.style.background = 'var(--accent-negative)';
                refreshIndicator.style.animation = 'none';
                stopPerfAutoRefresh();
            }

            localStorage.setItem('perfAutoRefresh', perfAutoRefreshEnabled);
        }

        // =====================================================
        // FULLSCREEN CHART FUNCTIONALITY
        // =====================================================

        function toggleChartFullscreen() {
            const card = document.getElementById('betaChartCard');
            const btn = document.getElementById('fullscreenBtn');
            const isFullscreen = card.classList.contains('fullscreen-chart');

            if (!isFullscreen) {
                // Enter fullscreen - hide everything except chart and exit button
                card.classList.add('fullscreen-chart');
                btn.innerHTML = `
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"></path>
                    </svg>
                `;
                // Hide bottom nav
                document.querySelector('.bottom-nav').style.display = 'none';

            } else {
                // Exit fullscreen - restore normal view
                card.classList.remove('fullscreen-chart');
                btn.innerHTML = `
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
                    </svg>
                `;
                // Show bottom nav
                document.querySelector('.bottom-nav').style.display = 'flex';
                // Restore chart height
                const chartContainer = document.getElementById('performanceChart');
                if (chartContainer) {
                    chartContainer.style.height = '350px';
                }
            }
        }

        function startPerfAutoRefresh() {
            if (perfAutoRefreshInterval) clearInterval(perfAutoRefreshInterval);
            perfAutoRefreshInterval = setInterval(() => {
                if (document.getElementById('performanceTab').style.display !== 'none') {
                    console.log('[PERFORMANCE] Auto-refreshing data...');
                    loadPerformanceData();
                }
            }, PERF_AUTO_REFRESH_MS);
        }

        function stopPerfAutoRefresh() {
            if (perfAutoRefreshInterval) {
                clearInterval(perfAutoRefreshInterval);
                perfAutoRefreshInterval = null;
            }
        }

        function updateLastUpdatedTime() {
            const now = new Date();
            const timeStr = now.toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
            const lastUpdated = document.getElementById('lastUpdated');
            if (lastUpdated) lastUpdated.textContent = timeStr;
        }

        // Initialize from localStorage on load
        function initPerformanceSettings() {
            const savedTf = localStorage.getItem('perfTimeframe');
            const savedAutoRefresh = localStorage.getItem('perfAutoRefresh');

            if (savedTf) {
                currentTimeframe = parseFloat(savedTf);
                // Update UI to match saved timeframe
                document.querySelectorAll('.tf-btn').forEach(btn => {
                    const btnTf = parseFloat(btn.getAttribute('data-tf'));
                    if (btnTf === currentTimeframe) {
                        btn.style.background = 'rgba(251, 191, 36, 0.2)';
                        btn.style.borderColor = 'var(--accent-amber)';
                        btn.style.color = 'var(--accent-amber)';
                    } else {
                        btn.style.background = 'var(--bg-secondary)';
                        btn.style.borderColor = 'var(--border-light)';
                        btn.style.color = 'var(--text-secondary)';
                    }
                });
                // Update labels - format as minutes for sub-hour timeframes
                let tfLabel;
                if (currentTimeframe < 1) {
                    tfLabel = Math.round(currentTimeframe * 60) + 'm';
                } else {
                    tfLabel = currentTimeframe + 'H';
                }
                const timeframeBadge = document.getElementById('timeframeBadge');
                const btcTimeframeLabel = document.getElementById('btcTimeframeLabel');
                const chartTimeframeLabel = document.getElementById('chartTimeframeLabel');
                if (timeframeBadge) timeframeBadge.textContent = tfLabel;
                if (btcTimeframeLabel) btcTimeframeLabel.textContent = tfLabel;
                if (chartTimeframeLabel) chartTimeframeLabel.textContent = tfLabel;
            }

            if (savedAutoRefresh === 'false') {
                perfAutoRefreshEnabled = true; // Set to true so toggle will turn it off
                toggleAutoRefresh(); // Toggle to false and update UI
            }
        }

        // Bybit symbol mapping for meme coins
        const BYBIT_SYMBOL_MAP = {
            'PEPE': '1000PEPEUSDT',
            'SHIB': '1000SHIBUSDT',
            'FLOKI': '1000FLOKIUSDT',
            'BONK': '1000BONKUSDT',
            'LUNC': '1000LUNCUSDT',
            'BABYDOGE': '1000000BABYDOGEUSDT',
            'SATS': '1000SATSUSDT',
            'RATS': '1000RATSUSDT',
            'CAT': '10000CATUSDT',
            'LADYS': '1000LADYSUSDT',
            'BTT': '1000000BTTUSDT',
            'XEC': '1000XECUSDT',
            'CHEEMS': '10000CHEEMSUSDT',
            'COQ': '1000000COQUSDT',
            'STARL': '10000STARLUSDT',
        };

        function normalizeSymbol(symbol) {
            symbol = symbol.toUpperCase();
            if (symbol.endsWith('USDT')) {
                symbol = symbol.slice(0, -4);
            } else if (symbol.endsWith('USD')) {
                symbol = symbol.slice(0, -3);
            }

            // Handle numeric prefixes
            for (const prefix of ['10000000', '1000000', '100000', '10000', '1000']) {
                if (symbol.startsWith(prefix)) {
                    return symbol.slice(prefix.length);
                }
            }
            return symbol;
        }

        async function fetchBybitTickers() {
            try {
                const response = await fetch('https://api.bybit.com/v5/market/tickers?category=linear', {
                    method: 'GET',
                    headers: { 'Accept': 'application/json' }
                });
                const data = await response.json();

                if (data.retCode !== 0) {
                    throw new Error(data.retMsg || 'Bybit API error');
                }

                const tickers = data.result.list
                    .filter(t => t.symbol.endsWith('USDT'))
                    .map(t => ({
                        symbol: t.symbol,
                        normalized: normalizeSymbol(t.symbol),
                        price: parseFloat(t.lastPrice) || 0,
                        volume_24h: parseFloat(t.turnover24h) || 0,
                        price_change_pct: (parseFloat(t.price24hPcnt) || 0) * 100
                    }))
                    .sort((a, b) => b.volume_24h - a.volume_24h);

                return tickers;
            } catch (error) {
                console.error('Error fetching Bybit tickers:', error);
                return [];
            }
        }

        async function fetchBybitKlines(symbol, interval = '60', limit = 12) {
            try {
                const url = 'https://api.bybit.com/v5/market/kline?category=linear&symbol=' + symbol + '&interval=' + interval + '&limit=' + limit;
                const response = await fetch(url);
                const data = await response.json();

                if (data.retCode !== 0) {
                    return [];
                }

                // Bybit returns newest first, reverse for chronological order
                const candles = data.result.list.reverse().map(k => ({
                    timestamp: parseInt(k[0]),
                    open: parseFloat(k[1]),
                    high: parseFloat(k[2]),
                    low: parseFloat(k[3]),
                    close: parseFloat(k[4]),
                    volume: parseFloat(k[5])
                }));

                return candles;
            } catch (error) {
                console.error('Error fetching klines for ' + symbol + ':', error);
                return [];
            }
        }

        async function fetchHistoricalDataBybit(symbols, limit = 12) {
            const historicalData = {};

            for (const symbol of symbols) {
                // Check if symbol needs special mapping
                const bybitSymbol = BYBIT_SYMBOL_MAP[symbol] || (symbol + 'USDT');
                const candles = await fetchBybitKlines(bybitSymbol, '60', limit);

                if (candles.length > 0) {
                    historicalData[symbol] = candles;
                }

                // Rate limiting
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            return historicalData;
        }

        async function loadPerformanceData() {
            console.log('[PERFORMANCE] Loading performance data from cached API...');

            try {
                // Fetch pre-computed data from our cached API endpoint
                const response = await fetch(`/api/dashboard/beta-chart?timeframe=${currentTimeframe}`);

                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }

                const apiData = await response.json();
                console.log('[PERFORMANCE] API response received, from_cache:', apiData.from_cache);

                if (!apiData.chart_data || Object.keys(apiData.chart_data).length === 0) {
                    throw new Error('No chart data in API response');
                }

                // Transform API data to format expected by chart renderer
                // API returns: {symbol: [{timestamp, value}, ...]} (value is already rebased %)
                // Chart expects: {symbol: [{timestamp, close}, ...]} where close is raw price
                // We'll adapt renderPerformanceChart to handle pre-computed values

                // Update overview from API response
                const overview = apiData.overview;
                updatePerformanceOverviewFromAPI(overview);

                // Render chart with pre-computed rebased data
                renderPerformanceChartFromAPI(apiData.chart_data, apiData.performance_order);

                // Update last refreshed timestamp
                updateLastUpdatedTime();

                console.log('[PERFORMANCE] Data loaded successfully for ' + currentTimeframe + 'H timeframe');

            } catch (error) {
                console.error('[PERFORMANCE] Error loading performance data:', error);

                // Fallback to direct Bybit fetch if API fails
                console.log('[PERFORMANCE] Attempting fallback to direct Bybit fetch...');
                try {
                    await loadPerformanceDataDirect();
                } catch (fallbackError) {
                    console.error('[PERFORMANCE] Fallback also failed:', fallbackError);
                    showPerformanceError();
                }
            }
        }

        // Fallback function using direct Bybit API calls
        async function loadPerformanceDataDirect() {
            const tickers = await fetchBybitTickers();
            if (tickers.length === 0) throw new Error('No tickers fetched');

            const topSymbols = ['BTC'];
            for (const t of tickers) {
                if (t.normalized !== 'BTC' && !topSymbols.includes(t.normalized)) {
                    topSymbols.push(t.normalized);
                }
                if (topSymbols.length >= 25) break;
            }

            const historicalData = await fetchHistoricalDataBybit(topSymbols, currentTimeframe);
            updatePerformanceOverview(historicalData, tickers);
            renderPerformanceChart(historicalData);
            updateLastUpdatedTime();
        }

        // Update overview metrics from API response
        function updatePerformanceOverviewFromAPI(overview) {
            const btcChangeEl = document.getElementById('perfBtcChange');
            if (btcChangeEl) {
                const btcChange = overview.btc_change || 0;
                btcChangeEl.textContent = (btcChange >= 0 ? '+' : '') + btcChange.toFixed(2) + '%';
                btcChangeEl.style.color = btcChange >= 0 ? 'var(--accent-positive)' : 'var(--accent-negative)';
            }

            const symbolCountEl = document.getElementById('perfSymbolCount');
            if (symbolCountEl) {
                symbolCountEl.textContent = overview.symbols_count || 0;
            }

            const outperformersEl = document.getElementById('perfOutperformers');
            if (outperformersEl) {
                outperformersEl.textContent = overview.outperformers || 0;
            }

            const underperformersEl = document.getElementById('perfUnderperformers');
            if (underperformersEl) {
                underperformersEl.textContent = overview.underperformers || 0;
            }
        }

        // Add floating tooltip to chart (uses globals: lwChart, lwSeriesData)
        function addFloatingTooltip(chartDiv) {
            const tooltip = document.createElement('div');
            tooltip.id = 'perfTooltip';
            tooltip.style.cssText = `
                position: absolute;
                display: none;
                padding: 8px 12px;
                background: rgba(10, 10, 10, 0.95);
                border: 1px solid rgba(251, 191, 36, 0.3);
                border-radius: 6px;
                font-family: 'IBM Plex Mono', monospace;
                font-size: 11px;
                color: #e0e0e0;
                pointer-events: none;
                z-index: 100;
                max-height: 180px;
                overflow-y: auto;
                backdrop-filter: blur(4px);
            `;
            chartDiv.style.position = 'relative';
            chartDiv.appendChild(tooltip);

            lwChart.subscribeCrosshairMove(param => {
                if (!param.time || param.seriesData.size === 0) {
                    tooltip.style.display = 'none';
                    return;
                }

                // Gather all values at this time
                const values = [];
                param.seriesData.forEach((priceData, series) => {
                    for (const data of lwSeriesData) {
                        if (data.series === series && data.visible) {
                            values.push({
                                symbol: data.symbol,
                                value: priceData.value,
                                color: data.color
                            });
                            break;
                        }
                    }
                });

                // Sort by value descending
                values.sort((a, b) => b.value - a.value);

                // Show top 5 and bottom 2 for readability
                const topValues = values.slice(0, 5);
                const bottomValues = values.slice(-2);
                const displayValues = [...topValues];
                if (values.length > 7) {
                    displayValues.push({ symbol: '...', value: null, color: '#666' });
                }
                displayValues.push(...bottomValues.filter(v => !topValues.includes(v)));

                tooltip.innerHTML = displayValues.map(v => {
                    if (v.value === null) return `<div style="color: #666; text-align: center;">···</div>`;
                    const sign = v.value >= 0 ? '+' : '';
                    const valueColor = v.value >= 0 ? '#10b981' : '#ef4444';
                    return `<div style="display: flex; justify-content: space-between; gap: 12px;">
                        <span style="color: ${v.color}; font-weight: ${v.symbol === 'BTC' ? '700' : '400'};">${v.symbol}</span>
                        <span style="color: ${valueColor};">${sign}${v.value.toFixed(2)}%</span>
                    </div>`;
                }).join('');

                // Position tooltip
                const x = param.point.x;
                const y = param.point.y;
                const containerRect = chartDiv.getBoundingClientRect();
                const tooltipX = x > containerRect.width / 2 ? x - 140 : x + 20;
                tooltip.style.left = `${tooltipX}px`;
                tooltip.style.top = `${Math.max(10, y - 60)}px`;
                tooltip.style.display = 'block';
            });
        }

        // Render chart from pre-computed API data (values are already rebased %)
        function renderPerformanceChartFromAPI(chartData, performanceOrder) {
            const chartDiv = document.getElementById('performanceChart');
            if (!chartDiv) return;

            if (Object.keys(chartData).length === 0) {
                chartDiv.innerHTML = '<div style="text-align: center; padding: 60px; color: var(--text-secondary);">No data available</div>';
                return;
            }

            // Save current zoom state before destroying chart
            if (lwChart) {
                try {
                    lwChartVisibleRange = lwChart.timeScale().getVisibleRange();
                } catch (e) {
                    lwChartVisibleRange = null;
                }
            }

            // Clear previous chart and tooltip
            chartDiv.innerHTML = '';
            const existingTooltip = document.getElementById('perfTooltip');
            if (existingTooltip) existingTooltip.remove();

            // Color palette
            const colorPalette = [
                '#00FF7F', '#FF1493', '#00CED1', '#FFD700', '#FF6347',
                '#7B68EE', '#FF69B4', '#20B2AA', '#9370DB', '#32CD32',
                '#FF4500', '#00BFFF', '#ADFF2F', '#FF00FF', '#00FA9A',
                '#DC143C', '#00FFFF', '#7FFF00', '#FF8C00', '#8A2BE2'
            ];

            // Create Lightweight Chart
            lwChart = LightweightCharts.createChart(chartDiv, {
                width: chartDiv.clientWidth,
                height: 320,
                layout: {
                    background: { color: '#0a0a0a' },
                    textColor: '#9ca3af',
                    fontSize: 10
                },
                grid: {
                    vertLines: { color: 'rgba(255, 191, 0, 0.06)' },
                    horzLines: { color: 'rgba(255, 191, 0, 0.06)' }
                },
                crosshair: {
                    mode: LightweightCharts.CrosshairMode.Magnet,
                    vertLine: {
                        color: 'rgba(251, 191, 36, 0.4)',
                        width: 1,
                        style: LightweightCharts.LineStyle.Dashed,
                        labelBackgroundColor: '#fbbf24'
                    },
                    horzLine: {
                        color: 'rgba(251, 191, 36, 0.4)',
                        width: 1,
                        style: LightweightCharts.LineStyle.Dashed,
                        labelBackgroundColor: '#333'
                    }
                },
                rightPriceScale: {
                    borderColor: 'rgba(255, 191, 0, 0.15)',
                    scaleMargins: { top: 0.08, bottom: 0.08 },
                    entireTextOnly: true
                },
                timeScale: {
                    borderColor: 'rgba(255, 191, 0, 0.15)',
                    timeVisible: true,
                    secondsVisible: false,
                    rightOffset: 5
                },
                handleScale: { mouseWheel: false, pinch: true },
                handleScroll: { mouseWheel: false, pressedMouseMove: true, horzTouchDrag: true, vertTouchDrag: false }
            });

            const symbolPerformances = [];
            let colorIndex = 0;
            lwSeries = {};
            lwSeriesData = [];
            let allTimePoints = [];

            // Use performance order from API for consistent legend sorting
            const symbols = performanceOrder || Object.keys(chartData);

            symbols.forEach(symbol => {
                const dataPoints = chartData[symbol];
                if (!dataPoints || dataPoints.length === 0) return;

                // Data is already rebased - just convert timestamp to seconds
                const data = dataPoints.map(p => ({
                    time: Math.floor(p.timestamp / 1000),
                    value: p.value
                }));

                // Collect time points for zero line
                data.forEach(d => {
                    if (!allTimePoints.includes(d.time)) {
                        allTimePoints.push(d.time);
                    }
                });

                // Final performance value
                const finalValue = data[data.length - 1].value;
                symbolPerformances.push({ symbol, finalValue });

                // Determine color (BTC always orange)
                const color = symbol === 'BTC' ? '#FFA500' : colorPalette[colorIndex % colorPalette.length];
                if (symbol !== 'BTC') colorIndex++;

                // Create line series
                const series = lwChart.addLineSeries({
                    color: color,
                    lineWidth: symbol === 'BTC' ? 2.5 : 1.2,
                    lastValueVisible: true,
                    priceLineVisible: false,
                    title: symbol,
                    crosshairMarkerRadius: symbol === 'BTC' ? 5 : 3,
                    crosshairMarkerBorderWidth: symbol === 'BTC' ? 2 : 1,
                    crosshairMarkerBackgroundColor: color
                });

                series.setData(data);
                lwSeries[symbol] = { series, color, data };
                lwSeriesData.push({ symbol, finalValue, color, visible: true, series });
            });

            // Add zero reference line
            if (allTimePoints.length > 0) {
                allTimePoints.sort((a, b) => a - b);
                const zeroLine = lwChart.addLineSeries({
                    color: 'rgba(136, 136, 136, 0.5)',
                    lineWidth: 1,
                    lineStyle: LightweightCharts.LineStyle.Dashed,
                    lastValueVisible: false,
                    priceLineVisible: false,
                    crosshairMarkerVisible: false
                });
                zeroLine.setData(allTimePoints.map(t => ({ time: t, value: 0 })));
            }

            // Restore saved zoom state or center latest data in middle of chart
            if (lwChartVisibleRange) {
                try {
                    lwChart.timeScale().setVisibleRange(lwChartVisibleRange);
                } catch (e) {
                    lwChart.timeScale().fitContent();
                }
            } else if (allTimePoints.length >= 2) {
                // Center the latest data point in the middle of the chart
                const dataStart = allTimePoints[0];
                const dataEnd = allTimePoints[allTimePoints.length - 1];
                const totalRange = dataEnd - dataStart;

                // Show the latest point in the middle of the view
                // This means we need to show half the data before and extend view after
                const visibleRange = totalRange; // Show all data
                const centerPoint = dataEnd - (visibleRange * 0.5);

                lwChart.timeScale().setVisibleRange({
                    from: Math.max(dataStart, centerPoint),
                    to: dataEnd + (visibleRange * 0.5)
                });
            } else {
                lwChart.timeScale().fitContent();
            }

            // Render legend sorted by performance
            renderPerformanceLegend(lwSeriesData);

            // Add floating tooltip
            addFloatingTooltip(chartDiv);

            // Handle resize
            const resizeObserver = new ResizeObserver(() => {
                if (lwChart) lwChart.applyOptions({ width: chartDiv.clientWidth });
            });
            resizeObserver.observe(chartDiv);
        }

        // Bridge function: converts lwSeriesData format to renderCollapsibleLegend format
        function renderPerformanceLegend(seriesData) {
            // Sort by performance (finalValue)
            const sorted = [...seriesData].sort((a, b) => b.finalValue - a.finalValue);

            // Convert to format expected by renderCollapsibleLegend
            const traces = sorted.map(s => ({
                name: s.symbol + ' ' + (s.finalValue >= 0 ? '+' : '') + s.finalValue.toFixed(1) + '%',
                line: { color: s.color }
            }));

            // Render using existing collapsible legend function
            renderCollapsibleLegend(traces, 'performanceChartLegend');
        }

        function updatePerformanceOverview(historicalData, tickers) {
            // Calculate BTC 12h change
            const btcData = historicalData['BTC'];
            let btcChange = 0;
            if (btcData && btcData.length > 0) {
                const firstPrice = btcData[0].close;
                const lastPrice = btcData[btcData.length - 1].close;
                btcChange = ((lastPrice - firstPrice) / firstPrice) * 100;
            }

            // Calculate outperformers/underperformers
            let outperformers = 0;
            let underperformers = 0;

            Object.keys(historicalData).forEach(symbol => {
                const candles = historicalData[symbol];
                if (candles.length > 0) {
                    const firstPrice = candles[0].close;
                    const lastPrice = candles[candles.length - 1].close;
                    const change = ((lastPrice - firstPrice) / firstPrice) * 100;

                    if (change > 1.0) outperformers++;
                    if (change < -3.0) underperformers++;
                }
            });

            // Update UI
            const btcChangeEl = document.getElementById('perfBtcChange');
            if (btcChangeEl) {
                btcChangeEl.textContent = (btcChange >= 0 ? '+' : '') + btcChange.toFixed(2) + '%';
                btcChangeEl.style.color = btcChange >= 0 ? 'var(--accent-positive)' : 'var(--accent-negative)';
            }

            const symbolCountEl = document.getElementById('perfSymbolCount');
            if (symbolCountEl) {
                symbolCountEl.textContent = Object.keys(historicalData).length;
            }

            const outperformersEl = document.getElementById('perfOutperformers');
            if (outperformersEl) {
                outperformersEl.textContent = outperformers;
            }

            const underperformersEl = document.getElementById('perfUnderperformers');
            if (underperformersEl) {
                underperformersEl.textContent = underperformers;
            }
        }

        // Store chart instance and series globally for toggle functionality
        let lwChart = null;
        let lwSeries = {};
        let lwSeriesData = [];
        let labelsVisible = true;
        let topBottomOnly = false;
        let lwChartVisibleRange = null;  // Preserve zoom state across refreshes

        // Toggle all chart labels on/off
        function toggleChartLabels() {
            labelsVisible = !labelsVisible;
            const btn = document.getElementById('toggleLabelsBtn');

            if (labelsVisible) {
                btn.innerHTML = '<span id="toggleLabelsIcon">👁</span> LABELS: ON';
                btn.style.background = 'rgba(251, 191, 36, 0.15)';
            } else {
                btn.innerHTML = '<span id="toggleLabelsIcon">👁‍🗨</span> LABELS: OFF';
                btn.style.background = 'rgba(100, 100, 100, 0.15)';
            }

            applyLabelVisibility();
        }

        // Toggle top/bottom 5 only mode
        function toggleTopBottomOnly() {
            topBottomOnly = !topBottomOnly;
            const btn = document.getElementById('toggleTopBottomBtn');

            if (topBottomOnly) {
                btn.textContent = 'TOP/BOTTOM 5: ON';
                btn.style.background = 'rgba(6, 182, 212, 0.3)';
                btn.style.borderColor = 'rgba(6, 182, 212, 0.8)';
            } else {
                btn.textContent = 'TOP/BOTTOM 5: OFF';
                btn.style.background = 'rgba(6, 182, 212, 0.15)';
                btn.style.borderColor = 'rgba(6, 182, 212, 0.4)';
            }

            applyLabelVisibility();
        }

        // Apply label visibility based on current toggle states
        function applyLabelVisibility() {
            if (!lwSeriesData || lwSeriesData.length === 0) return;

            // Sort to find top 5 and bottom 5 (handle both finalValue and finalChange property names)
            const sorted = [...lwSeriesData].sort((a, b) => {
                const aVal = a.finalValue !== undefined ? a.finalValue : a.finalChange;
                const bVal = b.finalValue !== undefined ? b.finalValue : b.finalChange;
                return bVal - aVal;
            });
            const top5 = sorted.slice(0, 5).map(s => s.symbol);
            const bottom5 = sorted.slice(-5).map(s => s.symbol);
            const topBottomSymbols = new Set([...top5, ...bottom5, 'BTC']); // Always include BTC

            lwSeriesData.forEach(seriesInfo => {
                if (!seriesInfo.series) return;

                let showLabel = labelsVisible;

                // If topBottomOnly is enabled, further filter
                if (showLabel && topBottomOnly) {
                    showLabel = topBottomSymbols.has(seriesInfo.symbol);
                }

                seriesInfo.series.applyOptions({
                    lastValueVisible: showLabel,
                    title: showLabel ? seriesInfo.symbol : ''
                });
            });
        }

        function renderPerformanceChart(historicalData) {
            const chartDiv = document.getElementById('performanceChart');

            if (!chartDiv) return;

            if (Object.keys(historicalData).length === 0) {
                chartDiv.innerHTML = '<div style="text-align: center; padding: 60px; color: var(--text-secondary);">No data available</div>';
                return;
            }

            // Save current zoom state before destroying chart
            if (lwChart) {
                try {
                    lwChartVisibleRange = lwChart.timeScale().getVisibleRange();
                } catch (e) {
                    lwChartVisibleRange = null;
                }
            }

            // Clear previous chart and tooltip
            chartDiv.innerHTML = '';
            const existingTooltip = document.getElementById('perfTooltip');
            if (existingTooltip) existingTooltip.remove();

            // Color palette
            const colorPalette = [
                '#00FF7F', '#FF1493', '#00CED1', '#FFD700', '#FF6347',
                '#7B68EE', '#FF69B4', '#20B2AA', '#9370DB', '#32CD32',
                '#FF4500', '#00BFFF', '#ADFF2F', '#FF00FF', '#00FA9A',
                '#DC143C', '#00FFFF', '#7FFF00', '#FF8C00', '#8A2BE2'
            ];

            // Create Lightweight Chart with optimized settings
            lwChart = LightweightCharts.createChart(chartDiv, {
                width: chartDiv.clientWidth,
                height: 320,
                layout: {
                    background: { color: '#0a0a0a' },
                    textColor: '#9ca3af',
                    fontSize: 10
                },
                grid: {
                    vertLines: { color: 'rgba(255, 191, 0, 0.06)' },
                    horzLines: { color: 'rgba(255, 191, 0, 0.06)' }
                },
                crosshair: {
                    mode: LightweightCharts.CrosshairMode.Magnet, // Snaps to data points
                    vertLine: {
                        color: 'rgba(251, 191, 36, 0.4)',
                        width: 1,
                        style: LightweightCharts.LineStyle.Dashed,
                        labelBackgroundColor: '#fbbf24'
                    },
                    horzLine: {
                        color: 'rgba(251, 191, 36, 0.4)',
                        width: 1,
                        style: LightweightCharts.LineStyle.Dashed,
                        labelBackgroundColor: '#333'
                    }
                },
                rightPriceScale: {
                    borderColor: 'rgba(255, 191, 0, 0.15)',
                    scaleMargins: { top: 0.08, bottom: 0.08 },
                    entireTextOnly: true
                },
                timeScale: {
                    borderColor: 'rgba(255, 191, 0, 0.15)',
                    timeVisible: true,
                    secondsVisible: false,
                    rightOffset: 5
                },
                handleScale: {
                    mouseWheel: false,
                    pinch: true
                },
                handleScroll: {
                    mouseWheel: false,
                    pressedMouseMove: true,
                    horzTouchDrag: true,
                    vertTouchDrag: false
                }
            });

            const symbolPerformances = [];
            let colorIndex = 0;
            lwSeries = {};
            lwSeriesData = [];

            // Collect all time points for zero line
            let allTimePoints = [];

            Object.keys(historicalData).forEach(symbol => {
                const candles = historicalData[symbol];
                if (candles.length === 0) return;

                const initialPrice = candles[0].close;
                const data = candles.map(c => ({
                    time: Math.floor(c.timestamp / 1000),
                    value: ((c.close - initialPrice) / initialPrice) * 100
                }));

                if (allTimePoints.length === 0) {
                    allTimePoints = data.map(d => d.time);
                }

                const finalChange = data[data.length - 1].value;
                symbolPerformances.push({ symbol, finalChange, data });

                const color = symbol === 'BTC' ? '#FFA500' : colorPalette[colorIndex++ % colorPalette.length];

                const series = lwChart.addLineSeries({
                    color: color,
                    lineWidth: symbol === 'BTC' ? 2.5 : 1.2,
                    priceFormat: {
                        type: 'custom',
                        formatter: price => `${price.toFixed(1)}%`
                    },
                    lastValueVisible: false, // Clean - no overlapping labels
                    priceLineVisible: false,
                    crosshairMarkerVisible: true,
                    crosshairMarkerRadius: symbol === 'BTC' ? 5 : 3,
                    crosshairMarkerBorderColor: color,
                    crosshairMarkerBackgroundColor: '#0a0a0a'
                });

                series.setData(data);

                lwSeries[symbol] = series;
                lwSeriesData.push({
                    symbol: symbol,
                    finalChange: finalChange,
                    color: color,
                    series: series,
                    visible: true
                });
            });

            // Add zero reference line (renders behind other series)
            if (allTimePoints.length > 0) {
                const zeroLine = lwChart.addLineSeries({
                    color: 'rgba(128, 128, 128, 0.5)',
                    lineWidth: 1,
                    lineStyle: LightweightCharts.LineStyle.Dashed,
                    lastValueVisible: false,
                    priceLineVisible: false,
                    crosshairMarkerVisible: false
                });
                zeroLine.setData(allTimePoints.map(t => ({ time: t, value: 0 })));
            }

            // Restore saved zoom state or set tight view starting at data origin
            if (lwChartVisibleRange) {
                try {
                    lwChart.timeScale().setVisibleRange(lwChartVisibleRange);
                } catch (e) {
                    lwChart.timeScale().fitContent();
                }
            } else if (allTimePoints.length >= 2) {
                // Set view to start exactly where lines begin (no empty space on left)
                allTimePoints.sort((a, b) => a - b);
                const dataStart = allTimePoints[0];
                const dataEnd = allTimePoints[allTimePoints.length - 1];
                // Add small padding on right for labels (5% of range)
                const rangePadding = (dataEnd - dataStart) * 0.05;
                lwChart.timeScale().setVisibleRange({
                    from: dataStart,
                    to: dataEnd + rangePadding
                });
            } else {
                lwChart.timeScale().fitContent();
            }

            // Add floating tooltip
            addFloatingTooltip(chartDiv);

            // Handle resize
            const resizeObserver = new ResizeObserver(entries => {
                if (lwChart && chartDiv.clientWidth > 0) {
                    lwChart.applyOptions({ width: chartDiv.clientWidth });
                }
            });
            resizeObserver.observe(chartDiv);

            // Sort by performance and create legend data
            symbolPerformances.sort((a, b) => b.finalChange - a.finalChange);
            const legendTraces = symbolPerformances.map(sp => {
                const seriesInfo = lwSeriesData.find(s => s.symbol === sp.symbol);
                return {
                    name: sp.symbol + ' ' + (sp.finalChange >= 0 ? '+' : '') + sp.finalChange.toFixed(1) + '%',
                    line: { color: seriesInfo ? seriesInfo.color : '#ffffff' }
                };
            });

            // Create collapsible legend below chart
            renderCollapsibleLegend(legendTraces, 'performanceChartLegend');
        }

        function renderCollapsibleLegend(traces, containerId) {
            const container = document.getElementById(containerId);
            if (!container) return;

            // Split into top performers (first 8) and others
            const topPerformers = traces.slice(0, 8);
            const others = traces.slice(8);

            let html = `
                <button id="legendToggle" onclick="toggleLegend()" style="
                    width: 100%;
                    padding: 10px;
                    background: rgba(26, 26, 26, 0.8);
                    border: 1px solid #fbbf24;
                    border-radius: 8px;
                    color: #fbbf24;
                    font-family: 'IBM Plex Mono', monospace;
                    font-size: 11px;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    justify-content: space-between;
                    transition: all 0.2s ease;
                ">
                    <span>VIEW ALL ${traces.length} SYMBOLS</span>
                    <span id="legendToggleIcon" style="font-size: 14px;">▼</span>
                </button>
                <div id="legendContent" style="
                    max-height: 0;
                    overflow: hidden;
                    transition: max-height 0.3s ease;
                    background: rgba(10, 10, 10, 0.95);
                    border: 1px solid rgba(251, 191, 36, 0.3);
                    border-top: none;
                    border-radius: 0 0 8px 8px;
                ">
                    <div style="padding: 12px; max-height: 200px; overflow-y: auto;">
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">
            `;

            // Render all traces in a compact grid
            traces.forEach(trace => {
                const symbol = trace.name.split(' ')[0];
                const change = trace.name.split(' ').slice(1).join(' ');
                html += `
                    <div onclick="toggleTrace('${symbol}')" style="
                        display: flex;
                        align-items: center;
                        padding: 6px 8px;
                        background: rgba(26, 26, 26, 0.6);
                        border-radius: 6px;
                        cursor: pointer;
                        transition: all 0.15s ease;
                        border: 1px solid transparent;
                        font-family: 'IBM Plex Mono', monospace;
                    " onmouseover="this.style.borderColor='${trace.line.color}'" onmouseout="this.style.borderColor='transparent'">
                        <div style="
                            width: 10px;
                            height: 10px;
                            background: ${trace.line.color};
                            border-radius: 2px;
                            margin-right: 6px;
                            flex-shrink: 0;
                        "></div>
                        <div style="
                            font-size: 10px;
                            color: #e0e0e0;
                            overflow: hidden;
                            text-overflow: ellipsis;
                            white-space: nowrap;
                        ">
                            <span style="font-weight: 600;">${symbol}</span>
                            <span style="color: ${change.startsWith('+') ? '#10b981' : '#ef4444'}; font-size: 9px; margin-left: 2px;">${change}</span>
                        </div>
                    </div>
                `;
            });

            html += `
                        </div>
                    </div>
                </div>
            `;

            container.innerHTML = html;
        }

        function toggleLegend() {
            const content = document.getElementById('legendContent');
            const icon = document.getElementById('legendToggleIcon');
            const toggle = document.getElementById('legendToggle');

            if (content.style.maxHeight === '0px' || content.style.maxHeight === '') {
                content.style.maxHeight = '240px';
                icon.textContent = '▲';
                toggle.style.borderRadius = '8px 8px 0 0';
            } else {
                content.style.maxHeight = '0px';
                icon.textContent = '▼';
                toggle.style.borderRadius = '8px';
            }
        }

        function toggleTrace(symbol) {
            // Find the series in the Lightweight Chart
            const seriesInfo = lwSeriesData.find(s => s.symbol === symbol);
            if (!seriesInfo || !seriesInfo.series) return;

            // Toggle visibility by changing line width (Lightweight Charts doesn't have direct visibility toggle)
            seriesInfo.visible = !seriesInfo.visible;

            if (seriesInfo.visible) {
                // Show the series
                seriesInfo.series.applyOptions({
                    lineWidth: symbol === 'BTC' ? 2.5 : 1.2,
                    color: seriesInfo.color
                });
            } else {
                // Hide the series by making it transparent
                seriesInfo.series.applyOptions({
                    lineWidth: 0,
                    color: 'transparent'
                });
            }
        }

        function renderTopPerformers(historicalData, type) {
            const performances = [];

            Object.keys(historicalData).forEach(symbol => {
                const candles = historicalData[symbol];
                if (candles.length > 0) {
                    const firstPrice = candles[0].close;
                    const lastPrice = candles[candles.length - 1].close;
                    const change = ((lastPrice - firstPrice) / firstPrice) * 100;
                    performances.push({ symbol, change });
                }
            });

            // Sort and get top 10
            performances.sort((a, b) => type === 'gainers' ? b.change - a.change : a.change - b.change);
            const top10 = performances.slice(0, 10);

            // Render
            const listId = type === 'gainers' ? 'perfTopGainers' : 'perfTopLosers';
            const listEl = document.getElementById(listId);

            if (!listEl) return;

            listEl.innerHTML = '';

            top10.forEach(item => {
                const changeColor = item.change >= 0 ? 'var(--accent-positive)' : 'var(--accent-negative)';
                const changeText = (item.change >= 0 ? '+' : '') + item.change.toFixed(2) + '%';

                listEl.innerHTML += '<div style="display: flex; justify-content: space-between; align-items: center; padding: 12px; background: var(--bg-secondary); border-radius: 8px; border: 1px solid var(--border-light);"><div><div style="font-size: 14px; font-weight: 600; color: var(--text-primary); font-family: \'IBM Plex Mono\', monospace;">' + item.symbol + '</div></div><div style="font-size: 18px; font-weight: 700; color: ' + changeColor + '; font-family: \'IBM Plex Mono\', monospace;">' + changeText + '</div></div>';
            });
        }

        function showPerformanceError() {
            const perfBtcChange = document.getElementById('perfBtcChange');
            if (perfBtcChange) perfBtcChange.textContent = '--';

            const perfSymbolCount = document.getElementById('perfSymbolCount');
            if (perfSymbolCount) perfSymbolCount.textContent = '--';

            const perfOutperformers = document.getElementById('perfOutperformers');
            if (perfOutperformers) perfOutperformers.textContent = '--';

            const perfUnderperformers = document.getElementById('perfUnderperformers');
            if (perfUnderperformers) perfUnderperformers.textContent = '--';

            const performanceChart = document.getElementById('performanceChart');
            if (performanceChart) {
                performanceChart.innerHTML = '<div style="text-align: center; padding: 60px; color: var(--accent-negative);">Error loading performance data</div>';
            }

            const perfTopGainers = document.getElementById('perfTopGainers');
            if (perfTopGainers) {
                perfTopGainers.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-secondary);">Unable to load data</div>';
            }

            const perfTopLosers = document.getElementById('perfTopLosers');
            if (perfTopLosers) {
                perfTopLosers.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-secondary);">Unable to load data</div>';
            }
        }

        // =====================================================
        // BITCOIN BETA DATA FUNCTIONS
        // =====================================================

        async function loadBetaData() {
            console.log('[BETA] Loading beta data...');
            try {
                const response = await fetch('/api/bitcoin-beta/realtime');
                const data = await response.json();

                if (data.status === 'success' && data.overview && data.symbols) {
                    // Update overview with real data
                    updateBetaOverview({
                        beta_coefficient: data.overview.market_beta || 1.0,
                        correlation: data.overview.avg_correlation || 0.5,
                        market_regime: data.overview.market_regime || 'NEUTRAL',
                        volatility_ratio: data.overview.market_beta || 1.0
                    });

                    // Transform symbols data for display
                    const betaSymbols = data.symbols.map(sym => ({
                        symbol: sym.symbol.replace('USDT', ''),
                        price: sym.last_price || 0,
                        change_24h: sym.change_24h || 0,
                        beta: sym.beta_30d || 1.0,
                        correlation: sym.correlation_30d || 0.5,
                        volume_24h: sym.volume_24h || 0,
                        risk_category: sym.risk_category?.category || 'Market Neutral',
                        risk_color: sym.risk_category?.color || '#6B7280',
                        alpha: sym.alpha_30d || 0,
                        r_squared: sym.r_squared_30d || 0
                    }));

                    // Update beta symbols table
                    updateBetaSymbols({ symbols: betaSymbols });

                    console.log('[BETA] Data loaded successfully');
                } else {
                    throw new Error('Invalid beta data format');
                }
            } catch (error) {
                console.error('[BETA] Error loading beta data:', error);
                updateBetaOverview({
                    beta_coefficient: 0,
                    correlation: 0,
                    market_regime: 'unknown',
                    volatility_ratio: 0
                });
                showBetaError();
            }
        }

        function updateBetaOverview(data) {
            // Update beta coefficient
            const betaCoef = document.getElementById('betaCoefficient');
            if (betaCoef) {
                const beta = data.beta_coefficient || 0;
                betaCoef.textContent = beta.toFixed(2);
                betaCoef.style.color = beta > 1 ? 'var(--accent-negative)' : beta < 1 ? 'var(--accent-positive)' : 'var(--text-primary)';
            }

            // Update correlation
            const correlation = document.getElementById('btcCorrelation');
            if (correlation) {
                const corr = data.correlation || 0;
                correlation.textContent = (corr * 100).toFixed(0) + '%';
                correlation.style.color = corr > 0.7 ? 'var(--accent-positive)' : corr < 0.3 ? 'var(--accent-negative)' : 'var(--accent-warning)';
            }

            // Update market regime (Beta section)
            // Format: "Category: Label" (e.g., "Bearish: Risk-Off")
            const regimeEl = document.getElementById('betaMarketRegime');
            if (regimeEl) {
                let marketRegime = data.market_regime || 'Neutral: Unknown';
                if (typeof marketRegime === 'object') {
                    marketRegime = marketRegime.regime || 'Neutral: Unknown';
                }
                marketRegime = String(marketRegime);
                regimeEl.textContent = marketRegime;

                // Extract category for coloring (before the colon)
                const category = marketRegime.split(':')[0].trim().toUpperCase();
                if (category.includes('BULLISH')) {
                    regimeEl.style.background = 'rgba(76, 175, 80, 0.2)';
                } else if (category.includes('BEARISH')) {
                    regimeEl.style.background = 'rgba(244, 67, 54, 0.2)';
                } else {
                    regimeEl.style.background = 'rgba(255, 191, 0, 0.2)';
                }
            }

            // Update volatility ratio
            const volRatio = document.getElementById('volatilityRatio');
            if (volRatio) {
                const ratio = data.volatility_ratio || 0;
                volRatio.textContent = ratio.toFixed(2) + 'x';
            }
        }

        // =====================================================
        // BETA RANKINGS FUNCTIONS (MULTI-TIMEFRAME)
        // =====================================================

        async function loadMTFRankings() {
            const cluster = document.getElementById('mtfClusterSelector')?.value || 'day_trading';
            const rankingsList = document.getElementById('mtfRankingsList');

            if (!rankingsList) return;

            console.log('[MTF] Loading rankings for cluster:', cluster);

            try {
                const response = await fetch(`/api/altcoins/mtf-ranking?cluster=${cluster}&top_n=8`);
                const data = await response.json();

                if (data.status === 'success' && data.data && data.data.rankings) {
                    renderMTFRankings(data.data.rankings);
                } else {
                    throw new Error('Invalid MTF data format');
                }
            } catch (error) {
                console.error('[MTF] Error loading rankings:', error);
                rankingsList.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-secondary);">Unable to load MTF rankings</div>';
            }
        }

        // =====================================================
        // MTF RANKINGS VISUALIZATION HELPERS
        // =====================================================

        /**
         * Generate circular progress ring for MTF score (0-100)
         * @param {number} score - MTF score (0-100)
         * @param {number} size - SVG size in pixels
         * @returns {string} SVG HTML string
         */
        function generateScoreRing(score, size = 64) {
            const radius = (size - 8) / 2;
            const circumference = 2 * Math.PI * radius;
            const offset = circumference - (score / 100) * circumference;

            // Color gradient based on score
            let strokeColor = '#ef4444'; // red (0-40)
            if (score >= 70) strokeColor = '#10b981'; // green (70-100)
            else if (score >= 50) strokeColor = '#fbbf24'; // amber (50-70)
            else if (score >= 40) strokeColor = '#f59e0b'; // orange (40-50)

            return `
                <svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" style="transform: rotate(-90deg); display: block;">
                    <!-- Background ring -->
                    <circle
                        cx="${size/2}"
                        cy="${size/2}"
                        r="${radius}"
                        fill="none"
                        stroke="rgba(255,255,255,0.08)"
                        stroke-width="4"
                    />
                    <!-- Progress ring -->
                    <circle
                        cx="${size/2}"
                        cy="${size/2}"
                        r="${radius}"
                        fill="none"
                        stroke="${strokeColor}"
                        stroke-width="4"
                        stroke-dasharray="${circumference}"
                        stroke-dashoffset="${offset}"
                        stroke-linecap="round"
                        style="transition: stroke-dashoffset 0.6s ease;"
                    />
                    <!-- Inner score text -->
                    <text
                        x="${size/2}"
                        y="${size/2}"
                        text-anchor="middle"
                        dominant-baseline="middle"
                        fill="${strokeColor}"
                        font-size="${size * 0.35}"
                        font-weight="800"
                        font-family="'IBM Plex Mono', monospace"
                        style="transform: rotate(90deg); transform-origin: ${size/2}px ${size/2}px;"
                    >${Math.round(score)}</text>
                </svg>
            `;
        }

        /**
         * Generate timeframe performance sparkline
         * @param {Object} timeframeDetails - Object with timeframe keys and performance values
         * @returns {string} SVG HTML string
         */
        function generatePerformanceSparkline(timeframeDetails) {
            if (!timeframeDetails || Object.keys(timeframeDetails).length === 0) {
                return '<div style="height: 40px; display: flex; align-items: center; color: var(--text-tertiary); font-size: 10px;">No data</div>';
            }

            const timeframes = Object.entries(timeframeDetails).map(([tf, value]) => ({
                label: `${tf}h`,
                value: parseFloat(value) || 0
            }));

            const width = 100;
            const height = 40;
            const barWidth = (width / timeframes.length) - 4;
            const maxAbsValue = Math.max(...timeframes.map(tf => Math.abs(tf.value)));
            const scale = maxAbsValue > 0 ? (height / 2 - 6) / maxAbsValue : 1;

            const bars = timeframes.map((tf, i) => {
                const barHeight = Math.abs(tf.value) * scale;
                const isPositive = tf.value >= 0;
                const y = isPositive ? (height / 2 - barHeight) : height / 2;
                const color = isPositive ? '#10b981' : '#ef4444';
                const opacity = 0.7 + (Math.abs(tf.value) / maxAbsValue) * 0.3;

                return `
                    <rect
                        x="${i * (barWidth + 4)}"
                        y="${y}"
                        width="${barWidth}"
                        height="${barHeight}"
                        fill="${color}"
                        opacity="${opacity}"
                        rx="2"
                    />
                    <text
                        x="${i * (barWidth + 4) + barWidth/2}"
                        y="${height - 2}"
                        text-anchor="middle"
                        fill="#6b7280"
                        font-size="8"
                        font-family="'IBM Plex Mono', monospace"
                    >${tf.label}</text>
                `;
            }).join('');

            return `
                <svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" style="display: block;">
                    <line x1="0" y1="${height/2}" x2="${width}" y2="${height/2}" stroke="rgba(255,255,255,0.1)" stroke-width="1"/>
                    ${bars}
                </svg>
            `;
        }

        /**
         * Generate consistency indicator (visual progress bar)
         * @param {number} aligned - Number of aligned timeframes
         * @param {number} total - Total timeframes
         * @returns {string} HTML string
         */
        function generateConsistencyIndicator(aligned, total) {
            const ratio = aligned / total;
            const percentage = Math.round(ratio * 100);

            // Color based on consistency
            let color = '#ef4444'; // red (<50%)
            if (percentage >= 80) color = '#10b981'; // green (80-100%)
            else if (percentage >= 60) color = '#fbbf24'; // amber (60-80%)
            else if (percentage >= 50) color = '#f59e0b'; // orange (50-60%)

            // Generate filled/empty circles
            const circles = Array.from({ length: total }, (_, i) => {
                const filled = i < aligned;
                return `<div style="
                    width: 8px;
                    height: 8px;
                    border-radius: 50%;
                    background: ${filled ? color : 'rgba(255,255,255,0.1)'};
                    border: 1px solid ${filled ? color : 'rgba(255,255,255,0.2)'};
                    ${filled ? 'box-shadow: 0 0 4px ' + color + '40;' : ''}
                    flex-shrink: 0;
                "></div>`;
            }).join('');

            return `
                <div style="display: flex; align-items: center; gap: 6px;">
                    ${circles}
                    <span style="font-size: 10px; color: ${color}; font-weight: 600; font-family: 'IBM Plex Mono', monospace; line-height: 1; white-space: nowrap;">${aligned}/${total}</span>
                </div>
            `;
        }

        /**
         * Main MTF Rankings Renderer with Enhanced Visualizations
         */
        function renderMTFRankings(rankings) {
            const rankingsList = document.getElementById('mtfRankingsList');
            if (!rankingsList) return;

            if (!rankings || rankings.length === 0) {
                rankingsList.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-secondary);">No MTF rankings available</div>';
                return;
            }

            rankingsList.innerHTML = rankings.map(coin => {
                // Signal colors
                const signalColors = {
                    'STRONG_BUY': { bg: 'rgba(16, 185, 129, 0.15)', color: '#10b981', border: 'rgba(16, 185, 129, 0.3)', pulse: true },
                    'BUY': { bg: 'rgba(59, 130, 246, 0.15)', color: '#3b82f6', border: 'rgba(59, 130, 246, 0.3)', pulse: false },
                    'WEAK_BUY': { bg: 'rgba(139, 92, 246, 0.15)', color: '#8b5cf6', border: 'rgba(139, 92, 246, 0.3)', pulse: false },
                    'NEUTRAL': { bg: 'rgba(107, 114, 128, 0.15)', color: '#6b7280', border: 'rgba(107, 114, 128, 0.3)', pulse: false },
                    'WEAK_SELL': { bg: 'rgba(239, 68, 68, 0.15)', color: '#ef4444', border: 'rgba(239, 68, 68, 0.3)', pulse: false },
                    'SELL': { bg: 'rgba(239, 68, 68, 0.2)', color: '#ef4444', border: 'rgba(239, 68, 68, 0.4)', pulse: false },
                    'STRONG_SELL': { bg: 'rgba(239, 68, 68, 0.25)', color: '#ef4444', border: 'rgba(239, 68, 68, 0.5)', pulse: true }
                };

                const signalStyle = signalColors[coin.signal] || signalColors['NEUTRAL'];
                const perfColor = coin.total_outperformance >= 0 ? '#10b981' : '#ef4444';

                // Generate visualizations
                const scoreRing = generateScoreRing(coin.mtf_score, 64);
                const sparkline = generatePerformanceSparkline(coin.timeframe_details);
                const consistencyIndicator = generateConsistencyIndicator(coin.aligned_timeframes, coin.total_timeframes);

                return `
                    <div class="signal-card" style="
                        cursor: pointer;
                        position: relative;
                        border-left: 3px solid ${signalStyle.color};
                        padding: 16px;
                        margin-bottom: 8px;
                        background: var(--bg-secondary);
                        border-radius: 8px;
                        ${signalStyle.pulse ? 'animation: subtle-pulse 2s ease-in-out infinite;' : ''}
                    " onclick="viewMTFDetails('${coin.symbol}')">

                        <!-- Header Row: Rank/Symbol + Signal Badge -->
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                            <div style="display: flex; align-items: baseline; gap: 8px;">
                                <span style="
                                    font-family: 'IBM Plex Mono', monospace;
                                    font-size: 12px;
                                    color: var(--text-secondary);
                                    font-weight: 600;
                                    min-width: 24px;
                                    line-height: 1.5;
                                ">#${String(coin.rank).padStart(2, '0')}</span>
                                <span style="
                                    font-size: 16px;
                                    font-weight: 700;
                                    color: var(--text-primary);
                                    letter-spacing: 0.5px;
                                    line-height: 1.5;
                                ">${coin.symbol}</span>
                            </div>
                            <div class="card-badge" style="
                                background: ${signalStyle.bg};
                                color: ${signalStyle.color};
                                border: 1px solid ${signalStyle.border};
                                font-size: 9px;
                                padding: 6px 8px;
                                letter-spacing: 0.5px;
                                white-space: nowrap;
                                line-height: 1;
                            ">
                                ${coin.signal.replace(/_/g, ' ')}
                            </div>
                        </div>

                        <!-- Main Content Row: Score Ring + Metrics -->
                        <div style="display: flex; gap: 16px; align-items: flex-start;">

                            <!-- Score Ring -->
                            <div style="
                                flex-shrink: 0;
                                width: 64px;
                                height: 64px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                            ">
                                ${scoreRing}
                            </div>

                            <!-- Metrics Column -->
                            <div style="flex: 1; display: flex; flex-direction: column; gap: 4px; min-width: 0;">

                                <!-- Performance -->
                                <div style="display: flex; justify-content: space-between; align-items: baseline; gap: 8px;">
                                    <span style="font-size: 11px; color: var(--text-secondary); line-height: 1.2; white-space: nowrap;">Performance</span>
                                    <span style="
                                        font-size: 14px;
                                        font-weight: 700;
                                        color: ${perfColor};
                                        font-family: 'IBM Plex Mono', monospace;
                                        line-height: 1.2;
                                        white-space: nowrap;
                                    ">${coin.total_outperformance >= 0 ? '+' : ''}${coin.total_outperformance.toFixed(2)}%</span>
                                </div>

                                <!-- Timeframe Sparkline -->
                                <div style="display: flex; align-items: center; justify-content: flex-start; margin: 4px 0;">
                                    ${sparkline}
                                </div>

                                <!-- Consistency Indicator -->
                                <div style="display: flex; justify-content: space-between; align-items: center; gap: 8px;">
                                    <span style="font-size: 11px; color: var(--text-secondary); line-height: 1.2; white-space: nowrap;">Alignment</span>
                                    ${consistencyIndicator}
                                </div>

                            </div>
                        </div>

                    </div>
                `;
            }).join('');
        }

        // Add subtle pulse animation for STRONG signals
        const style = document.createElement('style');
        style.textContent = `
            @keyframes subtle-pulse {
                0%, 100% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0); }
                50% { box-shadow: 0 0 8px 2px rgba(16, 185, 129, 0.2); }
            }
        `;
        document.head.appendChild(style);

        function viewMTFDetails(symbol) {
            console.log('[MTF] View details for:', symbol);
            // Could navigate to detailed view or show modal
        }

        // =====================================================
        // END CRYPTO PERFORMANCE TRACKER FUNCTIONS
        // =====================================================

        function updateTradeSignals(data) {
            console.log('[DEBUG] updateTradeSignals() called');
            const signalsList = document.getElementById('signalsList');
            const signalCount = document.getElementById('signalCount');
            const longCount = document.getElementById('longCount');
            const shortCount = document.getElementById('shortCount');
            const winRate = document.getElementById('winRate');
            const winLoss = document.getElementById('winLoss');

            const signals = data.signals || [];
            const summary = data.summary || {};
            const performance = data.performance_24h || {};

            console.log('[DEBUG] trade signals count:', signals.length);

            // Update summary stats
            signalCount.textContent = signals.length;
            longCount.textContent = summary.long_signals || 0;
            shortCount.textContent = summary.short_signals || 0;
            winRate.textContent = performance.win_rate !== undefined ? `${performance.win_rate}%` : '--';
            winLoss.textContent = `${performance.wins || 0}/${performance.losses || 0}`;

            // Render signal cards
            signalsList.innerHTML = '';

            if (signals.length > 0) {
                signals.forEach(signal => {
                    signalsList.innerHTML += createTradeSignalCard(signal);
                });
                // Re-initialize Lucide icons for new cards
                if (typeof lucide !== 'undefined') {
                    lucide.createIcons();
                }
            } else {
                signalsList.innerHTML = createEmptyState('No active trade signals');
            }
        }

        // Legacy updateSignals for backward compatibility
        function updateSignals(data) {
            const signals = Array.isArray(data) ? data : (data.signals || []);
            updateTradeSignals({ signals: signals, summary: {}, performance_24h: {} });
        }


        function updateAlpha(data) {
            console.log('[DEBUG] updateAlpha() called');
            console.log('[DEBUG] Alpha data.opportunities:', data.opportunities?.length || 0);
            const alphaList = document.getElementById('alphaList');
            alphaList.innerHTML = '';

            if (data.opportunities && data.opportunities.length > 0) {
                data.opportunities.forEach(alpha => {
                    alphaList.innerHTML += createAlphaCard(alpha);
                });
            } else {
                alphaList.innerHTML = createEmptyState('No alpha opportunities');
            }
        }

        // ═══════════════════════════════════════════════════════════════════
        // MOMENTUM WAVES NATIVE WIDGET
        // ═══════════════════════════════════════════════════════════════════

        function createMomentumSparkline(scoreHistory, width = 55, height = 20) {
            if (!scoreHistory || scoreHistory.length < 2) {
                return '';
            }

            const data = scoreHistory.slice(-12);
            const min = Math.min(...data);
            const max = Math.max(...data);
            const range = max - min || 1;
            const padding = 2;

            const points = data.map((val, i) => {
                const x = padding + (i / (data.length - 1)) * (width - padding * 2);
                const y = padding + (height - padding * 2) - ((val - min) / range) * (height - padding * 2);
                return `${x.toFixed(1)},${y.toFixed(1)}`;
            });

            return `<svg class="momentum-sparkline-mobile" viewBox="0 0 ${width} ${height}" preserveAspectRatio="none">
                <path class="sparkline-path-mobile" d="M${points.join(' L')}"/>
            </svg>`;
        }

        function formatMomentumPrice(price) {
            if (price === null || price === undefined) return '-';
            if (price >= 10000) return price.toLocaleString('en-US', { maximumFractionDigits: 0 });
            if (price >= 100) return price.toFixed(1);
            if (price >= 1) return price.toFixed(2);
            if (price >= 0.01) return price.toFixed(4);
            return price.toFixed(6);
        }

        function formatMomentumChange(change) {
            if (change === null || change === undefined) return '-';
            const prefix = change >= 0 ? '+' : '';
            return prefix + change.toFixed(1) + '%';
        }

        function updateMomentumWaves(confluenceScores) {
            const container = document.getElementById('momentumWavesContainer');
            const countBadge = document.getElementById('momentumWavesCount');

            if (!container) return;

            const validScores = (confluenceScores || []).filter(s => s && s.symbol && !s.symbol.includes('SYSTEM'));

            // Sort by signal strength: bullish/bearish first, then warming, then neutral
            validScores.sort((a, b) => {
                const scoreA = a.score || a.confluence_score || 50;
                const scoreB = b.score || b.confluence_score || 50;
                // Priority: bullish(≥65) or bearish(≤35) = 2, warming(60-64 or 36-40) = 1, neutral = 0
                const priorityA = (scoreA >= 65 || scoreA <= 35) ? 2 : (scoreA >= 60 || scoreA <= 40) ? 1 : 0;
                const priorityB = (scoreB >= 65 || scoreB <= 35) ? 2 : (scoreB >= 60 || scoreB <= 40) ? 1 : 0;
                // First sort by priority (higher first)
                if (priorityA !== priorityB) return priorityB - priorityA;
                // Within same priority, sort by distance from 50 (stronger signals first)
                return Math.abs(scoreB - 50) - Math.abs(scoreA - 50);
            });

            // Update count badge
            if (countBadge) {
                countBadge.textContent = validScores.length;
            }

            if (validScores.length === 0) {
                container.innerHTML = `
                    <div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: var(--text-muted);">
                        <i data-lucide="waves" style="width: 32px; height: 32px; margin-bottom: 8px; opacity: 0.5;"></i>
                        <div style="font-size: 12px;">No momentum data available</div>
                    </div>
                `;
                if (typeof lucide !== 'undefined') lucide.createIcons();
                return;
            }

            // 8-level pulse duration system
            const pulseLevels = [
                { threshold: 45, duration: 0.5 },
                { threshold: 40, duration: 0.7 },
                { threshold: 35, duration: 0.9 },
                { threshold: 28, duration: 1.2 },
                { threshold: 20, duration: 1.6 },
                { threshold: 12, duration: 2.2 },
                { threshold: 5, duration: 3.0 },
                { threshold: 0, duration: 4.5 }
            ];

            const cardsHtml = validScores.slice(0, 20).map((score, index) => {
                const change = score.change_24h || score.price_change_24h || score.change || 0;
                const confluenceScore = score.score || score.confluence_score || 50;
                // Direction and signal class with amber warming zones
                const direction = confluenceScore >= 65 ? 'LONG' :
                                 confluenceScore >= 60 ? 'WARM' :
                                 confluenceScore <= 35 ? 'SHORT' :
                                 confluenceScore <= 40 ? 'COOL' : 'NEUTRAL';
                const signalClass = confluenceScore >= 65 ? 'bullish' :
                                   confluenceScore >= 60 ? 'warming' :
                                   confluenceScore <= 35 ? 'bearish' :
                                   confluenceScore <= 40 ? 'warming' : 'neutral';
                const symbol = score.symbol.replace('USDT', '');
                const fullSymbol = score.symbol;
                const cardId = `alpha_pulse_${symbol}_${index}`;

                const sparkline = createMomentumSparkline(score.score_history);
                const circumference = 2 * Math.PI * 14; // radius 14 for 36px circle
                const offset = circumference - (confluenceScore / 100) * circumference;

                const trendArrow = change >= 0
                    ? '<span class="momentum-trend-arrow-mobile" style="color: #34d399;">&#9650;</span>'
                    : '<span class="momentum-trend-arrow-mobile" style="color: #f87171;">&#9660;</span>';

                // Calculate pulse intensity
                const intensity = Math.abs(confluenceScore - 50);
                const pulseDuration = pulseLevels.find(l => intensity >= l.threshold).duration;

                // Extract component scores
                const components = score.components || score.results || {};
                const componentScores = {
                    technical: components.technical || 50,
                    volume: components.volume || 50,
                    orderflow: components.orderflow || 50,
                    orderbook: components.orderbook || 50,
                    position: components.position || 50,
                    sentiment: components.sentiment || 50
                };

                // Generate component bars HTML
                const componentBarsHtml = Object.entries(componentScores).map(([comp, compScore]) => {
                    const height = Math.max(8, (compScore / 100) * 24);
                    const barColor = compScore >= 65 ? 'var(--accent-positive)' : compScore <= 35 ? 'var(--accent-negative)' : 'var(--accent-warning)';
                    return `<div style="flex: 1; background: rgba(255, 255, 255, 0.08); border-radius: 2px; height: 24px; position: relative; overflow: hidden;">
                        <div style="position: absolute; bottom: 0; width: 100%; height: ${height}px; background: ${barColor}; opacity: 0.85;"></div>
                    </div>`;
                }).join('');

                // Generate expanded breakdown HTML with CSS Grid alignment
                const breakdownHtml = `<div style="display: grid; grid-template-columns: 80px 1fr 28px; gap: 6px 12px; align-items: center;">` +
                    Object.entries(componentScores).map(([comp, compScore]) => {
                        const compColor = compScore >= 65 ? 'var(--accent-positive)' : compScore <= 35 ? 'var(--accent-negative)' : 'var(--accent-warning)';
                        const compName = comp.charAt(0).toUpperCase() + comp.slice(1);
                        return `
                        <span style="font-size: 10px; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${compName}</span>
                        <div style="height: 4px; background: rgba(255, 255, 255, 0.1); border-radius: 2px; overflow: hidden;">
                            <div style="width: ${compScore}%; height: 100%; background: ${compColor}; transition: width 0.3s ease;"></div>
                        </div>
                        <span style="font-size: 11px; font-weight: 600; color: ${compColor}; text-align: right;">${Math.round(compScore)}</span>`;
                    }).join('') + `</div>`;

                return `
                    <div class="momentum-card-mobile ${signalClass}" style="--pulse-duration: ${pulseDuration}s; cursor: pointer; overflow: visible; transition: all 0.3s ease;" id="${cardId}">
                        <div class="card-pulse-ring-mobile"></div>
                        <div style="display: flex; flex-direction: row;">
                            <!-- Main card content with touch feedback -->
                            <div class="momentum-card-inner-mobile"
                                 onclick="toggleAlphaPulseCard('${cardId}')"
                                 ontouchstart="this.style.transform='scale(0.98)'; this.style.opacity='0.85';"
                                 ontouchend="this.style.transform=''; this.style.opacity='';"
                                 style="flex: 1; min-width: 0; transition: transform 0.15s ease, opacity 0.15s ease;">
                                <div class="momentum-card-header">
                                    <span class="momentum-symbol-mobile">${symbol}</span>
                                    <span class="momentum-signal-badge-mobile ${direction}">${direction}</span>
                                </div>
                                <div class="momentum-card-body">
                                    <div class="momentum-metrics-mobile">
                                        <div class="momentum-metric-mobile">
                                            <span class="momentum-metric-label-mobile">PRC</span>
                                            <span class="momentum-metric-value-mobile">${formatMomentumPrice(score.price || 0)}</span>
                                        </div>
                                        <div class="momentum-metric-mobile">
                                            <span class="momentum-metric-label-mobile">24H</span>
                                            <span class="momentum-metric-value-mobile ${change >= 0 ? 'positive' : 'negative'}">
                                                ${formatMomentumChange(change)}${trendArrow}
                                            </span>
                                        </div>
                                    </div>
                                    <div class="momentum-score-container-mobile">
                                        ${sparkline}
                                        <div class="momentum-score-circle-mobile">
                                            <div class="momentum-pulse-ring-mobile"></div>
                                            <svg class="momentum-score-ring-mobile" width="36" height="36" viewBox="0 0 36 36">
                                                <circle class="momentum-score-ring-bg-mobile" cx="18" cy="18" r="14"/>
                                                <circle class="momentum-score-ring-progress-mobile"
                                                    cx="18" cy="18" r="14"
                                                    stroke-dasharray="${circumference}"
                                                    stroke-dashoffset="${offset}"/>
                                            </svg>
                                            <div class="momentum-score-inner-mobile">
                                                <span class="momentum-score-value-mobile">${Math.round(confluenceScore)}</span>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <!-- Mini component bars -->
                                <div style="display: flex; gap: 2px; margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.05);">
                                    ${componentBarsHtml}
                                </div>
                                <!-- Tap indicator - down chevron (flips up on expand) -->
                                <div style="display: flex; justify-content: center; margin-top: 6px;">
                                    <i data-lucide="chevron-down" style="width: 16px; height: 16px; color: var(--text-secondary); opacity: 0.6; transition: transform 0.3s ease;" id="${cardId}_chevron"></i>
                                </div>
                            </div>
                            <!-- Horizontal slide: Action buttons only -->
                            <div id="${cardId}_buttons" style="display: none; width: 0; overflow: hidden; border-left: 1px solid var(--border-light); background: rgba(0,0,0,0.2); opacity: 0; transition: all 0.3s ease;">
                                <div style="padding: 8px; min-width: 70px; display: flex; flex-direction: column; gap: 6px; height: 100%; justify-content: center;">
                                    <button onclick="event.stopPropagation(); viewDetailedAnalysis('${fullSymbol}')" style="min-height: 44px; padding: 8px; background: var(--accent-primary); border: none; border-radius: 6px; color: var(--bg-primary); font-size: 11px; font-weight: 700; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 4px; touch-action: manipulation;">
                                        <i data-lucide="chart-line" style="width: 14px; height: 14px;"></i>
                                    </button>
                                    <button onclick="event.stopPropagation(); viewAlerts('${fullSymbol}')" style="min-height: 44px; padding: 8px; background: rgba(255, 191, 0, 0.15); border: 1px solid rgba(251, 191, 36, 0.3); border-radius: 6px; color: var(--text-primary); font-size: 11px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 4px; touch-action: manipulation;">
                                        <i data-lucide="bell" style="width: 14px; height: 14px;"></i>
                                    </button>
                                </div>
                            </div>
                        </div>
                        <!-- Vertical expansion: Breakdown grid (full width below card) -->
                        <div id="${cardId}_expanded" style="display: none; max-height: 0; overflow: hidden; opacity: 0; transition: all 0.3s ease; border-top: 1px solid var(--border-light); background: rgba(0,0,0,0.15);">
                            <div style="padding: 12px;">
                                <h4 style="font-size: 10px; font-weight: 600; color: var(--text-primary); margin-bottom: 10px; text-transform: uppercase; letter-spacing: 0.5px;">Score Breakdown</h4>
                                ${breakdownHtml}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = cardsHtml;

            // Re-init Lucide icons
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }

        // Store alerts data for filtering
        let currentAlertsData = [];
        let currentAlertFilter = 'all';

        function updateAlerts(data) {
            // Handle both array response and {alerts: [...]} object response
            const alerts = Array.isArray(data) ? data : (data.alerts || []);
            console.log('[DEBUG] updateAlerts() called, alerts:', alerts.length);

            // Store for filtering
            currentAlertsData = alerts;

            // Update count badge
            document.getElementById('alertCount').textContent = alerts.length;

            // Render with current filter
            renderAlerts(alerts, currentAlertFilter);

            // Also render signal alerts in the Signals tab
            renderAlertedSignals(alerts);
        }

        function renderAlerts(alerts, filter) {
            const alertsList = document.getElementById('alertsList');

            // Apply filter
            let filteredAlerts = alerts;
            if (filter !== 'all') {
                // Signal filter should match 'signal', 'high_confluence', and 'confluence' types
                if (filter === 'signal') {
                    filteredAlerts = alerts.filter(a => {
                        const alertType = a.alert_type || a.details?.type || '';
                        return alertType === 'signal' ||
                               alertType === 'high_confluence' ||
                               alertType === 'confluence';  // Include confluence alerts - these are LONG/SHORT trading signals
                    });
                } else {
                    filteredAlerts = alerts.filter(a => {
                        const alertType = a.alert_type || a.details?.type || '';
                        return alertType === filter;
                    });
                }
            }

            alertsList.innerHTML = '';

            if (filteredAlerts.length > 0) {
                filteredAlerts.forEach(alert => {
                    alertsList.innerHTML += createAlertCard(alert);
                });
            } else {
                // Special empty state for signal filter - match the Alerted card style
                if (filter === 'signal') {
                    alertsList.innerHTML = `
                        <div style="text-align: center; padding: 24px 16px;">
                            <i data-lucide="radar" style="width: 28px; height: 28px; color: var(--accent-positive); margin-bottom: 8px; opacity: 0.7;"></i>
                            <div style="font-size: 12px; color: var(--text-primary); font-weight: 500;">Scanning for opportunities</div>
                            <div style="font-size: 10px; margin-top: 4px; color: var(--text-secondary);">High-conviction signals will appear here</div>
                        </div>
                    `;
                } else {
                    const filterNames = {
                        'whale_trade': 'whale',
                        'liquidation_cascade': 'liquidation',
                        'regime_change': 'regime'
                    };
                    const filterName = filterNames[filter] || '';
                    alertsList.innerHTML = createEmptyState(`No ${filterName} alerts`);
                }
            }

            // Initialize Lucide icons for filter pills
            setTimeout(() => { if (typeof lucide !== 'undefined') lucide.createIcons(); }, 50);
        }

        function filterAlerts(filter) {
            currentAlertFilter = filter;

            // Update pill active states
            document.querySelectorAll('.alert-filter-pill').forEach(pill => {
                pill.classList.remove('active');
                if (pill.dataset.filter === filter) {
                    pill.classList.add('active');
                }
            });

            // Re-render with filter
            renderAlerts(currentAlertsData, filter);
        }

        // Render signal-type alerts in the Signals tab
        function renderAlertedSignals(alerts) {
            const alertedSignalsList = document.getElementById('alertedSignalsList');
            const alertedSignalCount = document.getElementById('alertedSignalCount');

            // Filter for signal-type alerts (including confluence alerts which are trading signals)
            const signalAlerts = alerts.filter(a =>
                a.type === 'signal' ||
                a.type === 'high_confluence' ||
                a.type === 'confluence'  // Include confluence alerts - these are LONG/SHORT trading signals
            );

            // Update count
            alertedSignalCount.textContent = signalAlerts.length;
            alertedSignalsList.innerHTML = '';

            if (signalAlerts.length === 0) {
                // Show positive empty state
                alertedSignalsList.innerHTML = `
                    <div style="text-align: center; padding: 16px;">
                        <i data-lucide="radar" style="width: 28px; height: 28px; color: var(--accent-positive); margin-bottom: 8px; opacity: 0.7;"></i>
                        <div style="font-size: 12px; color: var(--text-primary); font-weight: 500;">Scanning for opportunities</div>
                        <div style="font-size: 10px; margin-top: 4px; color: var(--text-secondary);">High-conviction signals will appear here</div>
                    </div>
                `;
            } else {
                // Render each signal alert using an expandable card format (like Alpha Pulse)
                signalAlerts.forEach((alert, index) => {
                    alertedSignalsList.innerHTML += createAlertedSignalCard(alert, index);
                });
            }

            // Initialize Lucide icons
            setTimeout(() => { if (typeof lucide !== 'undefined') lucide.createIcons(); }, 50);
        }

        // Track currently expanded alerted signal card (accordion behavior)
        let currentlyExpandedAlertedSignal = null;

        // Create an expandable card for alerted signals (similar to Alpha Pulse cards)
        function createAlertedSignalCard(alert, index) {
            const symbol = alert.symbol || 'UNKNOWN';
            const details = alert.details || {};
            const signalType = details.signal_type || details.type || '';
            const confluenceScore = details.confluence_score || details.score || 0;

            // Parse timestamp for relative time and report filename
            let alertDate;
            let alertTimestamp = '';
            if (alert.unix_timestamp) {
                alertDate = new Date(alert.unix_timestamp * 1000);
                alertTimestamp = alertDate.toISOString().replace(/[-:T]/g, '').slice(0, 15);
            } else if (alert.timestamp) {
                alertDate = new Date(alert.timestamp.replace(' ', 'T') + 'Z');
                alertTimestamp = alertDate.toISOString().replace(/[-:T]/g, '').slice(0, 15);
            } else {
                alertDate = new Date();
                alertTimestamp = alertDate.toISOString().replace(/[-:T]/g, '').slice(0, 15);
            }
            const relativeTime = formatRelativeTime(alertDate);

            // Direction
            const isLong = signalType.toUpperCase() === 'LONG' || signalType.toUpperCase() === 'BUY';
            const direction = isLong ? 'LONG' : 'SHORT';
            const dirColor = isLong ? 'var(--accent-positive)' : 'var(--accent-negative)';
            const dirBg = isLong ? 'rgba(16, 185, 129, 0.15)' : 'rgba(239, 68, 68, 0.15)';
            const dirIcon = isLong ? 'trending-up' : 'trending-down';
            const borderColor = isLong ? 'rgba(16, 185, 129, 0.3)' : 'rgba(239, 68, 68, 0.3)';

            // Score color
            const scoreColor = confluenceScore >= 70 ? 'var(--accent-positive)' : confluenceScore >= 55 ? 'var(--neon-amber)' : 'var(--text-secondary)';

            // Clean symbol
            const displaySymbol = symbol.replace(/USDT$/i, '');
            const fullSymbol = symbol.replace(/USDT$/i, 'USDT');

            // Generate unique card ID
            const cardId = `alerted_signal_${displaySymbol}_${index}`;

            // Extract price levels if available
            const entryPrice = parseFloat(details.entry_price || details.price || 0);
            const stopLoss = parseFloat(details.stop_loss || 0);
            const takeProfit = parseFloat(details.take_profit || 0);

            const formatPrice = (p) => {
                if (p >= 1000) return p.toFixed(2);
                if (p >= 1) return p.toFixed(4);
                return p.toFixed(6);
            };

            // Build price info if available
            let priceInfo = '';
            if (entryPrice > 0) {
                priceInfo = `
                    <div style="display: flex; gap: 12px; margin-top: 10px; padding-top: 10px; border-top: 1px solid var(--border-light);">
                        ${stopLoss > 0 ? `<div><span style="font-size: 9px; color: var(--accent-negative);">SL</span><div style="font-size: 12px; color: var(--text-primary);">$${formatPrice(stopLoss)}</div></div>` : ''}
                        <div><span style="font-size: 9px; color: var(--neon-amber);">ENTRY</span><div style="font-size: 12px; color: var(--neon-amber); font-weight: 600;">$${formatPrice(entryPrice)}</div></div>
                        ${takeProfit > 0 ? `<div><span style="font-size: 9px; color: var(--accent-positive);">TP</span><div style="font-size: 12px; color: var(--text-primary);">$${formatPrice(takeProfit)}</div></div>` : ''}
                    </div>
                `;
            }

            return `
                <div id="${cardId}" style="background: var(--bg-secondary); border: 1px solid ${borderColor}; border-radius: 10px; margin-bottom: 8px; overflow: hidden; transition: all 0.3s ease;">
                    <div style="display: flex; flex-direction: row;">
                        <!-- Main card content (clickable) -->
                        <div class="alerted-signal-inner"
                             onclick="toggleAlertedSignalCard('${cardId}')"
                             ontouchstart="this.style.transform='scale(0.98)'; this.style.opacity='0.85';"
                             ontouchend="this.style.transform=''; this.style.opacity='';"
                             style="flex: 1; min-width: 0; padding: 12px; cursor: pointer; transition: transform 0.15s ease, opacity 0.15s ease;">
                            <!-- Header -->
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <span style="font-weight: 700; font-size: 15px; color: var(--text-primary);">${displaySymbol}</span>
                                    <div style="background: ${dirBg}; padding: 3px 8px; border-radius: 5px; display: flex; align-items: center; gap: 3px;">
                                        <i data-lucide="${dirIcon}" style="width: 12px; height: 12px; color: ${dirColor};"></i>
                                        <span style="font-size: 11px; font-weight: 600; color: ${dirColor};">${direction}</span>
                                    </div>
                                </div>
                                <div style="display: flex; align-items: center; gap: 6px;">
                                    <div style="background: rgba(16, 185, 129, 0.15); padding: 3px 6px; border-radius: 4px;">
                                        <i data-lucide="bell" style="width: 10px; height: 10px; color: var(--accent-positive);"></i>
                                    </div>
                                    <div style="background: ${scoreColor}20; padding: 3px 8px; border-radius: 5px;">
                                        <span style="font-size: 12px; font-weight: 700; color: ${scoreColor};">${confluenceScore.toFixed(0)}</span>
                                    </div>
                                </div>
                            </div>
                            <!-- Time -->
                            <div style="font-size: 10px; color: var(--text-secondary); margin-top: 6px;">
                                Alerted ${relativeTime}
                            </div>
                            ${priceInfo}
                            <!-- Tap indicator (chevron that flips on expand) -->
                            <div style="display: flex; justify-content: center; margin-top: 8px;">
                                <i data-lucide="chevron-down" style="width: 14px; height: 14px; color: var(--text-secondary); opacity: 0.5; transition: transform 0.3s ease;" id="${cardId}_chevron"></i>
                            </div>
                        </div>
                        <!-- Horizontal slide: Action buttons panel -->
                        <div id="${cardId}_buttons" style="display: none; width: 0; overflow: hidden; border-left: 1px solid var(--border-light); background: rgba(0,0,0,0.2); opacity: 0; transition: all 0.3s ease;">
                            <div style="padding: 8px; min-width: 80px; display: flex; flex-direction: column; gap: 6px; height: 100%; justify-content: center;">
                                <!-- Alpha Analysis Button -->
                                <button onclick="event.stopPropagation(); viewDetailedAnalysis('${fullSymbol}')"
                                        style="min-height: 40px; padding: 8px; background: var(--accent-primary); border: none; border-radius: 6px; color: var(--bg-primary); font-size: 10px; font-weight: 700; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 2px; touch-action: manipulation;">
                                    <i data-lucide="bar-chart-3" style="width: 16px; height: 16px;"></i>
                                    <span>Analysis</span>
                                </button>
                                <!-- HTML Report Button -->
                                <button onclick="event.stopPropagation(); viewAlertReport('${fullSymbol}', '${alertTimestamp}')"
                                        style="min-height: 40px; padding: 8px; background: rgba(255, 191, 0, 0.15); border: 1px solid rgba(251, 191, 36, 0.3); border-radius: 6px; color: var(--neon-amber); font-size: 10px; font-weight: 600; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 2px; touch-action: manipulation;">
                                    <i data-lucide="file-text" style="width: 16px; height: 16px;"></i>
                                    <span>Report</span>
                                </button>
                                <!-- Trade Button -->
                                <button onclick="event.stopPropagation(); window.open('https://www.bybit.com/trade/usdt/${fullSymbol}', '_blank')"
                                        style="min-height: 40px; padding: 8px; background: rgba(16, 185, 129, 0.15); border: 1px solid rgba(16, 185, 129, 0.3); border-radius: 6px; color: var(--accent-positive); font-size: 10px; font-weight: 600; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 2px; touch-action: manipulation;">
                                    <i data-lucide="external-link" style="width: 16px; height: 16px;"></i>
                                    <span>Trade</span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        // Store symbols data for sorting
        let currentSymbolsData = [];
        
        function updateSymbols(data) {
            const symbolsList = document.getElementById('analyzedSymbolsList');
            const symbolsCount = document.getElementById('symbolsCount');

            const symbols = data.symbols || [];
            currentSymbolsData = symbols; // Store for sorting
            
            // Only update if element exists (Beta tab may not be loaded yet)
            if (symbolsCount) {
                symbolsCount.textContent = symbols.length;
            }
            
            renderSymbols(symbols);

            // Initialize Lucide icons for the new elements
            setTimeout(() => { if (typeof lucide !== 'undefined') lucide.createIcons(); }, 100);
        }

        function renderSymbols(symbols) {
            const symbolsList = document.getElementById('analyzedSymbolsList');
            
            // Beta tab may not be loaded yet
            if (!symbolsList) {
                console.warn('[WARN] analyzedSymbolsList element not found, skipping render');
                return;
            }
            
            symbolsList.innerHTML = '';
            
            if (symbols.length > 0) {
                symbols.forEach(symbol => {
                    symbolsList.innerHTML += createAnalyzedSymbolItem(symbol);
                });
            } else {
                symbolsList.innerHTML = '<div class="empty-state" style="text-align: center; color: var(--text-secondary); padding: 20px; grid-column: 1 / -1;">No symbols data available</div>';
            }
        }
        
        function sortSymbols() {
            const sortSelector = document.getElementById('sortSelector');
            if (!sortSelector) {
                console.warn('[WARN] sortSelector element not found, using default sort');
                return;
            }
            
            const sortBy = sortSelector.value;
            let sortedSymbols = [...currentSymbolsData];
            
            switch(sortBy) {
                case 'score':
                    sortedSymbols.sort((a, b) => (b.confluence_score || b.score || 0) - (a.confluence_score || a.score || 0));
                    break;
                case 'change':
                    sortedSymbols.sort((a, b) => {
                        const changeA = parseFloat(a.price_change_percent || a.change_24h || 0);
                        const changeB = parseFloat(b.price_change_percent || b.change_24h || 0);
                        return changeB - changeA;
                    });
                    break;
                case 'volume':
                    sortedSymbols.sort((a, b) => {
                        const priceA = a.price || a.current_price || 0;
                        const priceB = b.price || b.current_price || 0;
                        const volumeA = a.volume_usd || a.quote_volume || ((a.volume || a.volume_24h || 0) * priceA) || 0;
                        const volumeB = b.volume_usd || b.quote_volume || ((b.volume || b.volume_24h || 0) * priceB) || 0;
                        return volumeB - volumeA;
                    });
                    break;
                case 'symbol':
                    sortedSymbols.sort((a, b) => (a.symbol || a).localeCompare(b.symbol || b));
                    break;
            }
            
            renderSymbols(sortedSymbols);
            setTimeout(() => { if (typeof lucide !== 'undefined') lucide.createIcons(); }, 100);
        }

        function updateMarketOverview(data) {
            console.log('[DEBUG] updateMarketOverview called with:', data);
            console.log('[DEBUG] data keys:', Object.keys(data || {}));

            // === FEAR & GREED INDEX (Compact Display) ===
            const fearGreedValue = parseInt(data.fear_greed_value || 50);
            const fearGreedLabel = data.fear_greed_label || 'Neutral';
            document.getElementById('fearGreedValue').textContent = fearGreedValue;
            document.getElementById('fearGreedLabel').textContent = fearGreedLabel;

            // Color based on value
            const fearGreedValueEl = document.getElementById('fearGreedValue');
            if (fearGreedValue <= 25) {
                fearGreedValueEl.style.color = '#f44336'; // Extreme Fear - Red
            } else if (fearGreedValue <= 45) {
                fearGreedValueEl.style.color = '#ff9800'; // Fear - Orange
            } else if (fearGreedValue <= 55) {
                fearGreedValueEl.style.color = 'var(--accent-warning)'; // Neutral - Yellow
            } else if (fearGreedValue <= 75) {
                fearGreedValueEl.style.color = '#8bc34a'; // Greed - Light Green
            } else {
                fearGreedValueEl.style.color = '#4caf50'; // Extreme Greed - Green
            }

            // === MARKET REGIME ===
            // Format: "Category: Label" (e.g., "Bearish: Risk-Off", "Strong Bullish: Euphoric Rally")
            const regimeData = data.market_regime || data.regime || 'Neutral: Unknown';
            const regime = safeExtractValue(regimeData, 'Neutral: Unknown', false);
            const regimeContainer = document.getElementById('marketRegime');
            const regimeCategoryEl = document.getElementById('regimeCategory');
            const regimeLabelEl = document.getElementById('regimeLabel');
            if (regimeContainer && regimeCategoryEl) {
                // Split into category and label
                const parts = regime.split(':');
                const category = parts[0].trim();
                const label = parts.length > 1 ? parts[1].trim() : '';

                // Set the two-line content
                regimeCategoryEl.textContent = category;
                if (regimeLabelEl) {
                    regimeLabelEl.textContent = label;
                }

                // Apply background color based on category
                const categoryUpper = category.toUpperCase();
                if (categoryUpper.includes('BULLISH')) {
                    regimeContainer.style.background = 'rgba(76, 175, 80, 0.2)';
                    regimeCategoryEl.style.color = 'var(--accent-positive)';
                } else if (categoryUpper.includes('BEARISH')) {
                    regimeContainer.style.background = 'rgba(244, 67, 54, 0.2)';
                    regimeCategoryEl.style.color = 'var(--accent-negative)';
                } else {
                    // Neutral regimes
                    regimeContainer.style.background = 'rgba(255, 191, 0, 0.15)';
                    regimeCategoryEl.style.color = 'var(--text-primary)';
                }
            }

            // === TOTAL MARKET CAP & 24H VOLUME ===
            const totalMarketCap = parseFloat(data.total_market_cap || 0);
            const marketCapChange = parseFloat(data.market_cap_change_24h || 0);

            document.getElementById('totalMarketCap').textContent = formatMarketCap(totalMarketCap);

            const mcapChangeEl = document.getElementById('marketCapChange');
            mcapChangeEl.textContent = (marketCapChange >= 0 ? '+' : '') + marketCapChange.toFixed(2) + '%';
            if (marketCapChange >= 0) {
                mcapChangeEl.style.background = 'rgba(76, 175, 80, 0.2)';
                mcapChangeEl.style.color = 'var(--accent-positive)';
            } else {
                mcapChangeEl.style.background = 'rgba(244, 67, 54, 0.2)';
                mcapChangeEl.style.color = 'var(--accent-negative)';
            }

            // Update 24H Volume (now in market cap row)
            const totalVolume = parseFloat(data.total_volume || data.coingecko_volume_24h || 0);
            document.getElementById('totalVolume').textContent = formatMarketCap(totalVolume);

            // === DOMINANCE BREAKDOWN ===
            const btcDom = parseFloat(data.btc_dominance || 57);
            const ethDom = parseFloat(data.eth_dominance || 12);
            const stableDom = parseFloat(data.stablecoin_dominance || 8);
            // Calculate altcoin dominance (everything else)
            const altDom = Math.max(0, 100 - btcDom - ethDom - stableDom);

            // Update text labels
            document.getElementById('btcDominance').textContent = btcDom.toFixed(1) + '%';
            document.getElementById('ethDominance').textContent = ethDom.toFixed(1) + '%';
            document.getElementById('stableDominance').textContent = stableDom.toFixed(1) + '%';
            document.getElementById('altDominance').textContent = altDom.toFixed(1) + '%';

            // Update bar widths (scale to fit, minimum widths handled by CSS)
            const scale = 100 / (btcDom + ethDom + stableDom + altDom);
            document.getElementById('btcDomBar').style.width = `${btcDom * scale}%`;
            document.getElementById('ethDomBar').style.width = `${ethDom * scale}%`;
            document.getElementById('stableDomBar').style.width = `${stableDom * scale}%`;
            document.getElementById('altDomBar').style.width = `${altDom * scale}%`;

            // === TREND STRENGTH ===
            const trendStrength = parseFloat(data.trend_strength || 50);
            document.getElementById('trendStrength').textContent = Math.round(trendStrength);
            document.getElementById('trendStrengthBar').style.width = `${trendStrength}%`;

            const trendBar = document.getElementById('trendStrengthBar');
            if (trendStrength >= 70) {
                trendBar.style.background = 'var(--accent-positive)';
            } else if (trendStrength >= 30) {
                trendBar.style.background = 'var(--accent-warning)';
            } else {
                trendBar.style.background = 'var(--accent-negative)';
            }

            // === VOLATILITY ===
            const currentVol = parseFloat(data.current_volatility || data.volatility || data.market_dispersion || 0);
            const avgVol = parseFloat(data.avg_volatility || data.avg_market_dispersion || 8);
            document.getElementById('currentVolatility').textContent = currentVol.toFixed(1) + '%';
            document.getElementById('avgVolatility').textContent = avgVol.toFixed(1) + '%';

            const descriptorElement = document.getElementById('volatilityDescriptor');
            let descriptor = '';
            let descriptorColor = '';

            if (currentVol < 3) {
                descriptor = 'Very Low';
                descriptorColor = 'var(--accent-positive)';
            } else if (currentVol < 5) {
                descriptor = 'Low';
                descriptorColor = 'var(--accent-positive)';
            } else if (currentVol < 10) {
                descriptor = 'Normal';
                descriptorColor = 'var(--text-primary)';
            } else if (currentVol < 15) {
                descriptor = 'Elevated';
                descriptorColor = '#FFA500';
            } else if (currentVol < 20) {
                descriptor = 'High';
                descriptorColor = 'var(--accent-negative)';
            } else if (currentVol < 30) {
                descriptor = 'Very High';
                descriptorColor = 'var(--accent-negative)';
            } else {
                descriptor = 'Extreme';
                descriptorColor = '#FF0000';
            }

            descriptorElement.textContent = descriptor;
            descriptorElement.style.color = descriptorColor;

            const volElement = document.getElementById('currentVolatility');
            if (currentVol > avgVol * 1.2) {
                volElement.style.color = 'var(--accent-negative)';
            } else if (currentVol > avgVol) {
                volElement.style.color = 'var(--accent-warning)';
            } else {
                volElement.style.color = 'var(--accent-positive)';
            }

            // === MARKET SENTIMENT BREADTH ===
            if (data.market_breadth) {
                const breadth = data.market_breadth;
                updateMarketBreadth(breadth.up || breadth.up_count || 0, breadth.down || breadth.down_count || 0);
            } else if (data.market_overview) {
                updateMarketBreadth(data.market_overview.gainers || 0, data.market_overview.losers || 0);
            } else if (data.gainers !== undefined || data.losers !== undefined) {
                updateMarketBreadth(data.gainers || 0, data.losers || 0);
            } else {
                updateMarketBreadth(0, 0);
            }

            // === ALTCOIN SEASON INDICATOR ===
            const altcoinSeason = data.altcoin_season || 'Dormant';
            const altSeasonEl = document.getElementById('altcoinSeason');
            altSeasonEl.textContent = altcoinSeason;

            if (altcoinSeason === 'Active') {
                altSeasonEl.style.background = 'rgba(139, 92, 246, 0.3)';
                altSeasonEl.style.color = '#c4b5fd';
            } else if (altcoinSeason === 'Emerging') {
                altSeasonEl.style.background = 'rgba(139, 92, 246, 0.2)';
                altSeasonEl.style.color = '#a78bfa';
            } else {
                altSeasonEl.style.background = 'rgba(139, 92, 246, 0.1)';
                altSeasonEl.style.color = '#8b5cf6';
            }
        }

        function formatMarketCap(value) {
            if (value >= 1e12) {
                return '$' + (value / 1e12).toFixed(2) + 'T';
            } else if (value >= 1e9) {
                return '$' + (value / 1e9).toFixed(2) + 'B';
            } else if (value >= 1e6) {
                return '$' + (value / 1e6).toFixed(2) + 'M';
            } else {
                return '$' + value.toFixed(0);
            }
        }
        
        function formatVolume(volume) {
            if (volume >= 1e9) {
                return '$' + (volume / 1e9).toFixed(2) + 'B';
            } else if (volume >= 1e6) {
                return '$' + (volume / 1e6).toFixed(2) + 'M';
            } else if (volume >= 1e3) {
                return '$' + (volume / 1e3).toFixed(2) + 'K';
            } else {
                return '$' + volume.toFixed(2);
            }
        }

        function formatTimestamp(timestamp) {
            // Format timestamp as compact date+time for mobile: "Dec 3, 2:04 PM"
            const date = new Date(timestamp);
            const now = new Date();
            const isToday = date.toDateString() === now.toDateString();
            const yesterday = new Date(now);
            yesterday.setDate(yesterday.getDate() - 1);
            const isYesterday = date.toDateString() === yesterday.toDateString();

            const timeStr = date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });

            if (isToday) {
                return timeStr;  // Just time for today's alerts
            } else if (isYesterday) {
                return `Yesterday, ${timeStr}`;
            } else {
                // Show month and day for older alerts
                const monthDay = date.toLocaleDateString([], { month: 'short', day: 'numeric' });
                return `${monthDay}, ${timeStr}`;
            }
        }

        // Format relative time (e.g., "2h ago", "5m ago")
        function formatRelativeTime(dateInput) {
            const date = new Date(dateInput);
            const now = new Date();
            const diffMs = now - date;
            const diffSec = Math.floor(diffMs / 1000);
            const diffMin = Math.floor(diffSec / 60);
            const diffHr = Math.floor(diffMin / 60);
            const diffDays = Math.floor(diffHr / 24);

            if (diffSec < 60) return 'just now';
            if (diffMin < 60) return `${diffMin}m ago`;
            if (diffHr < 24) return `${diffHr}h ago`;
            if (diffDays === 1) return 'yesterday';
            if (diffDays < 7) return `${diffDays}d ago`;
            return date.toLocaleDateString();
        }

        function updateTopMovers(data) {
            console.log('[DEBUG] updateTopMovers() called');
            console.log('[DEBUG] gainers:', data?.gainers?.length || 0, 'losers:', data?.losers?.length || 0);
            const gainersList = document.getElementById('topGainersList');
            const losersList = document.getElementById('topLosersList');

            // Clear loading state
            gainersList.innerHTML = '';
            losersList.innerHTML = '';

            // Get gainers and losers
            const gainers = data.gainers || [];
            const losers = data.losers || [];
            
            // Display top 5 gainers
            if (gainers.length > 0) {
                gainers.slice(0, 5).forEach(item => {
                    gainersList.innerHTML += createMoverItem(item, 'gainer');
                });
            } else {
                gainersList.innerHTML = '<div style="text-align: center; color: var(--text-secondary); font-size: 12px; padding: 10px;">No gainers found</div>';
            }
            
            // Display top 5 losers
            if (losers.length > 0) {
                losers.slice(0, 5).forEach(item => {
                    losersList.innerHTML += createMoverItem(item, 'loser');
                });
            } else {
                losersList.innerHTML = '<div style="text-align: center; color: var(--text-secondary); font-size: 12px; padding: 10px;">No losers found</div>';
            }
        }
        
        function createMoverItem(item, type) {
            const symbol = item.symbol || item;
            const displaySymbol = item.display_symbol || symbol;
            const change = parseFloat(item.change || item.change_24h || item.percentage || 0);
            const price = item.price || item.last || 0;
            const volume = item.volume || item.volume_24h || 0;
            
            const changeColor = type === 'gainer' ? 'var(--accent-positive)' : 'var(--accent-negative)';
            const changePrefix = type === 'gainer' ? '+' : '';
            
            // Use the cleaned display symbol (1000 prefix already removed from API)
            // Also remove USDT suffix for even cleaner display
            const finalDisplaySymbol = displaySymbol.replace('USDT', '').replace('USD', '');
            
            return `
                <div style="background: var(--bg-secondary); border: 1px solid var(--border-light); border-radius: 8px; padding: 10px; cursor: pointer;" onclick="viewSymbol('${symbol}')">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                        <span style="font-weight: 600; font-size: 13px; color: var(--text-primary);">${finalDisplaySymbol}</span>
                        <span style="font-weight: 700; font-size: 14px; color: ${changeColor};">${changePrefix}${Math.abs(change).toFixed(2)}%</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span style="font-size: 11px; color: var(--text-secondary);">$${price > 100 ? price.toFixed(2) : price.toFixed(4)}</span>
                        <span style="font-size: 10px; color: var(--text-secondary);">Vol: ${(volume / 1e6).toFixed(1)}M</span>
                    </div>
                </div>
            `;
        }

        // Component creators - Compact row format (matching Top Movers style)
        function createOpportunityCard(opp) {
            console.log('[DEBUG] createOpportunityCard() called with:', JSON.stringify(opp));
            if (!opp || !opp.symbol) {
                console.error('[DEBUG] Invalid opportunity object:', opp);
                return '<div style="padding: 8px; color: var(--text-secondary);">Invalid data</div>';
            }

            // Score color: green for high, yellow for medium, gray for low
            const scoreColor = opp.score >= 70 ? 'var(--accent-positive)' : opp.score >= 55 ? 'var(--accent-warning)' : 'var(--text-secondary)';
            const momentum = opp.momentum || `${opp.price_change > 0 ? '+' : ''}${(opp.price_change || 0).toFixed(1)}%`;
            const isBullish = opp.direction === 'bullish' || opp.price_change > 0;
            const momentumColor = isBullish ? 'var(--accent-positive)' : 'var(--accent-negative)';

            // SVG icons with appropriate colors
            const trendIcon = isBullish
                ? `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" style="vertical-align: middle;"><path d="M7 17L17 7M17 7H7M17 7V17" stroke="var(--accent-positive)" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/></svg>`
                : `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" style="vertical-align: middle;"><path d="M7 7L17 17M17 17H7M17 17V7" stroke="var(--accent-negative)" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
            const directionText = opp.direction || (isBullish ? 'bullish' : 'bearish');
            const directionColor = isBullish ? 'var(--accent-positive)' : 'var(--accent-negative)';

            // Option C: Dense Two-Column Layout - eliminates whitespace
            return `<div style="background: var(--bg-secondary); border: 1px solid var(--border-light); border-radius: 8px; padding: 10px; cursor: pointer; margin-bottom: 6px;" onclick="viewConfluenceAnalysis('${opp.symbol}')">
                    <div style="display: grid; grid-template-columns: 1fr auto; gap: 4px 10px;">
                        <div style="display: flex; flex-direction: column; gap: 2px;">
                            <span style="font-weight: 600; font-size: 14px; color: var(--text-primary);">${opp.symbol}</span>
                            <span style="font-size: 11px; color: ${directionColor}; display: flex; align-items: center; gap: 4px;">${trendIcon} ${directionText}</span>
                        </div>
                        <div style="display: flex; flex-direction: column; gap: 2px; text-align: right;">
                            <div style="display: flex; align-items: center; gap: 6px; justify-content: flex-end;">
                                <span style="font-size: 11px; font-weight: 600; color: ${scoreColor}; background: ${scoreColor}20; padding: 2px 6px; border-radius: 4px;">${opp.score}</span>
                                <span style="font-weight: 700; font-size: 14px; color: ${momentumColor};">${momentum}</span>
                            </div>
                            <span style="font-size: 11px; color: var(--text-secondary);">${opp.volume || 'N/A'}</span>
                        </div>
                    </div>
                </div>`;
        }

        function createTradeSignalCard(signal) {
            // Extract trade signal data
            const symbol = signal.symbol || 'N/A';
            const direction = signal.direction || 'NEUTRAL';
            const isLong = direction === 'LONG';
            const score = parseFloat(signal.confluence_score || 50);
            const entryPrice = parseFloat(signal.entry_price || signal.current_price || 0);
            const stopLoss = parseFloat(signal.stop_loss || 0);
            const takeProfit = parseFloat(signal.take_profit || 0);
            const currentPrice = parseFloat(signal.current_price || entryPrice);
            const rrRatio = parseFloat(signal.risk_reward_ratio || 2.0);
            const pnlPct = parseFloat(signal.current_pnl_pct || 0);
            const timeRemaining = parseFloat(signal.time_remaining_hours || 24);
            const status = signal.status || 'ACTIVE';
            const change24h = parseFloat(signal.change_24h || 0);

            // Format prices intelligently (more decimals for small prices)
            const formatPrice = (p) => {
                if (p >= 1000) return p.toFixed(2);
                if (p >= 1) return p.toFixed(4);
                return p.toFixed(6);
            };

            // Colors based on direction
            const dirColor = isLong ? 'var(--accent-positive)' : 'var(--accent-negative)';
            const dirBg = isLong ? 'rgba(16, 185, 129, 0.15)' : 'rgba(239, 68, 68, 0.15)';
            const dirIcon = isLong ? 'trending-up' : 'trending-down';

            // P&L color
            const pnlColor = pnlPct > 0 ? 'var(--accent-positive)' : pnlPct < 0 ? 'var(--accent-negative)' : 'var(--text-secondary)';
            const pnlPrefix = pnlPct > 0 ? '+' : '';

            // Status styling
            const statusStyles = {
                'ACTIVE': { color: 'var(--neon-amber)', bg: 'rgba(251, 191, 36, 0.15)', icon: 'circle-dot', text: 'Active' },
                'HIT_TP': { color: 'var(--accent-positive)', bg: 'rgba(16, 185, 129, 0.15)', icon: 'check-circle', text: 'TP Hit ✓' },
                'HIT_SL': { color: 'var(--accent-negative)', bg: 'rgba(239, 68, 68, 0.15)', icon: 'x-circle', text: 'SL Hit ✗' },
                'EXPIRED': { color: 'var(--text-secondary)', bg: 'rgba(128, 128, 128, 0.15)', icon: 'clock', text: 'Expired' }
            };
            const statusStyle = statusStyles[status] || statusStyles['ACTIVE'];

            // Score color
            const scoreColor = score >= 70 ? 'var(--accent-positive)' : score >= 55 ? 'var(--neon-amber)' : 'var(--text-secondary)';

            // Calculate distance to TP/SL for progress indicator
            const totalRange = Math.abs(takeProfit - stopLoss);
            const currentFromEntry = currentPrice - entryPrice;
            const progressPct = isLong
                ? ((currentPrice - stopLoss) / totalRange) * 100
                : ((stopLoss - currentPrice) / totalRange) * 100;
            const clampedProgress = Math.max(0, Math.min(100, progressPct));

            // Remove USDT suffix for cleaner display
            const displaySymbol = symbol.replace(/USDT$/i, '');
            const fullSymbol = symbol.replace(/USDT$/i, 'USDT');

            return `
                <div style="background: var(--bg-secondary); border: 1px solid var(--border-light); border-radius: 12px; padding: 14px; margin-bottom: 10px;">
                    <!-- Header: Symbol + Direction + Status -->
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span style="font-weight: 700; font-size: 16px; color: var(--text-primary);">${displaySymbol}</span>
                            <div style="background: ${dirBg}; padding: 4px 10px; border-radius: 6px; display: flex; align-items: center; gap: 4px;">
                                <i data-lucide="${dirIcon}" style="width: 14px; height: 14px; color: ${dirColor};"></i>
                                <span style="font-size: 12px; font-weight: 600; color: ${dirColor};">${direction}</span>
                            </div>
                        </div>
                        <div style="display: flex; align-items: center; gap: 6px;">
                            <div style="background: ${statusStyle.bg}; padding: 4px 8px; border-radius: 6px;">
                                <span style="font-size: 11px; font-weight: 500; color: ${statusStyle.color};">${statusStyle.text}</span>
                            </div>
                            <div style="background: ${scoreColor}20; padding: 4px 8px; border-radius: 6px;">
                                <span style="font-size: 12px; font-weight: 700; color: ${scoreColor};">${score.toFixed(0)}</span>
                            </div>
                        </div>
                    </div>

                    <!-- Price Levels Grid -->
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-bottom: 12px;">
                        <div style="background: rgba(0,0,0,0.2); padding: 8px; border-radius: 6px; text-align: center;">
                            <div style="font-size: 9px; color: var(--accent-negative); text-transform: uppercase; margin-bottom: 2px;">Stop Loss</div>
                            <div style="font-size: 13px; font-weight: 600; color: var(--text-primary);">$${formatPrice(stopLoss)}</div>
                        </div>
                        <div style="background: rgba(251, 191, 36, 0.1); padding: 8px; border-radius: 6px; text-align: center; border: 1px solid var(--neon-amber);">
                            <div style="font-size: 9px; color: var(--neon-amber); text-transform: uppercase; margin-bottom: 2px;">Entry</div>
                            <div style="font-size: 13px; font-weight: 700; color: var(--neon-amber);">$${formatPrice(entryPrice)}</div>
                        </div>
                        <div style="background: rgba(0,0,0,0.2); padding: 8px; border-radius: 6px; text-align: center;">
                            <div style="font-size: 9px; color: var(--accent-positive); text-transform: uppercase; margin-bottom: 2px;">Take Profit</div>
                            <div style="font-size: 13px; font-weight: 600; color: var(--text-primary);">$${formatPrice(takeProfit)}</div>
                        </div>
                    </div>

                    <!-- Progress Bar (current price position) -->
                    <div style="margin-bottom: 12px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                            <span style="font-size: 10px; color: var(--text-secondary);">SL</span>
                            <span style="font-size: 11px; color: var(--text-primary);">Current: <span style="font-weight: 600; color: ${pnlColor};">$${formatPrice(currentPrice)}</span></span>
                            <span style="font-size: 10px; color: var(--text-secondary);">TP</span>
                        </div>
                        <div style="height: 6px; background: rgba(0,0,0,0.3); border-radius: 3px; overflow: hidden; position: relative;">
                            <div style="position: absolute; left: 0; top: 0; height: 100%; width: ${clampedProgress}%; background: linear-gradient(90deg, var(--accent-negative), var(--neon-amber), var(--accent-positive)); border-radius: 3px;"></div>
                            <div style="position: absolute; left: calc(${clampedProgress}% - 4px); top: -1px; width: 8px; height: 8px; background: white; border-radius: 50%; box-shadow: 0 0 4px rgba(0,0,0,0.5);"></div>
                        </div>
                    </div>

                    <!-- Stats Row -->
                    <div style="display: flex; justify-content: space-between; align-items: center; padding-top: 10px; border-top: 1px solid var(--border-light);">
                        <div style="display: flex; gap: 12px;">
                            <div>
                                <span style="font-size: 10px; color: var(--text-secondary);">P&L</span>
                                <div style="font-size: 14px; font-weight: 700; color: ${pnlColor};">${pnlPrefix}${pnlPct.toFixed(2)}%</div>
                            </div>
                            <div>
                                <span style="font-size: 10px; color: var(--text-secondary);">R:R</span>
                                <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">${rrRatio.toFixed(1)}:1</div>
                            </div>
                            <div>
                                <span style="font-size: 10px; color: var(--text-secondary);">Expires</span>
                                <div style="font-size: 14px; font-weight: 600; color: ${timeRemaining < 4 ? 'var(--accent-negative)' : 'var(--text-primary)'};">${timeRemaining.toFixed(0)}h</div>
                            </div>
                        </div>
                        <button class="action-btn btn-primary" style="flex: none; padding: 6px 28px; font-size: 11px;" onclick="window.open('https://www.bybit.com/trade/usdt/${fullSymbol}', '_blank')">
                            Trade
                        </button>
                    </div>
                </div>
            `;
        }

        // Legacy createSignalCard for backward compatibility
        function createSignalCard(signal) {
            return createTradeSignalCard(signal);
        }


        function createAlphaCard(opp) {
            const isBullish = opp.direction === 'bullish';
            const dirColor = isBullish ? 'var(--accent-positive)' : 'var(--accent-negative)';
            const dirBg = isBullish ? 'rgba(16, 185, 129, 0.15)' : 'rgba(239, 68, 68, 0.15)';
            const dirIcon = isBullish ? 'trending-up' : 'trending-down';
            const scoreColor = opp.score >= 65 ? 'var(--accent-positive)' : opp.score >= 50 ? 'var(--accent-warning)' : 'var(--accent-negative)';

            return `
                <div class="opportunity-item" style="background: var(--bg-secondary); border: 1px solid var(--border-light); border-radius: 12px; padding: 14px; margin-bottom: 10px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span style="font-weight: 700; font-size: 16px; color: var(--text-primary);">${opp.symbol}</span>
                            <i data-lucide="${dirIcon}" style="width: 16px; height: 16px; color: ${dirColor};"></i>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <div style="background: ${dirBg}; padding: 4px 10px; border-radius: 6px;">
                                <span style="font-size: 13px; font-weight: 600; color: ${dirColor};">${opp.momentum}</span>
                            </div>
                        </div>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-bottom: 10px;">
                        <div style="background: rgba(0,0,0,0.2); padding: 8px; border-radius: 6px; text-align: center;">
                            <div style="font-size: 9px; color: var(--text-secondary); text-transform: uppercase; margin-bottom: 2px;">Score</div>
                            <div style="font-size: 14px; font-weight: 700; color: ${scoreColor};">${opp.score}</div>
                        </div>
                        <div style="background: rgba(0,0,0,0.2); padding: 8px; border-radius: 6px; text-align: center;">
                            <div style="font-size: 9px; color: var(--text-secondary); text-transform: uppercase; margin-bottom: 2px;">Opp Score</div>
                            <div style="font-size: 14px; font-weight: 600; color: var(--neon-amber);">${opp.opportunity_score?.toFixed(1) || 'N/A'}</div>
                        </div>
                        <div style="background: rgba(0,0,0,0.2); padding: 8px; border-radius: 6px; text-align: center;">
                            <div style="font-size: 9px; color: var(--text-secondary); text-transform: uppercase; margin-bottom: 2px;">Volume</div>
                            <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">${opp.volume}</div>
                        </div>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span style="font-size: 11px; color: var(--text-secondary); text-transform: capitalize;">${opp.direction} setup</span>
                        <button class="action-btn btn-primary" style="padding: 6px 14px; font-size: 11px;" onclick="window.open('https://www.bybit.com/trade/usdt/${opp.full_symbol}', '_blank')">
                            Trade
                        </button>
                    </div>
                </div>
            `;
        }

        // Alert card redesign - handles both whale trades and liquidation cascades
        function createAlertCard(alert) {
            const symbol = alert.symbol || 'UNKNOWN';
            const message = alert.message || '';
            const details = alert.details || {};
            const level = alert.level || 'warning';
            const alertType = alert.alert_type || alert.details?.type || '';

            // Parse timestamp
            let alertDate;
            if (alert.unix_timestamp) {
                alertDate = new Date(alert.unix_timestamp * 1000);
            } else if (alert.timestamp) {
                alertDate = new Date(alert.timestamp.replace(' ', 'T') + 'Z');
            } else {
                alertDate = new Date();
            }
            const relativeTime = formatRelativeTime(alertDate);

            // Extract data based on alert type
            let totalValue = 0;
            let dominant = '';
            let alertLabel = '';
            let confidence = 0;  // For regime changes

            if (alertType === 'whale_trade') {
                // Whale trade: data is nested in details.data
                const data = details.data || {};
                totalValue = data.largest_trade_usd || 0;
                dominant = data.direction || data.largest_trade_side?.toUpperCase() || '';
                alertLabel = '🐋 Whale';
            } else if (alertType === 'liquidation_cascade') {
                // Liquidation cascade: data is directly in details
                totalValue = details.total_value || 0;
                dominant = details.dominant || details.largest_side || '';
                alertLabel = '💧 Liq';
            } else if (alertType === 'regime_change') {
                // Regime change: show transition info with confidence
                const newRegime = details.new_regime || '';
                const prevRegime = details.previous_regime || '';
                confidence = details.new_confidence || 0;
                alertLabel = '📊 Regime';
                // Determine direction based on new regime
                if (newRegime.includes('uptrend')) {
                    dominant = '↑ ' + newRegime.replace('_', ' ').replace('moderate ', '').toUpperCase();
                } else if (newRegime.includes('downtrend')) {
                    dominant = '↓ ' + newRegime.replace('_', ' ').replace('moderate ', '').toUpperCase();
                } else if (newRegime.includes('volatility')) {
                    dominant = '⚡ HIGH VOL';
                } else if (newRegime === 'ranging') {
                    dominant = '↔ RANGING';
                } else {
                    dominant = newRegime.replace('_', ' ').toUpperCase();
                }
            } else if (alertType === 'high_confluence' || alertType === 'signal') {
                // High confluence / Signal alerts: show signal type and confluence score
                const signalType = details.signal_type || details.type || '';
                confidence = (details.confluence_score || details.score || 0) / 100;  // Convert to 0-1 range
                alertLabel = '📈 Signal';
                // Determine direction based on signal type
                if (signalType.toUpperCase() === 'LONG' || signalType.toUpperCase() === 'BUY') {
                    dominant = '↑ LONG';
                } else if (signalType.toUpperCase() === 'SHORT' || signalType.toUpperCase() === 'SELL') {
                    dominant = '↓ SHORT';
                } else {
                    dominant = signalType.toUpperCase() || 'NEUTRAL';
                }
            } else {
                // Fallback for other alert types
                totalValue = details.total_value || details.data?.largest_trade_usd || 0;
                dominant = details.dominant || details.data?.direction || '';
            }

            const isGlobal = details.is_global || symbol === 'GLOBAL';

            // Severity → background tint (brand style guide colors)
            let bgTint = 'rgba(251, 191, 36, 0.04)';  // Default: subtle amber
            if (alertType === 'whale_trade') {
                bgTint = 'rgba(59, 130, 246, 0.08)';  // Blue wash for whales
            } else if (alertType === 'regime_change') {
                bgTint = 'rgba(139, 92, 246, 0.08)';  // Purple wash for regime changes
            } else if (alertType === 'high_confluence' || alertType === 'signal') {
                bgTint = 'rgba(16, 185, 129, 0.08)';  // Green wash for signals
            } else if (message.includes('🚨') || message.includes('CRITICAL') || level === 'critical') {
                bgTint = 'rgba(239, 68, 68, 0.12)';  // Red wash
            } else if (message.includes('⚠️') || message.includes('HIGH')) {
                bgTint = 'rgba(245, 158, 11, 0.10)';  // Orange wash
            } else if (message.includes('📊') || message.includes('MODERATE')) {
                bgTint = 'rgba(251, 191, 36, 0.06)';  // Amber wash
            }

            // Side color based on direction
            // For whale trades: SELL = bearish (red), BUY = bullish (green)
            // For liquidations: SHORT = bullish (green, shorts got liquidated), LONG = bearish (red)
            // For regime changes: uptrend = green, downtrend = red, volatility = orange, ranging = gray
            // For signals: LONG = bullish (green), SHORT = bearish (red)
            let sideColor = '#6b7280';  // Default gray
            if (alertType === 'whale_trade') {
                sideColor = dominant === 'BUY' ? '#10b981' : '#ef4444';
            } else if (alertType === 'regime_change') {
                if (dominant.includes('↑') || dominant.includes('UPTREND')) {
                    sideColor = '#10b981';  // Green for uptrend
                } else if (dominant.includes('↓') || dominant.includes('DOWNTREND')) {
                    sideColor = '#ef4444';  // Red for downtrend
                } else if (dominant.includes('⚡') || dominant.includes('VOL')) {
                    sideColor = '#f59e0b';  // Orange for high volatility
                } else {
                    sideColor = '#8b5cf6';  // Purple for ranging/other
                }
            } else if (alertType === 'high_confluence' || alertType === 'signal') {
                // Signals: LONG = green, SHORT = red
                if (dominant.includes('LONG') || dominant.includes('↑')) {
                    sideColor = '#10b981';  // Green for long
                } else if (dominant.includes('SHORT') || dominant.includes('↓')) {
                    sideColor = '#ef4444';  // Red for short
                } else {
                    sideColor = '#6b7280';  // Gray for neutral
                }
            } else {
                sideColor = dominant === 'SHORT' ? '#10b981' : '#ef4444';
            }

            // Format value compactly (or confidence/score for regime changes and signals)
            let valueStr = '';
            let isConfidence = false;  // Flag to style confidence differently
            if ((alertType === 'regime_change' || alertType === 'high_confluence' || alertType === 'signal') && confidence > 0) {
                // Show confidence as smaller labeled value for regime changes and signals
                valueStr = Math.round(confidence * 100) + '%';
                isConfidence = true;
            } else if (totalValue >= 1000000) {
                valueStr = '$' + (totalValue / 1000000).toFixed(1) + 'M';
            } else if (totalValue >= 1000) {
                valueStr = '$' + Math.round(totalValue / 1000) + 'K';
            } else if (totalValue > 0) {
                valueStr = '$' + Math.round(totalValue);
            }

            // Clean symbol
            const displaySymbol = isGlobal ? 'GLOBAL' : symbol.replace('USDT', '');

            // For signal alerts, add click handler to navigate to Signals tab
            const isSignalAlert = alertType === 'high_confluence' || alertType === 'signal';
            const clickHandler = isSignalAlert ? `onclick="navigateToAlertedSignals()"` : '';
            const cursorStyle = isSignalAlert ? 'cursor: pointer;' : '';

            return `
                <div class="signal-card" data-alert-type="${alertType}" ${clickHandler} style="
                    padding: 14px 16px;
                    background: ${bgTint};
                    border-radius: 8px;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    min-height: 52px;
                    font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
                    ${cursorStyle}
                ">
                    <div>
                        <div style="display: flex; align-items: baseline; gap: 6px;">
                            <span style="font-size: 15px; font-weight: 600; color: #fbbf24; font-family: 'IBM Plex Mono', monospace;">${displaySymbol}</span>
                            <span style="font-size: 11px; color: #6b7280;">${relativeTime}</span>
                        </div>
                        ${isGlobal ? `<div style="font-size: 10px; color: #f59e0b; margin-top: 2px;">Market-wide cascade</div>` : ''}
                        ${alertLabel ? `<div style="font-size: 10px; color: #9ca3af; margin-top: 2px;">${alertLabel}</div>` : ''}
                    </div>
                    <div style="display: flex; align-items: center; gap: 12px;">
                        ${dominant ? `<span style="font-size: 12px; font-weight: 600; color: ${sideColor}; font-family: 'IBM Plex Mono', monospace; letter-spacing: 0.5px; white-space: nowrap;">${dominant}</span>` : ''}
                        ${isConfidence
                            ? `<span style="font-size: 11px; color: #6b7280; font-family: 'IBM Plex Mono', monospace; white-space: nowrap; background: rgba(255,255,255,0.05); padding: 2px 6px; border-radius: 4px;"><span style="font-weight: 600; color: #d1d5db;">${valueStr}</span> Conf</span>`
                            : `<span style="font-size: 17px; font-weight: 700; color: #e0e0e0; font-family: 'IBM Plex Mono', monospace;">${valueStr}</span>`
                        }
                    </div>
                </div>
            `;
        }

        function createAnalyzedSymbolItem(symbol) {
            // Handle different data formats
            const symbolName = symbol.symbol || symbol;
            const price = symbol.price || symbol.current_price || 0;
            const confluenceScore = symbol.confluence_score || symbol.score || 50;
            const change = symbol.price_change_percent || symbol.change_24h || 0;
            const changeValue = typeof change === 'string' ? parseFloat(change) : change;
            const volume = symbol.volume || symbol.volume_24h || 0;
            const volume_usd = symbol.volume_usd || symbol.quote_volume || symbol.turnover_24h || (volume * price) || 0;
            const high_24h = symbol.high_24h || symbol.high || 0;
            const low_24h = symbol.low_24h || symbol.low || 0;
            
            // Extract component scores if available
            const components = symbol.components || symbol.results || {};
            const reliability = symbol.reliability || 0;
            const signalType = symbol.signal_type || symbol.type || 'NEUTRAL';
            const signalStrength = symbol.signal_strength || symbol.strength || 'weak';
            const timestamp = symbol.timestamp || Date.now();
            
            // Generate unique ID for expand/collapse
            const cardId = `card_${symbolName.replace(/[^a-zA-Z0-9]/g, '_')}`;
            
            // Determine score color and get trend icon
            let scoreColor = 'var(--text-secondary)';
            let scoreBg = 'rgba(255, 255, 255, 0.05)';
            let scoreLevel = 'WEAK';
            let trendIcon = 'minus';
            
            if (confluenceScore >= 70) {
                scoreColor = 'var(--accent-positive)';
                scoreBg = 'rgba(76, 175, 80, 0.1)';
                scoreLevel = 'STRONG';
                trendIcon = 'trending-up';
            } else if (confluenceScore >= 50) {
                scoreColor = 'var(--accent-warning)';
                scoreBg = 'rgba(255, 191, 0, 0.1)';
                scoreLevel = 'MODERATE';
                trendIcon = changeValue > 0 ? 'trending-up' : 'trending-down';
            } else {
                scoreColor = 'var(--accent-negative)';
                scoreBg = 'rgba(244, 67, 54, 0.1)';
                scoreLevel = 'WEAK';
                trendIcon = 'trending-down';
            }
            
            // Format symbol name (remove 1000 prefix and USDT suffix for display)
            let displaySymbol = symbolName;
            if (displaySymbol.startsWith('1000') && displaySymbol.length > 4) {
                displaySymbol = displaySymbol.substring(4);
            }
            displaySymbol = displaySymbol.replace('USDT', '').replace('USD', '');
            const changePrefix = changeValue > 0 ? '+' : '';
            const changeColor = changeValue >= 0 ? 'var(--accent-positive)' : 'var(--accent-negative)';
            
            // Format turnover/USD volume
            let turnoverDisplay = '';
            if (volume_usd > 0) {
                turnoverDisplay = volume_usd > 1e9 ? '$' + (volume_usd/1e9).toFixed(2) + 'B' : 
                                 volume_usd > 1e6 ? '$' + (volume_usd/1e6).toFixed(1) + 'M' : 
                                 volume_usd > 1e3 ? '$' + (volume_usd/1e3).toFixed(1) + 'K' : 
                                 '$' + volume_usd.toFixed(0);
            }
            
            // Calculate price range percentage
            const priceRange = high_24h > 0 && low_24h > 0 ? ((high_24h - low_24h) / low_24h * 100).toFixed(2) : 0;
            
            // Component scores for mini visualization
            const componentScores = {
                technical: components.technical || 50,
                volume: components.volume || 50,
                orderflow: components.orderflow || 50,
                sentiment: components.sentiment || 50,
                orderbook: components.orderbook || 50,
                price_structure: components.price_structure || 50
            };
            
            return `
                <div class="symbol-card" id="${cardId}" style="background: var(--bg-secondary); border: 1px solid var(--border-light); border-radius: 14px; cursor: pointer; transition: all 0.2s ease; position: relative; overflow: hidden; margin-bottom: 12px;">
                    <!-- Score indicator bar -->
                    <div style="position: absolute; top: 0; left: 0; right: 0; height: 4px; background: ${scoreColor}; opacity: 0.9;"></div>

                    <!-- Main card content (always visible) -->
                    <div style="padding: 18px 16px;" onclick="toggleCardExpansion('${cardId}')">
                        <!-- Header with symbol and score -->
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 14px;">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <span style="font-weight: 700; font-size: 18px; color: var(--text-primary);">${displaySymbol}</span>
                                <i data-lucide="${trendIcon}" style="width: 16px; height: 16px; color: ${scoreColor};"></i>
                            </div>
                            <div style="background: ${scoreBg}; padding: 6px 10px; border-radius: 8px;">
                                <span style="font-size: 15px; font-weight: 700; color: ${scoreColor};">${Math.round(confluenceScore)}</span>
                            </div>
                        </div>

                        <!-- Price and change row -->
                        <div style="display: flex; justify-content: space-between; align-items: baseline; margin-bottom: 14px;">
                            <div style="font-size: 16px; font-weight: 600; color: var(--text-primary);">
                                $${price > 100 ? price.toFixed(2) : price < 1 ? price.toFixed(4) : price.toFixed(3)}
                            </div>
                            <div style="font-size: 14px; font-weight: 600; color: ${changeColor};">
                                ${changePrefix}${Math.abs(changeValue).toFixed(2)}%
                            </div>
                        </div>
                        
                        <!-- Turnover and range row -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 14px;">
                            <div style="padding: 10px 8px; background: rgba(0, 0, 0, 0.25); border-radius: 8px;">
                                <div style="font-size: 10px; color: var(--text-secondary); text-transform: uppercase; margin-bottom: 2px;">Turnover</div>
                                <div style="font-size: 13px; font-weight: 600; color: var(--text-primary);">${turnoverDisplay || 'N/A'}</div>
                            </div>
                            <div style="padding: 10px 8px; background: rgba(0, 0, 0, 0.25); border-radius: 8px;">
                                <div style="font-size: 10px; color: var(--text-secondary); text-transform: uppercase; margin-bottom: 2px;">24H Range</div>
                                <div style="font-size: 13px; font-weight: 600; color: var(--text-primary);">${priceRange}%</div>
                            </div>
                        </div>

                        <!-- Component breakdown mini bars -->
                        <div style="display: flex; gap: 3px; margin-bottom: 10px;">
                            ${Object.entries(componentScores).map(([comp, score]) => {
                                const height = Math.max(12, (score / 100) * 36);
                                const barColor = score >= 70 ? 'var(--accent-positive)' : score >= 30 ? 'var(--accent-warning)' : 'var(--accent-negative)';
                                return `<div style="flex: 1; background: rgba(255, 255, 255, 0.05); border-radius: 3px; height: 36px; position: relative; overflow: hidden;">
                                    <div style="position: absolute; bottom: 0; width: 100%; height: ${height}px; background: ${barColor}; opacity: 0.8;"></div>
                                </div>`;
                            }).join('')}
                        </div>

                        <!-- Expand indicator -->
                        <div style="display: flex; justify-content: center; margin-top: 10px;">
                            <i data-lucide="chevron-down" style="width: 16px; height: 16px; color: var(--text-secondary); transition: transform 0.3s;" id="${cardId}_chevron"></i>
                        </div>
                    </div>
                    
                    <!-- Expanded content (hidden by default) -->
                    <div id="${cardId}_expanded" style="display: none; padding: 0 16px 16px 16px; border-top: 1px solid var(--border-light);">
                        <!-- Component scores breakdown -->
                        <div style="margin-bottom: 12px;">
                            <h4 style="font-size: 12px; font-weight: 600; color: var(--text-primary); margin-bottom: 8px; text-transform: uppercase;">Component Breakdown</h4>
                            ${Object.entries(componentScores).map(([comp, score]) => {
                                const compColor = score >= 70 ? 'var(--accent-positive)' : score >= 30 ? 'var(--accent-warning)' : 'var(--accent-negative)';
                                const compName = comp.replace('_', ' ').charAt(0).toUpperCase() + comp.replace('_', ' ').slice(1);
                                return `
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                                    <span style="font-size: 11px; color: var(--text-secondary);">${compName}</span>
                                    <div style="display: flex; align-items: center; gap: 6px;">
                                        <div style="width: 60px; height: 4px; background: rgba(255, 255, 255, 0.1); border-radius: 2px; overflow: hidden;">
                                            <div style="width: ${score}%; height: 100%; background: ${compColor};"></div>
                                        </div>
                                        <span style="font-size: 11px; font-weight: 600; color: ${compColor}; min-width: 25px; text-align: right;">${Math.round(score)}</span>
                                    </div>
                                </div>`;
                            }).join('')}
                        </div>
                        
                        <!-- Signal details -->
                        <div style="margin-bottom: 12px;">
                            <h4 style="font-size: 12px; font-weight: 600; color: var(--text-primary); margin-bottom: 8px; text-transform: uppercase;">Signal Details</h4>
                            <div style="padding: 8px; background: rgba(0, 0, 0, 0.2); border-radius: 6px; text-align: center;">
                                <div style="font-size: 9px; color: var(--text-secondary); margin-bottom: 4px;">Current Signal</div>
                                <div style="font-size: 14px; font-weight: 700; color: ${signalType === 'LONG' ? 'var(--accent-positive)' : signalType === 'SHORT' ? 'var(--accent-negative)' : 'var(--text-secondary)'};">${signalType}</div>
                            </div>
                        </div>
                        
                        <!-- Reliability and timestamp -->
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <span style="font-size: 9px; color: var(--text-secondary);">Reliability: </span>
                                <span style="font-size: 11px; font-weight: 600; color: ${reliability >= 80 ? 'var(--accent-positive)' : reliability >= 60 ? 'var(--accent-warning)' : 'var(--accent-negative)'};">${reliability.toFixed(1)}%</span>
                            </div>
                            <div style="font-size: 9px; color: var(--text-secondary);">
                                ${formatTimestamp(timestamp)}
                            </div>
                        </div>

                        <!-- Action buttons -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 14px;">
                            <button onclick="viewDetailedAnalysis('${symbolName}')" style="padding: 12px 10px; background: var(--accent-primary); border: none; border-radius: 8px; color: var(--bg-primary); font-size: 13px; font-weight: 700; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 6px;">
                                <i data-lucide="chart-line" style="width: 14px; height: 14px;"></i>
                                Analyze
                            </button>
                            <button onclick="viewAlerts('${symbolName}')" style="padding: 12px 10px; background: rgba(255, 191, 0, 0.15); border: 1px solid rgba(251, 191, 36, 0.3); border-radius: 8px; color: var(--text-primary); font-size: 13px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 6px;">
                                <i data-lucide="bell" style="width: 14px; height: 14px;"></i>
                                Alerts
                            </button>
                        </div>
                    </div>
                </div>
            `;
        }
        
        function createSymbolItem(symbol) {
            // Handle different data formats
            const symbolName = symbol.symbol || symbol;
            const price = symbol.price || symbol.current_price || 0;
            const confluenceScore = symbol.confluence_score || symbol.score || 50;
            const change = symbol.price_change_percent || symbol.change_24h || 0;
            const changeValue = typeof change === 'string' ? parseFloat(change) : change;
            const changeClass = changeValue > 0 ? 'change-positive' : changeValue < 0 ? 'change-negative' : 'change-neutral';
            const changePrefix = changeValue > 0 ? '+' : '';
            
            // Determine score color
            let scoreColor = 'var(--text-secondary)';
            if (confluenceScore >= 70) {
                scoreColor = 'var(--accent-positive)';
            } else if (confluenceScore >= 30 && confluenceScore < 70) {
                scoreColor = 'var(--accent-warning)';
            } else {
                scoreColor = 'var(--accent-negative)';
            }
            
            // Format price based on value
            const formattedPrice = price > 100 ? price.toFixed(2) : price > 1 ? price.toFixed(4) : price.toFixed(6);
            
            return `
                <div class="symbol-item" onclick="viewSymbol('${symbolName}')">
                    <div class="symbol-info">
                        <div>
                            <div class="symbol-name">${symbolName.replace('USDT', '')}</div>
                            <div class="symbol-price">$${formattedPrice}</div>
                        </div>
                    </div>
                    <div class="symbol-metrics">
                        <div class="confluence-score">
                            <div class="score-value" style="color: ${scoreColor}">${confluenceScore}</div>
                            <div class="score-label">Score</div>
                        </div>
                        <div class="symbol-change ${changeClass}">
                            ${changePrefix}${changeValue.toFixed(2)}%
                        </div>
                    </div>
                </div>
            `;
        }

        function createEmptyState(message) {
            return `
                <div class="empty-state">
                    <i data-lucide="inbox" class="empty-icon"></i>
                    <div class="empty-title">No Data</div>
                    <div class="empty-text">${message}</div>
                </div>
            `;
        }

        // Helper functions
        function getScoreClass(score) {
            if (score >= 80) return 'score-high';
            if (score >= 60) return 'score-medium';
            return 'score-low';
        }

        function getScoreColor(score) {
            if (score >= 80) return 'var(--accent-positive)';
            if (score >= 60) return 'var(--accent-warning)';
            return 'var(--accent-negative)';
        }

        // Debounce function for performance
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        const debouncedRefresh = debounce(() => {
            const activeTab = document.querySelector('.nav-item.active');
            // Extract tab name from onclick attribute (more reliable than label text)
            const onclick = activeTab.getAttribute('onclick') || '';
            const match = onclick.match(/switchTab\(['"](\w+)['"]\)/);
            const tabName = match ? match[1] : 'dashboard';

            // Load the current tab's data
            loadTabData(tabName);

            // Also refresh the price ticker (fetch fresh data)
            refreshPriceTicker();

            // Show refresh feedback
            pullToRefresh.innerHTML = '<i data-lucide="check" style="width: 16px; height: 16px; margin-right: 8px;"></i><span>Updated</span>';
            setTimeout(() => {
                pullToRefresh.innerHTML = '<i data-lucide="refresh-cw" style="width: 16px; height: 16px; margin-right: 8px;"></i><span>Pull to refresh</span>';
                if (typeof lucide !== 'undefined') lucide.createIcons();
            }, 1000);
        }, 300);

        // Refresh price ticker independently
        async function refreshPriceTicker() {
            try {
                const response = await fetch('/api/dashboard/mobile-data');
                const data = await response.json();
                if (data.status === 'success' && data.confluence_scores) {
                    updatePriceTicker(data.confluence_scores);
                }
            } catch (e) {
                console.warn('Failed to refresh ticker:', e);
            }
        }

        function refreshData() {
            debouncedRefresh();
        }

        function toggleSettings() {
            // Implement settings panel
            alert('Settings panel coming soon!');
        }

        function viewOpportunity(symbol) {
            // Implement opportunity detail view
            console.log('View opportunity:', symbol);
        }


        function viewAlpha(id) {
            // Implement alpha detail view
            console.log('View alpha:', id);
        }

        function viewSymbol(symbol) {
            // Navigate to signals tab with symbol filter
            switchTab('signals');
            // TODO: Filter signals by symbol
            console.log('View symbol:', symbol);
        }

        // Card expansion/collapse functionality
        function toggleCardExpansion(cardId) {
            const expandedContent = document.getElementById(`${cardId}_expanded`);
            const chevron = document.getElementById(`${cardId}_chevron`);
            
            if (expandedContent.style.display === 'none') {
                // Expand
                expandedContent.style.display = 'block';
                chevron.style.transform = 'rotate(180deg)';
                
                // Smooth animation
                expandedContent.style.opacity = '0';
                expandedContent.style.maxHeight = '0';
                setTimeout(() => {
                    expandedContent.style.transition = 'all 0.3s ease';
                    expandedContent.style.opacity = '1';
                    expandedContent.style.maxHeight = '500px';
                }, 10);
            } else {
                // Collapse
                expandedContent.style.opacity = '0';
                expandedContent.style.maxHeight = '0';
                chevron.style.transform = 'rotate(0deg)';
                
                setTimeout(() => {
                    expandedContent.style.display = 'none';
                    expandedContent.style.transition = '';
                }, 300);
            }
            
            // Prevent event bubbling
            event.stopPropagation();
        }

        // Haptic feedback helper
        function triggerHapticFeedback(type = 'light') {
            if ('vibrate' in navigator) {
                const duration = type === 'light' ? 10 : type === 'medium' ? 20 : 30;
                navigator.vibrate(duration);
            }
        }

        // Track currently expanded card (accordion behavior)
        let currentlyExpandedAlphaCard = null;

        // Alpha Pulse card expansion/collapse - HORIZONTAL with UX improvements
        function toggleAlphaPulseCard(cardId) {
            const card = document.getElementById(cardId);
            const buttonsPanel = document.getElementById(`${cardId}_buttons`);
            const breakdownPanel = document.getElementById(`${cardId}_expanded`);
            const chevron = document.getElementById(`${cardId}_chevron`);

            if (!breakdownPanel || !card) return;

            const isExpanded = breakdownPanel.style.maxHeight && breakdownPanel.style.maxHeight !== '0px';

            // Accordion: collapse previously expanded card if different
            if (!isExpanded && currentlyExpandedAlphaCard && currentlyExpandedAlphaCard !== cardId) {
                const prevCard = document.getElementById(currentlyExpandedAlphaCard);
                const prevButtons = document.getElementById(`${currentlyExpandedAlphaCard}_buttons`);
                const prevBreakdown = document.getElementById(`${currentlyExpandedAlphaCard}_expanded`);
                const prevChevron = document.getElementById(`${currentlyExpandedAlphaCard}_chevron`);

                if (prevBreakdown && prevCard) {
                    // Collapse buttons panel
                    if (prevButtons) {
                        prevButtons.style.width = '0px';
                        prevButtons.style.opacity = '0';
                    }
                    // Collapse breakdown panel
                    prevBreakdown.style.maxHeight = '0px';
                    prevBreakdown.style.opacity = '0';
                    if (prevChevron) prevChevron.style.transform = 'rotate(0deg)';
                    setTimeout(() => {
                        if (prevButtons) prevButtons.style.display = 'none';
                        prevBreakdown.style.display = 'none';
                        prevCard.style.gridColumn = '';
                    }, 300);
                }
            }

            if (!isExpanded) {
                // Haptic feedback on expand
                triggerHapticFeedback('light');

                // Expand card to full width
                card.style.gridColumn = '1 / -1';

                // Show buttons panel (horizontal)
                if (buttonsPanel) {
                    buttonsPanel.style.display = 'block';
                    setTimeout(() => {
                        buttonsPanel.style.width = '80px';
                        buttonsPanel.style.opacity = '1';
                    }, 10);
                }

                // Show breakdown panel (vertical, below card)
                breakdownPanel.style.display = 'block';
                if (chevron) chevron.style.transform = 'rotate(180deg)';

                setTimeout(() => {
                    breakdownPanel.style.maxHeight = '200px';
                    breakdownPanel.style.opacity = '1';

                    // Auto-scroll card into view
                    setTimeout(() => {
                        card.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'nearest' });
                    }, 150);
                }, 10);

                currentlyExpandedAlphaCard = cardId;

                // Re-initialize lucide icons
                if (typeof lucide !== 'undefined') {
                    lucide.createIcons();
                }
            } else {
                // Collapse buttons panel
                if (buttonsPanel) {
                    buttonsPanel.style.width = '0px';
                    buttonsPanel.style.opacity = '0';
                }

                // Collapse breakdown panel
                breakdownPanel.style.maxHeight = '0px';
                breakdownPanel.style.opacity = '0';
                if (chevron) chevron.style.transform = 'rotate(0deg)';

                setTimeout(() => {
                    if (buttonsPanel) buttonsPanel.style.display = 'none';
                    breakdownPanel.style.display = 'none';
                    card.style.gridColumn = '';
                }, 300);

                currentlyExpandedAlphaCard = null;
            }
        }

        function viewDetailedAnalysis(symbol) {
            // Navigate to detailed analysis page
            console.log('View detailed analysis for:', symbol);
            window.location.href = `/api/dashboard/confluence-analysis-page?symbol=${symbol}`;
            event.stopPropagation();
        }

        function viewAlerts(symbol) {
            // Navigate to alerts for this symbol
            console.log('View alerts for:', symbol);
            // Switch to alerts tab and filter by symbol
            switchTab('alerts');
            // TODO: Implement symbol filtering in alerts
            event.stopPropagation();
        }

        // View HTML/PDF report for a signal alert
        async function viewAlertReport(symbol, timestamp) {
            console.log('View report for:', symbol, 'at timestamp:', timestamp);
            event.stopPropagation();

            try {
                // Show loading indicator
                const loadingToast = showToast('Loading reports...', 'info');

                // Fetch available reports for this symbol
                const response = await fetch(`/api/dashboard/signal-reports/${symbol}`);
                const data = await response.json();

                // Hide loading toast
                if (loadingToast) loadingToast.remove();

                // Check if we have HTML reports (PDF serving disabled)
                const hasHtml = data.html_reports && data.html_reports.length > 0;

                if (!hasHtml) {
                    // No HTML reports found - fall back to analysis page
                    showToast('No archived reports found. Opening live analysis...', 'warning');
                    setTimeout(() => {
                        window.location.href = `/api/dashboard/confluence-analysis-page?symbol=${symbol}`;
                    }, 1000);
                    return;
                }

                // Show report selector modal (HTML only)
                showReportSelectorModal(symbol, data);

            } catch (error) {
                console.error('Error fetching reports:', error);
                showToast('Error loading reports. Opening analysis page...', 'error');
                window.location.href = `/api/dashboard/confluence-analysis-page?symbol=${symbol}`;
            }
        }

        // Show a modal to select between available reports
        function showReportSelectorModal(symbol, reportsData) {
            // Remove existing modal if any
            const existingModal = document.getElementById('reportSelectorModal');
            if (existingModal) existingModal.remove();

            const displaySymbol = symbol.replace(/USDT$/i, '');
            const hasHtml = reportsData.html_reports && reportsData.html_reports.length > 0;
            const htmlCount = reportsData.html_reports?.length || 0;

            // Build report list HTML (HTML reports only)
            let reportsListHtml = '';

            // Signal Report - full branded report with charts and trade levels
            if (hasHtml) {
                // Find the latest signal report (not a SNAPSHOT file)
                const signalReports = reportsData.html_reports.filter(r => !r.filename.includes('_SNAPSHOT_'));
                if (signalReports.length > 0) {
                    const latestSignal = signalReports[0];
                    const signalDate = new Date(latestSignal.created);
                    reportsListHtml += `
                        <a href="${latestSignal.url}" target="_blank" class="report-item" style="display: flex; align-items: center; gap: 12px; padding: 14px; background: rgba(251, 191, 36, 0.1); border: 1px solid rgba(251, 191, 36, 0.3); border-radius: 10px; text-decoration: none; margin-bottom: 10px;">
                            <div style="width: 40px; height: 40px; background: rgba(251, 191, 36, 0.2); border-radius: 8px; display: flex; align-items: center; justify-content: center;">
                                <i data-lucide="file-text" style="width: 20px; height: 20px; color: #fbbf24;"></i>
                            </div>
                            <div style="flex: 1;">
                                <div style="font-weight: 600; color: var(--text-primary); font-size: 13px;">Signal Report</div>
                                <div style="font-size: 11px; color: var(--text-secondary);">${formatRelativeTime(signalDate)} • ${latestSignal.size_kb} KB</div>
                            </div>
                            <i data-lucide="external-link" style="width: 16px; height: 16px; color: var(--text-secondary);"></i>
                        </a>
                    `;
                }
            }

            // Live analysis row with Alpha Snapshot button
            // Alpha Snapshot = archived terminal-style analysis from alert time
            const snapshotReports = reportsData.html_reports?.filter(r => r.filename.includes('_SNAPSHOT_')) || [];
            const alphaSnapshotUrl = snapshotReports.length > 0 ? snapshotReports[0].url : null;
            reportsListHtml += `
                <div style="display: flex; gap: 10px; align-items: stretch;">
                    <a href="/api/dashboard/confluence-analysis-page?symbol=${symbol}" class="report-item" style="flex: 1; display: flex; align-items: center; gap: 12px; padding: 14px; background: rgba(16, 185, 129, 0.1); border: 1px solid rgba(16, 185, 129, 0.3); border-radius: 10px; text-decoration: none;">
                        <div style="width: 40px; height: 40px; background: rgba(16, 185, 129, 0.2); border-radius: 8px; display: flex; align-items: center; justify-content: center;">
                            <i data-lucide="activity" style="width: 20px; height: 20px; color: #10b981;"></i>
                        </div>
                        <div style="flex: 1;">
                            <div style="font-weight: 600; color: var(--text-primary); font-size: 13px;">Live Analysis</div>
                            <div style="font-size: 11px; color: var(--text-secondary);">Current market data</div>
                        </div>
                        <i data-lucide="chevron-right" style="width: 16px; height: 16px; color: var(--text-secondary);"></i>
                    </a>
                    ${alphaSnapshotUrl ? `
                    <a href="${alphaSnapshotUrl}" target="_blank" class="snapshot-btn" style="width: 60px; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 3px; padding: 8px 6px; background: rgba(168, 85, 247, 0.1); border: 1px solid rgba(168, 85, 247, 0.3); border-radius: 10px; text-decoration: none;">
                        <i data-lucide="camera" style="width: 18px; height: 18px; color: #a855f7;"></i>
                        <span style="font-size: 8px; color: #a855f7; font-weight: 600; text-align: center; line-height: 1.1;">ALPHA<br>SNAP</span>
                    </a>
                    ` : `
                    <div style="width: 60px; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 3px; padding: 8px 6px; background: rgba(100, 100, 100, 0.1); border: 1px solid rgba(100, 100, 100, 0.3); border-radius: 10px; opacity: 0.5;">
                        <i data-lucide="camera-off" style="width: 18px; height: 18px; color: #666;"></i>
                        <span style="font-size: 8px; color: #666; font-weight: 600; text-align: center; line-height: 1.1;">NO<br>SNAP</span>
                    </div>
                    `}
                </div>
            `;

            // Create modal
            const modal = document.createElement('div');
            modal.id = 'reportSelectorModal';
            modal.innerHTML = `
                <div style="position: fixed; inset: 0; background: rgba(0,0,0,0.7); backdrop-filter: blur(4px); z-index: 9999; display: flex; align-items: flex-end; justify-content: center;" onclick="closeReportModal(event)">
                    <div style="background: var(--bg-primary); border-radius: 20px 20px 0 0; width: 100%; max-width: 500px; max-height: 80vh; overflow: hidden; animation: slideUp 0.3s ease;" onclick="event.stopPropagation()">
                        <!-- Header -->
                        <div style="padding: 16px 20px; border-bottom: 1px solid var(--border-light); display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <h3 style="margin: 0; font-size: 16px; font-weight: 700; color: var(--text-primary);">${displaySymbol} Reports</h3>
                                <div style="font-size: 11px; color: var(--text-secondary); margin-top: 2px;">${htmlCount} archived report${htmlCount !== 1 ? 's' : ''}</div>
                            </div>
                            <button onclick="closeReportModal(event)" style="width: 32px; height: 32px; border-radius: 50%; border: none; background: var(--bg-secondary); cursor: pointer; display: flex; align-items: center; justify-content: center;">
                                <i data-lucide="x" style="width: 18px; height: 18px; color: var(--text-secondary);"></i>
                            </button>
                        </div>
                        <!-- Performance Section -->
                        <div id="performanceSection" style="padding: 12px 20px; border-bottom: 1px solid var(--border-light);">
                            <div style="text-align: center; color: var(--text-secondary); font-size: 12px;">
                                <i data-lucide="loader-2" class="spin" style="width: 16px; height: 16px; animation: spin 1s linear infinite;"></i>
                                Loading performance...
                            </div>
                        </div>
                        <!-- Reports List -->
                        <div style="padding: 16px 20px; overflow-y: auto; max-height: 50vh;">
                            ${reportsListHtml}
                        </div>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);

            // Initialize Lucide icons in modal
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }

            // Add slide-up animation and spin
            const style = document.createElement('style');
            style.textContent = `
                @keyframes slideUp {
                    from { transform: translateY(100%); opacity: 0; }
                    to { transform: translateY(0); opacity: 1; }
                }
                @keyframes spin {
                    from { transform: rotate(0deg); }
                    to { transform: rotate(360deg); }
                }
            `;
            modal.appendChild(style);

            // Fetch and display performance data
            loadSignalPerformance(symbol);
        }

        // Load signal performance data
        async function loadSignalPerformance(symbol) {
            const container = document.getElementById('performanceSection');
            if (!container) return;

            try {
                const response = await fetch(`/api/dashboard/signal-performance/${symbol}`);
                if (!response.ok) {
                    container.innerHTML = `<div style="text-align: center; color: var(--text-secondary); font-size: 11px;">No signal data available</div>`;
                    return;
                }

                const perf = await response.json();

                // Determine colors
                const pnlColor = perf.pnl_percent >= 0 ? '#10b981' : '#ef4444';
                const statusColors = { green: '#10b981', red: '#ef4444', amber: '#fbbf24' };
                const statusColor = statusColors[perf.status_color] || '#9ca3af';

                // Status display text
                const statusText = {
                    'STOPPED_OUT': '⛔ Stopped Out',
                    'ALL_TARGETS_HIT': '🎯 All Targets Hit!',
                    'TARGET_1_HIT': '✅ Target 1 Hit',
                    'TARGET_2_HIT': '✅ Target 2 Hit',
                    'TARGET_3_HIT': '✅ Target 3 Hit',
                    'IN_PROFIT': '📈 In Profit',
                    'IN_DRAWDOWN': '📉 In Drawdown'
                }[perf.status] || perf.status;

                container.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; gap: 12px;">
                        <!-- P&L Display -->
                        <div style="flex: 1;">
                            <div style="font-size: 10px; color: var(--text-secondary); text-transform: uppercase; margin-bottom: 2px;">Performance</div>
                            <div style="font-size: 22px; font-weight: 700; color: ${pnlColor};">
                                ${perf.pnl_percent >= 0 ? '+' : ''}${perf.pnl_percent}%
                            </div>
                            <div style="font-size: 10px; color: var(--text-secondary);">
                                ${perf.signal_type} @ $${perf.entry_price.toFixed(4)} → $${perf.current_price.toFixed(4)}
                            </div>
                        </div>
                        <!-- Status & Targets -->
                        <div style="text-align: right;">
                            <div style="font-size: 12px; font-weight: 600; color: ${statusColor}; margin-bottom: 4px;">
                                ${statusText}
                            </div>
                            <div style="font-size: 10px; color: var(--text-secondary);">
                                Targets: ${perf.targets_hit}/${perf.targets_total}
                            </div>
                            <div style="font-size: 9px; color: var(--text-secondary);">
                                ${perf.signal_age_hours}h ago
                            </div>
                        </div>
                    </div>
                `;
            } catch (error) {
                console.error('Error loading performance:', error);
                container.innerHTML = `<div style="text-align: center; color: var(--text-secondary); font-size: 11px;">Performance unavailable</div>`;
            }
        }

        // Close report modal
        function closeReportModal(event) {
            event.stopPropagation();
            const modal = document.getElementById('reportSelectorModal');
            if (modal) modal.remove();
        }

        // Show toast notification
        function showToast(message, type = 'info') {
            const existingToast = document.querySelector('.toast-notification');
            if (existingToast) existingToast.remove();

            const colors = {
                info: 'rgba(59, 130, 246, 0.9)',
                success: 'rgba(16, 185, 129, 0.9)',
                warning: 'rgba(251, 191, 36, 0.9)',
                error: 'rgba(239, 68, 68, 0.9)'
            };

            const toast = document.createElement('div');
            toast.className = 'toast-notification';
            toast.style.cssText = `
                position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
                background: ${colors[type]}; color: white; padding: 12px 20px;
                border-radius: 8px; font-size: 13px; font-weight: 500;
                z-index: 10000; animation: fadeIn 0.3s ease;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            `;
            toast.textContent = message;
            document.body.appendChild(toast);

            // Auto-remove after 3 seconds
            setTimeout(() => toast.remove(), 3000);
        }

        // Toggle expansion for alerted signal cards (similar to Alpha Pulse)
        function toggleAlertedSignalCard(cardId) {
            const card = document.getElementById(cardId);
            const buttonsPanel = document.getElementById(`${cardId}_buttons`);
            const chevron = document.getElementById(`${cardId}_chevron`);

            if (!buttonsPanel || !card) return;

            const isExpanded = buttonsPanel.style.width && buttonsPanel.style.width !== '0px';

            // Accordion: collapse previously expanded card if different
            if (!isExpanded && currentlyExpandedAlertedSignal && currentlyExpandedAlertedSignal !== cardId) {
                const prevCard = document.getElementById(currentlyExpandedAlertedSignal);
                const prevButtons = document.getElementById(`${currentlyExpandedAlertedSignal}_buttons`);
                const prevChevron = document.getElementById(`${currentlyExpandedAlertedSignal}_chevron`);

                if (prevButtons && prevCard) {
                    // Collapse buttons panel
                    prevButtons.style.width = '0px';
                    prevButtons.style.opacity = '0';
                    if (prevChevron) prevChevron.style.transform = 'rotate(0deg)';
                    setTimeout(() => {
                        prevButtons.style.display = 'none';
                    }, 300);
                }
            }

            if (!isExpanded) {
                // Haptic feedback on expand
                triggerHapticFeedback('light');

                // Show buttons panel (horizontal slide)
                buttonsPanel.style.display = 'block';
                if (chevron) chevron.style.transform = 'rotate(-90deg)';

                setTimeout(() => {
                    buttonsPanel.style.width = '90px';
                    buttonsPanel.style.opacity = '1';

                    // Auto-scroll card into view
                    setTimeout(() => {
                        card.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'nearest' });
                    }, 150);
                }, 10);

                currentlyExpandedAlertedSignal = cardId;

                // Re-initialize lucide icons for the expanded panel
                if (typeof lucide !== 'undefined') {
                    lucide.createIcons();
                }
            } else {
                // Collapse buttons panel
                buttonsPanel.style.width = '0px';
                buttonsPanel.style.opacity = '0';
                if (chevron) chevron.style.transform = 'rotate(0deg)';

                setTimeout(() => {
                    buttonsPanel.style.display = 'none';
                }, 300);

                currentlyExpandedAlertedSignal = null;
            }
        }
        
        // WebSocket connection for real-time updates
        let ws;
        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(`${protocol}//${window.location.host}/ws`);
            
            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                handleRealtimeUpdate(data);
            };
            
            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };
            
            ws.onclose = () => {
                // Reconnect after 5 seconds
                setTimeout(connectWebSocket, 5000);
            };
        }

        function handleRealtimeUpdate(data) {
            // Handle real-time updates based on data type
            if (data.type === 'signal') {
                // Update signals if on signals tab
                if (document.getElementById('signalsTab').classList.contains('active')) {
                    loadSignalsData();
                }
            } else if (data.type === 'price_update' || data.type === 'ticker') {
                // Update symbols if on dashboard tab
                if (document.getElementById('dashboardTab').classList.contains('active')) {
                    fetch('/api/dashboard/symbols')
                        .then(response => response.json())
                        .then(data => updateSymbols(data))
                        .catch(error => console.error('Error updating symbols:', error));
                }
            }
        }

        // Intersection Observer for performance
        const observerOptions = {
            root: null,
            rootMargin: '50px',
            threshold: 0.1
        };

        const intersectionObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    // Load content when it comes into view
                    const element = entry.target;
                    if (element.dataset.lazy === 'true') {
                        // Trigger lazy loading here
                        element.dataset.lazy = 'false';
                    }
                }
            });
        }, observerOptions);

        // ============================================
        // iOS-STYLE HAPTIC FEEDBACK & SWIPE GESTURES
        // ============================================

        // Haptic feedback utility (uses Vibration API)
        // Track user interaction to comply with browser vibration policy
        let userHasInteracted = false;
        document.addEventListener('touchstart', () => { userHasInteracted = true; }, { once: true, passive: true });
        document.addEventListener('click', () => { userHasInteracted = true; }, { once: true });

        const haptic = {
            light: () => {
                if (userHasInteracted && 'vibrate' in navigator) {
                    navigator.vibrate(10);
                }
            },
            medium: () => {
                if (userHasInteracted && 'vibrate' in navigator) {
                    navigator.vibrate(20);
                }
            },
            heavy: () => {
                if (userHasInteracted && 'vibrate' in navigator) {
                    navigator.vibrate([30, 10, 30]);
                }
            },
            success: () => {
                if (userHasInteracted && 'vibrate' in navigator) {
                    navigator.vibrate([10, 50, 20]);
                }
            },
            error: () => {
                if (userHasInteracted && 'vibrate' in navigator) {
                    navigator.vibrate([50, 30, 50, 30, 50]);
                }
            }
        };

        // Add haptic feedback to all interactive elements
        function initHapticFeedback() {
            // Buttons and nav items
            document.querySelectorAll('button, .nav-item, .tab-btn, .tf-btn, .pressable').forEach(el => {
                el.addEventListener('touchstart', () => haptic.light(), { passive: true });
            });

            // Cards - lighter feedback
            document.querySelectorAll('.mobile-card').forEach(el => {
                el.addEventListener('touchstart', () => {
                    if (userHasInteracted && 'vibrate' in navigator) navigator.vibrate(5);
                }, { passive: true });
            });
        }

        // Initialize confluence scroll hint - hides when scrolled to bottom
        function initConfluenceScrollHint() {
            const scrollContainer = document.getElementById('confluenceScrollContainer');
            const scrollHint = document.getElementById('confluenceScrollHint');

            if (!scrollContainer || !scrollHint) return;

            // Check if content is scrollable and update hint visibility
            function updateScrollHint() {
                const isScrollable = scrollContainer.scrollHeight > scrollContainer.clientHeight;
                const isAtBottom = scrollContainer.scrollTop + scrollContainer.clientHeight >= scrollContainer.scrollHeight - 20;

                if (!isScrollable || isAtBottom) {
                    scrollHint.classList.add('hidden');
                    scrollContainer.classList.add('scrolled-bottom');
                } else {
                    scrollHint.classList.remove('hidden');
                    scrollContainer.classList.remove('scrolled-bottom');
                }
            }

            // Listen to scroll events
            scrollContainer.addEventListener('scroll', updateScrollHint, { passive: true });

            // Initial check (delay to allow content to load)
            setTimeout(updateScrollHint, 500);

            // Re-check after data loads
            const observer = new MutationObserver(() => {
                setTimeout(updateScrollHint, 100);
            });
            observer.observe(scrollContainer, { childList: true, subtree: true });
        }


        console.log('[DEBUG] Script executing, about to register DOMContentLoaded');

        // Initialize on load with performance optimizations
        document.addEventListener('DOMContentLoaded', () => {
            console.log('[DEBUG] DOMContentLoaded fired!');
            try {
                // Use requestIdleCallback for non-critical tasks
                if ('requestIdleCallback' in window) {
                    requestIdleCallback(() => {
                        connectWebSocket();
                    });
                } else {
                    setTimeout(connectWebSocket, 100);
                }

                console.log('[DEBUG] About to call loadDashboardData()');
                loadDashboardData();

            // Debounced icon refresh
            const debouncedIconRefresh = debounce(() => {
                if (typeof lucide !== 'undefined') lucide.createIcons();
            }, 100);

            // Optimize mutation observer
            const observer = new MutationObserver(debouncedIconRefresh);
            observer.observe(document.body, {
                childList: true,
                subtree: true,
                attributes: false,
                characterData: false
            });

            // Initialize Zen Mode (hidden easter egg feature)
            initZenMode();

            // Load news ticker (instant from cache, then background refresh)
            loadNewsTicker();
            startNewsRefresh(); // Periodic refresh every 5 minutes
            loadSettings(); // Load user settings including news ticker visibility

            // Initialize iOS-style features
            initHapticFeedback();
            console.log('[DEBUG] iOS features initialized (haptics)');

            // Initialize Performance Tracker settings (timeframe, auto-refresh)
            initPerformanceSettings();
            if (perfAutoRefreshEnabled) {
                startPerfAutoRefresh();
            }

            // Initialize confluence scroll indicator
            initConfluenceScrollHint();

            // Initialize alert notification system
            initNotifications();
            // Load alerts on startup to check for unread (without switching tabs)
            loadAlertsData();

            console.log('[DEBUG] DOMContentLoaded handler completed successfully');
            } catch (e) {
                console.error('[DEBUG] ERROR in DOMContentLoaded:', e);
                const errDiv = document.createElement('div');
                errDiv.style.cssText = 'position:fixed;top:0;left:0;right:0;background:red;color:white;padding:10px;z-index:9999;';
                errDiv.textContent = 'Init Error: ' + e.message;
                document.body.prepend(errDiv);
            }
        });

        // Handle visibility change
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) {
                refreshData();
            }
        });

        // Service Worker for offline support
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/sw.js').catch(() => {
                console.log('Service Worker registration failed');
            });
        }

        /* ============================================
           ZEN MODE - Hidden Easter Egg Feature
           Double-tap the VIRTUOSO title to toggle header buttons
           State persists across page loads via localStorage
           ============================================ */

        function initZenMode() {
            const appTitle = document.getElementById('appTitle');
            const headerActions = document.getElementById('headerActions');

            if (!appTitle || !headerActions) {
                console.error('Zen Mode: Required elements not found');
                return;
            }

            let tapCount = 0;
            let tapTimeout = null;
            const doubleTapDelay = 400; // ms window for double-tap
            const isTouchDevice = 'ontouchstart' in window;

            // Restore zen mode state from localStorage
            const isZenMode = localStorage.getItem('zenMode') === 'true';
            const priceTicker = document.getElementById('priceTicker');
            const newsTicker = document.getElementById('newsTicker');
            if (isZenMode) {
                headerActions.classList.add('zen-hidden');
                if (priceTicker) priceTicker.classList.add('zen-hidden');
                if (newsTicker) newsTicker.classList.add('zen-hidden');
                console.log('Zen Mode: Restored hidden state');
            }

            // Unified tap handler
            function handleTap(e) {
                // On touch devices, ignore click events (they fire after touchend)
                if (e.type === 'click' && isTouchDevice) return;

                tapCount++;
                console.log('Zen tap #' + tapCount);

                if (tapCount === 1) {
                    // First tap - wait for second
                    tapTimeout = setTimeout(() => {
                        tapCount = 0;
                    }, doubleTapDelay);
                } else if (tapCount >= 2) {
                    // Double-tap!
                    clearTimeout(tapTimeout);
                    tapCount = 0;
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Zen Mode: Double-tap triggered!');
                    toggleZenMode();
                }
            }

            // Attach appropriate listener based on device type
            if (isTouchDevice) {
                appTitle.addEventListener('touchend', handleTap, { passive: false });
            } else {
                appTitle.addEventListener('click', handleTap);
            }

            console.log('Zen Mode ready. Double-tap VIRTUOSO to toggle.');
        }

        function toggleZenMode() {
            const appTitle = document.getElementById('appTitle');
            const headerActions = document.getElementById('headerActions');
            const priceTicker = document.getElementById('priceTicker');
            const newsTicker = document.getElementById('newsTicker');

            // Toggle the hidden state
            const isHidden = headerActions.classList.contains('zen-hidden');

            if (isHidden) {
                // Show actions and tickers
                headerActions.classList.remove('zen-hidden');
                if (priceTicker) priceTicker.classList.remove('zen-hidden');
                if (newsTicker) newsTicker.classList.remove('zen-hidden');
                localStorage.setItem('zenMode', 'false');
            } else {
                // Hide actions and tickers
                headerActions.classList.add('zen-hidden');
                if (priceTicker) priceTicker.classList.add('zen-hidden');
                if (newsTicker) newsTicker.classList.add('zen-hidden');
                localStorage.setItem('zenMode', 'true');
            }

            // Visual feedback: amber glow pulse
            appTitle.classList.remove('zen-tapped');
            // Force reflow to restart animation
            void appTitle.offsetWidth;
            appTitle.classList.add('zen-tapped');

            // Remove animation class after completion
            setTimeout(() => {
                appTitle.classList.remove('zen-tapped');
            }, 600);

            console.log(`Zen Mode ${isHidden ? 'disabled' : 'enabled'} - header actions ${isHidden ? 'shown' : 'hidden'}`);
        }

        // Settings Management
        let autoRefreshInterval = null;
        let userSettings = {
            refreshRate: 60000,
            defaultSort: 'score',
            symbolsLimit: 20,
            minConfluence: 70,
            soundAlerts: false,
            showNewsTicker: true,
            visibleCards: {
                marketOverview: true,
                topMovers: true
            }
        };

        function toggleSettings() {
            const panel = document.getElementById('settingsPanel');
            const overlay = document.getElementById('settingsOverlay');
            const isOpen = panel.style.right === '0px';
            
            if (isOpen) {
                panel.style.right = '-100%';
                overlay.style.opacity = '0';
                overlay.style.visibility = 'hidden';
            } else {
                panel.style.right = '0px';
                overlay.style.opacity = '1';
                overlay.style.visibility = 'visible';
                if (typeof lucide !== 'undefined') lucide.createIcons();
            }
        }

        function updateRefreshRate() {
            const rate = parseInt(document.getElementById('refreshRate').value);
            userSettings.refreshRate = rate;
            saveSettings();
            setupAutoRefresh();
        }

        function updateDefaultSort() {
            const sort = document.getElementById('defaultSort').value;
            userSettings.defaultSort = sort;
            
            const sortSelector = document.getElementById('sortSelector');
            if (sortSelector) {
                sortSelector.value = sort;
            }
            
            sortSymbols();
            saveSettings();
        }

        function updateSymbolsLimit() {
            const limit = parseInt(document.getElementById('symbolsLimit').value);
            userSettings.symbolsLimit = limit;
            saveSettings();
            loadDashboardData();
        }

        function updateMinConfluence() {
            const min = parseInt(document.getElementById('minConfluence').value);
            userSettings.minConfluence = min;
            saveSettings();
        }

        function updateSoundAlerts() {
            const enabled = document.getElementById('soundAlerts').checked;
            userSettings.soundAlerts = enabled;
            saveSettings();
        }

        function toggleCard(cardType) {
            const checkbox = document.getElementById(`show${cardType.charAt(0).toUpperCase() + cardType.slice(1)}`);
            userSettings.visibleCards[cardType] = checkbox.checked;
            saveSettings();
            applyCardVisibility();
        }

        function applyCardVisibility() {
            const cards = document.querySelectorAll('.mobile-card');
            cards.forEach(card => {
                const title = card.querySelector('.card-title')?.textContent;
                if (title?.includes('Market Overview') && !userSettings.visibleCards.marketOverview) {
                    card.style.display = 'none';
                } else if (title?.includes('Top Movers') && !userSettings.visibleCards.topMovers) {
                    card.style.display = 'none';
                } else {
                    card.style.display = 'block';
                }
            });
        }

        // News Ticker Functions
        function toggleNewsTicker() {
            const checkbox = document.getElementById('showNewsTicker');
            userSettings.showNewsTicker = checkbox.checked;
            saveSettings();
            applyNewsTickerVisibility();
        }

        function applyNewsTickerVisibility() {
            const newsTicker = document.getElementById('newsTicker');
            if (!newsTicker) return;

            // Don't show if in zen mode
            const isZenMode = localStorage.getItem('zenMode') === 'true';
            if (isZenMode) {
                newsTicker.style.display = 'none';
                return;
            }

            // Apply user setting
            if (userSettings.showNewsTicker) {
                newsTicker.style.display = 'flex';
            } else {
                newsTicker.style.display = 'none';
            }
        }

        // News ticker cache configuration
        const NEWS_CACHE_KEY = 'virtuoso_news_cache';
        const NEWS_REFRESH_INTERVAL = 300000; // 5 minutes
        let newsRefreshTimer = null;

        function getNewsFromCache() {
            try {
                const cached = localStorage.getItem(NEWS_CACHE_KEY);
                if (cached) {
                    const { news } = JSON.parse(cached);
                    return news;
                }
            } catch (e) {}
            return null;
        }

        function saveNewsToCache(news) {
            try {
                localStorage.setItem(NEWS_CACHE_KEY, JSON.stringify({
                    news: news,
                    timestamp: Date.now()
                }));
            } catch (e) {}
        }

        function renderNewsItems(newsTrack, news) {
            const newsItems = news.slice(0, 20).map(item => {
                const timeAgo = getTimeAgo(item.timestamp * 1000);
                return `
                    <div class="news-item">
                        <a href="${item.link}" target="_blank" rel="noopener">${item.title}</a>
                        <span class="news-source">${timeAgo}</span>
                    </div>
                    <span class="news-separator">•</span>
                `;
            }).join('');
            // Duplicate for seamless scroll
            newsTrack.innerHTML = newsItems + newsItems;

            // Adjust animation speed based on content width (slower for reading)
            const contentWidth = newsTrack.scrollWidth / 2;
            const speed = Math.max(15, contentWidth / 60); // ~60px per second
            newsTrack.style.animationDuration = `${speed}s`;
        }

        async function loadNewsTicker() {
            const newsTrack = document.getElementById('newsTrack');
            if (!newsTrack) return;

            // 1. INSTANT: Show cached news immediately (no waiting)
            const cached = getNewsFromCache();
            if (cached && cached.length > 0) {
                renderNewsItems(newsTrack, cached);
            } else {
                // First visit - show loading state
                newsTrack.innerHTML = '<div class="news-item" style="opacity: 0.6;">Loading news...</div>';
            }

            // 2. BACKGROUND: Fetch fresh news without blocking
            try {
                const response = await fetch('/api/dashboard/news');
                const data = await response.json();

                if (data.news && data.news.length > 0) {
                    // Save to cache for next page load
                    saveNewsToCache(data.news);
                    // Update display with fresh data
                    renderNewsItems(newsTrack, data.news);
                }
            } catch (error) {
                console.error('Error loading news:', error);
                // Only show error if no cached data
                if (!cached || cached.length === 0) {
                    newsTrack.innerHTML = '<div class="news-item">Unable to load news</div>';
                }
            }
        }

        function startNewsRefresh() {
            // Clear any existing timer
            if (newsRefreshTimer) clearInterval(newsRefreshTimer);
            // Refresh news every 5 minutes
            newsRefreshTimer = setInterval(() => loadNewsTicker(), NEWS_REFRESH_INTERVAL);
        }

        function getTimeAgo(timestamp) {
            const now = Date.now();
            const diff = now - timestamp;
            const minutes = Math.floor(diff / 60000);
            const hours = Math.floor(diff / 3600000);
            const days = Math.floor(diff / 86400000);

            if (minutes < 1) return 'just now';
            if (minutes < 60) return `${minutes}m ago`;
            if (hours < 24) return `${hours}h ago`;
            return `${days}d ago`;
        }

        function resetSettings() {
            userSettings = {
                refreshRate: 60000,
                defaultSort: 'score',
                symbolsLimit: 20,
                minConfluence: 70,
                soundAlerts: false,
                showNewsTicker: true,
                visibleCards: {
                    marketOverview: true,
                    topMovers: true
                }
            };
            loadSettingsUI();
            saveSettings();
            setupAutoRefresh();
            applyCardVisibility();
            applyNewsTickerVisibility();
        }

        function exportSettings() {
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(userSettings, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "virtuoso-settings.json");
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        }

        function saveSettings() {
            localStorage.setItem('virtuoso-settings', JSON.stringify(userSettings));
        }

        function loadSettings() {
            const saved = localStorage.getItem('virtuoso-settings');
            if (saved) {
                userSettings = { ...userSettings, ...JSON.parse(saved) };
            }
            loadSettingsUI();
        }

        function loadSettingsUI() {
            // Settings panel elements (may not exist if settings modal not opened yet)
            const refreshRate = document.getElementById('refreshRate');
            const defaultSort = document.getElementById('defaultSort');
            const symbolsLimit = document.getElementById('symbolsLimit');
            const minConfluence = document.getElementById('minConfluence');
            const soundAlerts = document.getElementById('soundAlerts');
            const showNewsTicker = document.getElementById('showNewsTicker');
            const showMarketOverview = document.getElementById('showMarketOverview');
            const showTopMovers = document.getElementById('showTopMovers');
            
            if (refreshRate) refreshRate.value = userSettings.refreshRate;
            if (defaultSort) defaultSort.value = userSettings.defaultSort;
            if (symbolsLimit) symbolsLimit.value = userSettings.symbolsLimit;
            if (minConfluence) minConfluence.value = userSettings.minConfluence;
            if (soundAlerts) soundAlerts.checked = userSettings.soundAlerts;
            if (showNewsTicker) showNewsTicker.checked = userSettings.showNewsTicker;
            if (showMarketOverview) showMarketOverview.checked = userSettings.visibleCards.marketOverview;
            if (showTopMovers) showTopMovers.checked = userSettings.visibleCards.topMovers;

            // Sort selector in Beta Analysis section (may not be loaded yet if tab not active)
            const sortSelector = document.getElementById('sortSelector');
            if (sortSelector) {
                sortSelector.value = userSettings.defaultSort;
            }

            // Apply news ticker visibility
            applyNewsTickerVisibility();
        }

        function setupAutoRefresh() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
            }
            
            if (userSettings.refreshRate > 0) {
                autoRefreshInterval = setInterval(() => {
                    const activeTab = document.querySelector('.nav-item.active');
                    if (activeTab) {
                        const onclick = activeTab.getAttribute('onclick');
                        const tabName = onclick.match(/'([^']+)'/)[1];
                        loadTabData(tabName);
                    }
                }, userSettings.refreshRate);
            }
        }
    </script>

        <!-- Cache Status Indicator removed -->
        
</body>
</html>
