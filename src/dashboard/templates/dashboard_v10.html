<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Virtuoso Dashboard V10 - Signal Confluence Matrix</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <style>
        /* Terminal Amber + Navy Blue Theme */
        :root {
            --bg-primary: #0c1a2b;
            --bg-secondary: #0f172a;
            --bg-hero: #0f172a;
            --bg-satellite: #0f172a;
            --bg-header: #0a1525;
            --text-primary: #ffbf00;
            --text-secondary: #b8860b;
            --accent-primary: #ff9900;
            --accent-positive: #ffc107;
            --accent-negative: #ff5722;
            --accent-warning: #ff9900;
            --border-light: #1a2a40;
            --glow-amber: #ffbf00;
            
            /* Signal confidence colors */
            --signal-strong: #ffc107;
            --signal-medium: #ff9900;
            --signal-weak: #ff7043;
            --signal-neutral: #607d8b;
            --signal-negative: #f44336;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'JetBrains Mono', 'Courier New', monospace;
        }

        body {
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 50%, var(--bg-hero) 100%);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
            font-weight: 400;
        }

        /* Subtle pattern overlay */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(circle at 25% 25%, rgba(255, 191, 0, 0.05) 0%, transparent 50%),
                radial-gradient(circle at 75% 75%, rgba(255, 153, 0, 0.05) 0%, transparent 50%);
            background-size: 200px 200px;
            opacity: 0.3;
            z-index: -1;
            pointer-events: none;
        }

        /* Terminal ambient lighting */
        .ambient-glow {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 200px;
            background: linear-gradient(to top, rgba(255, 153, 0, 0.1), transparent);
            z-index: -1;
            pointer-events: none;
        }

        /* Header */
        .header {
            display: flex;
            flex-direction: column;
            padding: 2rem 2.5rem 0 2.5rem;
            border-bottom: 2px solid var(--border-light);
            background: linear-gradient(135deg, var(--bg-header), var(--bg-satellite));
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 191, 0, 0.3);
            position: relative;
        }

        .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        /* Tab Navigation */
        .tab-navigation {
            display: flex;
            gap: 1px;
            margin-bottom: 0;
            border-bottom: 1px solid var(--border-light);
        }

        .tab-button {
            background: linear-gradient(135deg, var(--bg-satellite), var(--bg-primary));
            border: none;
            color: var(--text-secondary);
            padding: 1rem 2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-top: 2px solid transparent;
            position: relative;
        }

        .tab-button:hover {
            background: linear-gradient(135deg, var(--bg-hero), var(--bg-satellite));
            color: var(--text-primary);
            border-top-color: var(--accent-primary);
        }

        .tab-button.active {
            background: linear-gradient(135deg, var(--bg-hero), var(--bg-satellite));
            color: var(--accent-positive);
            border-top-color: var(--accent-positive);
            box-shadow: 
                0 -4px 15px rgba(255, 193, 7, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .tab-button.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: var(--accent-positive);
        }



        .header::before {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, 
                transparent 0%, 
                var(--accent-primary) 25%, 
                var(--accent-positive) 50%, 
                var(--accent-primary) 75%, 
                transparent 100%);
            animation: terminalScan 3s ease-in-out infinite;
        }

        @keyframes terminalScan {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        .terminal-title {
            font-size: 2.4rem;
            color: var(--accent-positive);
            margin: 0;
            text-transform: uppercase;
            letter-spacing: 4px;
            font-weight: 700;
            text-shadow: 
                0 0 8px var(--accent-positive),
                0 0 16px var(--accent-positive);
            position: relative;
            font-family: 'JetBrains Mono', monospace;
            border: 2px solid var(--accent-positive);
            padding: 12px 20px;
            background: rgba(255, 193, 7, 0.08);
            border-radius: 6px;
            display: inline-flex;
            align-items: center;
            box-shadow: 0 4px 15px rgba(255, 193, 7, 0.2);
        }

        .terminal-title::before {
            content: '';
            position: absolute;
            left: -50px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--accent-positive);
            font-size: 1.5rem;
            text-shadow: 0 0 8px var(--accent-positive);
        }

        .terminal-title::after {
            content: '_';
            animation: blink 1s infinite;
            color: var(--accent-positive);
            margin-left: 8px;
        }

        .terminal-icon {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            color: var(--accent-positive);
            margin-right: 1rem;
            vertical-align: middle;
            stroke-width: 2.5;
            filter: drop-shadow(0 0 6px var(--accent-positive));
            animation: iconPulse 3s ease-in-out infinite;
        }

        @keyframes iconPulse {
            0%, 100% { 
                opacity: 1;
                transform: scale(1);
            }
            50% { 
                opacity: 0.8;
                transform: scale(1.05);
            }
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .subtitle {
            font-size: 0.9rem;
            color: var(--accent-positive);
            margin-top: 8px;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: 400;
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 1.5rem;
        }

        .config-toggle {
            background: linear-gradient(135deg, var(--bg-satellite), var(--bg-header));
            border: 1px solid var(--border-light);
            color: var(--text-primary);
            padding: 0.8rem 1.5rem;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 
                0 4px 15px rgba(255, 153, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            text-transform: uppercase;
            font-weight: 500;
            letter-spacing: 1px;
            font-family: 'JetBrains Mono', monospace;
            position: relative;
            overflow: hidden;
        }

        .config-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 
                0 8px 25px rgba(255, 153, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            border-color: var(--accent-positive);
            background: var(--accent-primary);
            color: var(--bg-primary);
        }

        .tab-button.nav-link {
            text-decoration: none;
            display: inline-block;
        }

        .tab-button.nav-link:hover {
            background: linear-gradient(135deg, var(--bg-hero), var(--bg-satellite));
            color: var(--signal-strong);
            border-top-color: var(--signal-strong);
            box-shadow: 
                0 -4px 15px rgba(16, 185, 129, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .real-time-indicator {
            display: flex;
            align-items: center;
            gap: 12px;
            background: linear-gradient(135deg, var(--bg-satellite), var(--bg-header));
            padding: 12px 20px;
            border: 1px solid var(--border-light);
            border-radius: 4px;
            box-shadow: 
                inset 0 2px 4px rgba(0, 0, 0, 0.3),
                0 0 15px rgba(255, 153, 0, 0.2);
        }

        .status-light {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--accent-positive);
            box-shadow: 0 0 15px var(--accent-positive);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .status-text {
            font-size: 0.85rem;
            color: var(--text-primary);
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Scrolling Ticker Bar */
        .ticker-container {
            background: linear-gradient(135deg, var(--bg-header), var(--bg-satellite));
            border-bottom: 2px solid var(--border-light);
            border-top: 1px solid var(--border-light);
            height: 60px;
            overflow: hidden;
            position: relative;
            box-shadow: 
                inset 0 2px 4px rgba(0, 0, 0, 0.3),
                0 2px 8px rgba(255, 153, 0, 0.1);
        }

        .ticker-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 1px;
            background: linear-gradient(90deg, 
                transparent 0%, 
                var(--accent-primary) 25%, 
                var(--accent-positive) 50%, 
                var(--accent-primary) 75%, 
                transparent 100%);
            animation: terminalScan 2s ease-in-out infinite;
        }

        .ticker-wrapper {
            height: 100%;
            display: flex;
            align-items: center;
            position: relative;
        }

        .ticker-content {
            display: flex;
            align-items: center;
            white-space: nowrap;
            animation: scrollLeft 60s linear infinite;
            gap: 2rem;
            padding-left: 100%;
        }

        @keyframes scrollLeft {
            0% {
                transform: translateX(0);
            }
            100% {
                transform: translateX(-100%);
            }
        }

        .ticker-item {
            display: inline-flex;
            align-items: center;
            background: linear-gradient(135deg, var(--bg-hero), var(--bg-primary));
            border: 1px solid var(--border-light);
            border-radius: 6px;
            padding: 8px 16px;
            margin: 0 12px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-primary);
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 
                0 2px 8px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            position: relative;
            min-width: 120px;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .ticker-item::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 3px;
            background: var(--accent-positive);
            border-radius: 6px 0 0 6px;
        }

        .ticker-item:hover {
            transform: scale(1.05);
            box-shadow: 
                0 4px 15px rgba(255, 153, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            border-color: var(--accent-positive);
            z-index: 10;
        }

        .ticker-symbol {
            color: var(--accent-positive);
            font-weight: 700;
            text-shadow: 0 0 8px rgba(255, 193, 7, 0.3);
            margin-right: 8px;
        }

        .ticker-change {
            font-size: 0.8rem;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        .price-positive {
            color: #4caf50;
            text-shadow: 0 0 6px rgba(76, 175, 80, 0.4);
        }

        .price-negative {
            color: #f44336;
            text-shadow: 0 0 6px rgba(244, 67, 54, 0.4);
        }

        .price-neutral {
            color: var(--text-secondary);
            text-shadow: 0 0 6px rgba(184, 134, 11, 0.3);
        }

        .ticker-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text-secondary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .ticker-loading::after {
            content: '...';
            animation: dots 1.5s infinite;
        }

        @keyframes dots {
            0%, 20% { color: transparent; }
            40% { color: var(--text-secondary); }
            100% { color: transparent; }
        }

        /* Main Container */
        .container {
            padding: 2rem 2.5rem;
            max-width: 100%;
            margin: 0 auto;
        }

        /* Dashboard Grid */
        .dashboard-grid {
            display: grid;
            grid-template-columns: 300px 1fr 320px 280px;
            grid-template-rows: auto auto auto;
            gap: 1.5rem;
            height: calc(100vh - 200px);
        }

        /* Panel Base Styles */
        .panel {
            background: linear-gradient(135deg, var(--bg-hero), var(--bg-satellite));
            border: 1px solid var(--border-light);
            border-radius: 8px;
            padding: 1.5rem;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
            position: relative;
            overflow: hidden;
        }

        .panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-positive), var(--accent-primary));
            opacity: 0.6;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid rgba(26, 42, 64, 0.5);
        }

        .panel-title {
            font-size: 0.85rem;
            color: var(--text-primary);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-family: 'JetBrains Mono', monospace;
        }

        .panel-count {
            font-size: 0.75rem;
            color: var(--accent-positive);
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Left Side Panel */
        .signals-panel {
            grid-column: 1;
            grid-row: 1 / 3;
            overflow-y: auto;
        }

        /* Signal Confluence Matrix - Center (Now wider) */
        .matrix-panel {
            grid-column: 2;
            grid-row: 1 / 3;
            overflow-x: auto;
        }

        /* Right Side Panels */
        .opportunities-panel {
            grid-column: 3;
            grid-row: 1;
            overflow-y: auto;
        }

        /* NEW: Confluence Tracking Panel */
        .tracking-panel {
            grid-column: 3;
            grid-row: 2;
            overflow-y: auto;
        }

        .alpha-panel {
            grid-column: 4;
            grid-row: 1 / 3;
            overflow-y: auto;
        }

        /* Bottom Row Panels */
        .performance-panel {
            grid-column: 1 / 5;
            grid-row: 3;
            overflow-x: auto;
        }

        .matrix-container {
            min-width: 1200px;
            overflow-x: auto;
        }

        .matrix-header {
            display: grid;
            grid-template-columns: 120px 100px repeat(12, 75px);
            gap: 2px;
            margin-bottom: 8px;
            position: sticky;
            top: 0;
            background: var(--bg-hero);
            z-index: 10;
            padding: 8px 0;
        }

        .matrix-header-cell {
            background: linear-gradient(135deg, var(--bg-header), var(--bg-satellite));
            border: 1px solid var(--border-light);
            border-radius: 4px;
            padding: 8px 4px;
            text-align: center;
            font-size: 7px;
            color: var(--text-secondary);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            line-height: 1.1;
        }

        .matrix-header-asset {
            font-size: 9px;
            color: var(--text-primary);
            font-weight: 700;
        }

        .matrix-grid {
            display: grid;
            grid-template-columns: 120px 100px repeat(12, 75px);
            gap: 2px;
            max-height: calc(100vh - 400px);
            overflow-y: auto;
        }

        .matrix-row-header {
            background: linear-gradient(135deg, var(--bg-header), var(--bg-satellite));
            border: 1px solid var(--border-light);
            border-radius: 4px;
            padding: 12px 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            color: var(--text-primary);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: sticky;
            left: 0;
            z-index: 5;
        }

        .matrix-cell {
            background: linear-gradient(135deg, var(--bg-hero), var(--bg-satellite));
            border: 1px solid var(--border-light);
            border-radius: 4px;
            padding: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            min-height: 60px;
        }

        .matrix-cell:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 20px rgba(255, 191, 0, 0.4);
            border-color: var(--accent-positive);
            z-index: 15;
        }

        .matrix-row-focused {
            animation: rowHighlight 2s ease-in-out;
            border-color: var(--accent-positive) !important;
            box-shadow: 0 0 15px rgba(255, 193, 7, 0.5) !important;
        }

        @keyframes rowHighlight {
            0%, 100% { 
                box-shadow: 0 0 15px rgba(255, 193, 7, 0.5);
                border-color: var(--accent-positive);
            }
            50% { 
                box-shadow: 0 0 25px rgba(255, 193, 7, 0.8);
                border-color: var(--signal-strong);
            }
        }

        .signal-icon {
            font-size: 16px;
            margin-bottom: 4px;
            font-weight: 700;
        }

        .signal-confidence {
            font-size: 8px;
            font-weight: 600;
            font-family: 'JetBrains Mono', monospace;
            color: var(--bg-primary);
        }

        /* Signal Strength Color Classes */
        .signal-strong-bullish {
            background: linear-gradient(135deg, #4caf50, #66bb6a);
            color: white;
        }

        .signal-medium-bullish {
            background: linear-gradient(135deg, #8bc34a, #aed581);
            color: white;
        }

        .signal-weak-bullish {
            background: linear-gradient(135deg, #cddc39, #dce775);
            color: var(--bg-primary);
        }

        .signal-neutral {
            background: linear-gradient(135deg, var(--bg-satellite), var(--border-light));
            color: var(--text-secondary);
        }

        .signal-weak-bearish {
            background: linear-gradient(135deg, #ff9800, #ffb74d);
            color: white;
        }

        .signal-medium-bearish {
            background: linear-gradient(135deg, #ff5722, #ff7043);
            color: white;
        }

        .signal-strong-bearish {
            background: linear-gradient(135deg, #f44336, #e57373);
            color: white;
        }

        /* Composite Score Styles */
        .composite-score-cell {
            min-height: 70px;
            font-size: 16px;
            font-weight: 700;
            position: relative;
            border: 2px solid transparent;
        }

        .composite-score-value {
            font-size: 20px;
            font-weight: 900;
            text-shadow: 0 0 10px currentColor;
            margin-bottom: 4px;
        }

        .composite-score-label {
            font-size: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.9;
        }

        .score-excellent {
            background: linear-gradient(135deg, #00e676, #4caf50);
            border-color: #00e676;
            color: white;
            box-shadow: 0 0 20px rgba(0, 230, 118, 0.4);
        }

        .score-good {
            background: linear-gradient(135deg, #76ff03, #8bc34a);
            border-color: #76ff03;
            color: var(--bg-primary);
            box-shadow: 0 0 15px rgba(118, 255, 3, 0.3);
        }

        .score-fair {
            background: linear-gradient(135deg, #ffeb3b, #ffc107);
            border-color: #ffeb3b;
            color: var(--bg-primary);
            box-shadow: 0 0 15px rgba(255, 235, 59, 0.3);
        }

        .score-poor {
            background: linear-gradient(135deg, #ff9800, #ff5722);
            border-color: #ff9800;
            color: white;
            box-shadow: 0 0 15px rgba(255, 152, 0, 0.3);
        }

        .score-avoid {
            background: linear-gradient(135deg, #f44336, #d32f2f);
            border-color: #f44336;
            color: white;
            box-shadow: 0 0 15px rgba(244, 67, 54, 0.3);
        }

        /* Top Opportunities Panel */
        .opportunity-item {
            background: linear-gradient(135deg, var(--bg-hero), var(--bg-satellite));
            border: 1px solid var(--border-light);
            border-radius: 8px;
            padding: 16px;
            margin: 12px 0;
            position: relative;
            transition: all 0.3s ease;
            overflow: hidden;
        }

        .opportunity-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: var(--accent-positive);
        }

        .opportunity-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(255, 193, 7, 0.3);
            border-color: var(--accent-positive);
        }

        .opportunity-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .opportunity-symbol {
            font-size: 14px;
            font-weight: 700;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
        }

        .opportunity-score {
            font-size: 18px;
            font-weight: 900;
            padding: 4px 12px;
            border-radius: 20px;
            font-family: 'JetBrains Mono', monospace;
            text-shadow: 0 0 10px currentColor;
        }

        .opportunity-metrics {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin: 12px 0;
        }

        .opportunity-metric {
            text-align: center;
            padding: 8px;
            background: rgba(26, 42, 64, 0.3);
            border-radius: 4px;
            border: 1px solid var(--border-light);
        }

        .metric-value {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
        }

        .metric-label {
            font-size: 8px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 2px;
        }

        .opportunity-actions {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        .action-btn {
            flex: 1;
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'JetBrains Mono', monospace;
        }

        .btn-trade {
            background: linear-gradient(135deg, #4caf50, #66bb6a);
            color: white;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
        }

        .btn-trade:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }

        .btn-analyze {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-positive));
            color: var(--bg-primary);
            box-shadow: 0 4px 15px rgba(255, 153, 0, 0.3);
        }

        .btn-analyze:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 20px rgba(255, 153, 0, 0.4);
        }

        /* Live Signals Panel */
        .signals-panel {
            grid-column: 1;
            grid-row: 1;
            max-height: 400px;
            overflow-y: auto;
        }

        .signal-compact {
            background: linear-gradient(135deg, var(--bg-hero), var(--bg-satellite));
            border-left: 3px solid var(--accent-positive);
            padding: 8px 12px;
            margin: 8px 0;
            border-radius: 4px;
            border: 1px solid var(--border-light);
            transition: all 0.3s ease;
        }

        .signal-compact:hover {
            transform: translateX(4px);
            box-shadow: 0 4px 15px rgba(255, 153, 0, 0.3);
        }

        .signal-compact-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }

        .signal-symbol {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 11px;
            font-family: 'JetBrains Mono', monospace;
        }

        .signal-action {
            font-size: 8px;
            padding: 2px 6px;
            border-radius: 2px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .action-long {
            background: rgba(76, 175, 80, 0.2);
            color: var(--accent-positive);
            border: 1px solid rgba(76, 175, 80, 0.3);
        }

        .action-short {
            background: rgba(255, 87, 34, 0.2);
            color: var(--accent-negative);
            border: 1px solid rgba(255, 87, 34, 0.3);
        }

        .action-watch {
            background: rgba(255, 153, 0, 0.2);
            color: var(--accent-warning);
            border: 1px solid rgba(255, 153, 0, 0.3);
        }

        .action-caution {
            background: rgba(255, 87, 34, 0.2);
            color: var(--accent-negative);
            border: 1px solid rgba(255, 87, 34, 0.3);
        }

        .signal-details {
            font-size: 9px;
            color: var(--text-secondary);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }





        /* Alpha Panel */
        .alpha-panel {
            grid-column: 1;
            grid-row: 2;
        }

        .alpha-item {
            background: linear-gradient(135deg, var(--bg-hero), var(--bg-satellite));
            border-left: 3px solid var(--accent-positive);
            padding: 12px;
            margin: 10px 0;
            border-radius: 4px;
            border: 1px solid var(--border-light);
            transition: all 0.3s ease;
        }

        .alpha-item:hover {
            transform: translateX(6px);
            box-shadow: 0 6px 20px rgba(255, 193, 7, 0.3);
        }

        .alpha-symbol {
            font-weight: 600;
            color: var(--accent-positive);
            font-size: 13px;
            font-family: 'JetBrains Mono', monospace;
            margin-bottom: 4px;
        }

        .alpha-pattern {
            font-size: 9px;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-bottom: 6px;
        }

        .alpha-stats {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .alpha-confidence {
            font-size: 11px;
            color: var(--accent-positive);
            font-weight: 600;
            font-family: 'JetBrains Mono', monospace;
        }

        .alpha-target {
            font-size: 11px;
            color: var(--text-primary);
            font-weight: 600;
            font-family: 'JetBrains Mono', monospace;
        }

        /* Confluence Tracking Panel Styles */
        .tracking-panel {
            max-height: 400px;
        }

        .tracking-controls {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            align-items: center;
        }

        .threshold-input {
            background: var(--bg-primary);
            border: 1px solid var(--border-light);
            color: var(--text-primary);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            width: 60px;
            font-family: 'JetBrains Mono', monospace;
        }

        .auto-track-toggle {
            background: linear-gradient(135deg, var(--bg-satellite), var(--bg-header));
            border: 1px solid var(--border-light);
            color: var(--text-secondary);
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 9px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: all 0.3s ease;
        }

        .auto-track-toggle.active {
            background: var(--accent-positive);
            color: var(--bg-primary);
            border-color: var(--accent-positive);
        }

        .tracked-signal {
            background: linear-gradient(135deg, var(--bg-hero), var(--bg-satellite));
            border-radius: 6px;
            padding: 10px;
            margin: 8px 0;
            border: 1px solid var(--border-light);
            position: relative;
            transition: all 0.3s ease;
            overflow: hidden;
        }

        .tracked-signal::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 3px;
            height: 100%;
            background: var(--accent-positive);
        }

        .tracked-signal.profitable::before {
            background: #4caf50;
        }

        .tracked-signal.losing::before {
            background: #f44336;
        }

        .tracked-signal:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 153, 0, 0.3);
        }

        .signal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .signal-symbol {
            font-size: 11px;
            font-weight: 700;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
        }

        .signal-score {
            font-size: 10px;
            font-weight: 600;
            padding: 2px 6px;
            border-radius: 10px;
            font-family: 'JetBrains Mono', monospace;
        }

        .signal-metrics {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
            margin: 8px 0;
        }

        .signal-metric {
            text-align: center;
            padding: 4px;
            background: rgba(26, 42, 64, 0.4);
            border-radius: 3px;
            border: 1px solid rgba(26, 42, 64, 0.8);
        }

        .metric-value {
            font-size: 10px;
            font-weight: 600;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
        }

        .metric-label {
            font-size: 7px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 1px;
        }

        .signal-pnl {
            font-size: 11px;
            font-weight: 700;
            font-family: 'JetBrains Mono', monospace;
            margin-bottom: 4px;
        }

        .signal-pnl.positive {
            color: #4caf50;
            text-shadow: 0 0 6px rgba(76, 175, 80, 0.4);
        }

        .signal-pnl.negative {
            color: #f44336;
            text-shadow: 0 0 6px rgba(244, 67, 54, 0.4);
        }

        .signal-pnl.neutral {
            color: var(--text-secondary);
        }

        .signal-actions {
            display: flex;
            gap: 4px;
            margin-top: 8px;
        }

        .signal-action-btn {
            flex: 1;
            padding: 4px 8px;
            border: none;
            border-radius: 3px;
            font-size: 8px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'JetBrains Mono', monospace;
        }

        .btn-stop {
            background: linear-gradient(135deg, #f44336, #e57373);
            color: white;
        }

        .btn-stop:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(244, 67, 54, 0.4);
        }

        .btn-details {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-positive));
            color: var(--bg-primary);
        }

        .btn-details:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(255, 153, 0, 0.4);
        }

        /* Signal Type Indicators */
        .signal-type {
            font-size: 9px;
            font-weight: 700;
            padding: 2px 6px;
            border-radius: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .signal-type.buy {
            background: rgba(76, 175, 80, 0.2);
            color: #4caf50;
            border: 1px solid rgba(76, 175, 80, 0.4);
        }

        .signal-type.sell {
            background: rgba(244, 67, 54, 0.2);
            color: #f44336;
            border: 1px solid rgba(244, 67, 54, 0.4);
        }

        .signal-strength {
            font-size: 8px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-left: 4px;
        }

        /* Performance Panel */
        .performance-panel {
            grid-column: 1 / 4;
            grid-row: 3;
        }

        .performance-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 20px;
            margin-top: 15px;
        }

        .perf-metric {
            background: linear-gradient(135deg, var(--bg-hero), var(--bg-primary));
            border: 1px solid var(--border-light);
            border-radius: 6px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .perf-metric:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(255, 153, 0, 0.3);
            border-color: var(--accent-positive);
        }

        .perf-value {
            font-size: 20px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 8px;
            text-shadow: 0 0 10px var(--glow-amber);
            font-family: 'JetBrains Mono', monospace;
        }

        .perf-label {
            font-size: 10px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 500;
        }

        /* Tooltip */
        .tooltip {
            position: absolute;
            background: rgba(10, 21, 37, 0.95);
            border: 1px solid var(--accent-positive);
            border-radius: 6px;
            padding: 12px;
            color: var(--text-primary);
            font-size: 10px;
            z-index: 1000;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            max-width: 300px;
            display: none;
        }

        .tooltip-title {
            font-weight: 600;
            color: var(--accent-positive);
            margin-bottom: 8px;
            font-size: 11px;
        }

        .tooltip-details {
            display: grid;
            grid-template-columns: auto auto;
            gap: 4px 12px;
            font-family: 'JetBrains Mono', monospace;
        }

        /* No Data Display */
        .matrix-no-data {
            grid-column: 1 / -1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 400px;
            background: linear-gradient(135deg, var(--bg-primary), var(--bg-satellite));
            border: 2px dashed var(--border-light);
            border-radius: 8px;
            text-align: center;
            padding: 3rem;
        }

        .no-data-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            opacity: 0.7;
        }

        .no-data-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent-warning);
            margin-bottom: 1rem;
            text-shadow: 0 0 10px rgba(255, 193, 7, 0.3);
        }

        .no-data-message {
            font-size: 1rem;
            color: var(--text-secondary);
            line-height: 1.6;
            margin-bottom: 2rem;
            max-width: 500px;
        }

        .no-data-actions {
            margin-top: 1rem;
        }

        .retry-btn {
            background: linear-gradient(135deg, var(--accent-warning), var(--accent-positive));
            color: var(--bg-primary);
            border: none;
            padding: 1rem 2rem;
            border-radius: 6px;
            font-weight: 600;
            font-family: 'JetBrains Mono', monospace;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .retry-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(255, 193, 7, 0.4);
        }

        /* Signal Notification Animations */
        @keyframes slideInRight {
            0% {
                transform: translateX(100%);
                opacity: 0;
            }
            100% {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOutRight {
            0% {
                transform: translateX(0);
                opacity: 1;
            }
            100% {
                transform: translateX(100%);
                opacity: 0;
            }
        }

        /* Responsive Design */
        @media (max-width: 1400px) {
            .matrix-container {
                min-width: 1000px;
            }
            
            .matrix-header {
                grid-template-columns: 100px repeat(12, 70px);
            }
            
            .matrix-grid {
                grid-template-columns: 100px repeat(12, 70px);
            }
            
            .matrix-header-cell {
                font-size: 6px;
            }
        }

        @media (max-width: 1600px) {
            .dashboard-grid {
                grid-template-columns: 280px 1fr 300px 270px;
                gap: 1.2rem;
            }
            .panel {
                padding: 1.5rem;
            }
        }

        @media (max-width: 1400px) {
            .dashboard-grid {
                grid-template-columns: 260px 1fr 280px 250px;
                gap: 1rem;
            }
            .panel {
                padding: 1.2rem;
            }
            .matrix-container {
                min-width: 900px;
            }
        }

        @media (max-width: 1200px) {
            .dashboard-grid {
                grid-template-columns: 1fr;
                grid-template-rows: repeat(5, auto);
                gap: 1rem;
            }
            
            .signals-panel { grid-column: 1; grid-row: 1; }
            .matrix-panel { grid-column: 1; grid-row: 2; }
            .opportunities-panel { grid-column: 1; grid-row: 3; }
            .alpha-panel { grid-column: 1; grid-row: 4; }
            .performance-panel { grid-column: 1; grid-row: 5; }
            
            .container {
                padding: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="ambient-glow"></div>
    
    <!-- Header -->
    <div class="header">
        <div class="header-top">
            <div class="terminal-title">
                <i data-lucide="activity" class="terminal-icon"></i>
                VIRTUOSO v10
            </div>
            <div id="error-panel" style="display:none; color: red; background-color: #330000; border: 1px solid red; padding: 10px; border-radius: 5px;"></div>
            <div class="header-controls">
                <div class="real-time-indicator">
                    <span class="status-indicator status-online pulse" id="connection-status"></span>
                </div>
            </div>
        </div>
        
        <!-- Tab Navigation -->
        <div class="tab-navigation">
            <button class="tab-button active" onclick="switchTab('matrix')">TRADING DASHBOARD</button>
            <a href="/market-analysis" class="tab-button nav-link">MARKET ANALYSIS</a>
            <a href="/beta-analysis" class="tab-button nav-link">BETA DASHBOARD</a>
        </div>
        

    </div>

    <!-- Scrolling Ticker Bar -->
    <div class="ticker-container">
        <div class="ticker-wrapper">
            <div class="ticker-content" id="symbolTicker">
                <!-- Symbols will be populated by JavaScript -->
            </div>
        </div>
    </div>

    <!-- Main Container -->
    <div class="container">
        <div class="dashboard-grid">
            <!-- Live Signals Panel -->
            <div class="panel signals-panel">
                <div class="panel-header">
                    <span class="panel-title">LIVE SIGNALS</span>
                    <span class="panel-count">0 ACTIVE</span>
                </div>
                <div id="signalsContainer">
                    <!-- Signal items will be populated by JavaScript with real data -->
                </div>
            </div>



            <!-- Signal Confluence Matrix -->
            <div class="panel matrix-panel">
                <div class="panel-header">
                    <span class="panel-title">SIGNAL CONFLUENCE MATRIX</span>
                    <span class="panel-count">REAL-TIME</span>
                </div>
                
                <div class="matrix-container">
                                         <!-- Matrix Header -->
                     <div class="matrix-header">
                         <div class="matrix-header-cell matrix-header-asset">ASSET</div>
                         <div class="matrix-header-cell matrix-header-asset">SCORE</div>
                         <div class="matrix-header-cell">TREND</div>
                         <div class="matrix-header-cell">TECHNICAL</div>
                         <div class="matrix-header-cell">VOLUME</div>
                         <div class="matrix-header-cell">ORDERFLOW</div>
                         <div class="matrix-header-cell">ORDERBOOK</div>
                         <div class="matrix-header-cell">SENTIMENT</div>
                         <div class="matrix-header-cell">PRICE STRUCT</div>
                         <div class="matrix-header-cell">BETA EXP</div>
                         <div class="matrix-header-cell">ALPHA</div>
                         <div class="matrix-header-cell">WHALE ACT</div>
                         <div class="matrix-header-cell">LIQUIDATION</div>
                         <div class="matrix-header-cell">MANIPULATION</div>
                     </div>

                    <!-- Matrix Grid -->
                    <div class="matrix-grid" id="signalMatrix">
                        <!-- Rows will be populated by JavaScript -->
                    </div>
                </div>
            </div>

            <!-- Alpha Panel -->
            <div class="panel alpha-panel">
                <div class="panel-header">
                    <span class="panel-title">ALPHA TARGETS</span>
                    <span class="panel-count">0 IDENTIFIED</span>
                </div>
                <div>
                    <!-- Alpha items will be populated by JavaScript with real data -->
                </div>
            </div>

            <!-- Top Opportunities Panel -->
            <div class="panel opportunities-panel">
                <div class="panel-header">
                    <span class="panel-title">TOP OPPORTUNITIES</span>
                    <span class="panel-count">HIGH CONVICTION</span>
                </div>
                <div id="opportunitiesContainer">
                    <!-- Opportunities will be populated by JavaScript -->
                </div>
            </div>

            <!-- NEW: Signal Tracking Panel -->
            <div class="panel tracking-panel">
                <div class="panel-header">
                    <span class="panel-title">SIGNAL TRACKING</span>
                    <span class="panel-count" id="trackingCount">0 ACTIVE</span>
                </div>
                
                <!-- Tracking Controls -->
                <div class="tracking-controls">
                    <label style="font-size: 8px; color: var(--text-secondary); text-transform: uppercase;">Auto-Track:</label>
                    <button class="auto-track-toggle active" id="autoTrackToggle">ENABLED</button>
                    <label style="font-size: 8px; color: var(--text-secondary); text-transform: uppercase; margin-left: 8px;">Signals:</label>
                    <select class="threshold-input" id="signalTypeFilter" style="width: 80px;">
                        <option value="all">ALL</option>
                        <option value="buy">BUY</option>
                        <option value="sell">SELL</option>
                    </select>
                </div>
                
                <!-- Active Trading Signals Container -->
                <div id="trackedSignalsContainer">
                    <!-- Active trading signals will be populated by JavaScript -->
                </div>
            </div>

            <!-- Performance Panel -->
            <div class="panel performance-panel">
                <div class="panel-header">
                    <span class="panel-title">PERFORMANCE METRICS</span>
                    <span class="panel-count">REAL-TIME</span>
                </div>
                <div class="performance-grid" id="performanceGrid">
                    <!-- Performance metrics will be populated by JavaScript -->
                </div>
            </div>


        </div>
    </div>

    <!-- Tooltip -->
    <div class="tooltip" id="matrixTooltip">
        <div class="tooltip-title" id="tooltipTitle"></div>
        <div class="tooltip-details" id="tooltipDetails"></div>
    </div>

    <script>
        // Tab switching functionality (simplified since external tabs are now separate pages)
        function switchTab(tabName) {
            // Remove active class from all tab buttons
            const tabButtons = document.querySelectorAll('.tab-button');
            tabButtons.forEach(button => button.classList.remove('active'));
            
            // Mark the current tab as active
            if (tabName === 'matrix') {
                document.querySelector('[onclick="switchTab(\'matrix\')"]').classList.add('active');
            }
        }




        // Asset pairs will be fetched dynamically from API - no static list

        // Signal types
        const signalTypes = [
            'trend', 'technical', 'volume', 'orderflow', 'orderbook', 
            'sentiment', 'priceStruct', 'betaExp', 'alpha', 'whaleAct', 
            'liquidation', 'manipulation'
        ];

        // Signal weights based on confluence config (80% confluence + 20% direct signals)
        const signalWeights = {
            // CONFLUENCE SIGNALS (80% total) - Normalized from config.yaml
            technical: 0.136,      // 17% * 0.8 = 13.6% - Technical indicators
            orderflow: 0.200,      // 25% * 0.8 = 20.0% - Order flow pressure
            volume: 0.096,         // 12% * 0.8 = 9.6%  - Volume analysis
            orderbook: 0.160,      // 20% * 0.8 = 16.0% - Order book analysis
            priceStruct: 0.120,    // 15% * 0.8 = 12.0% - Price structure
            sentiment: 0.080,      // 10% * 0.8 = 8.0%  - Market sentiment
            
            // TREND ANALYSIS (derived from multi-timeframe confluence)
            trend: 0.008,          // 0.8% - Multi-timeframe trend direction
            
            // DIRECT SIGNALS (20% total)
            alpha: 0.080,          // 8.0% - Alpha opportunities
            betaExp: 0.040,        // 4.0% - Beta expansion patterns
            whaleAct: 0.060,       // 6.0% - Whale activity detection
            liquidation: 0.030,    // 3.0% - Liquidation risk analysis
            manipulation: 0.030    // 3.0% - Manipulation detection
        };
        // Total = 1.000 (100%)

        // Dynamic API base URL detection
        const API_BASE_URL = `${window.location.protocol}//${window.location.hostname}:${window.location.port}`;
        
        // API Data Management
        let dashboardData = null;
        let liquidationData = null;
        let alphaData = null;
        let systemData = null;
        let tradingData = null;
        let marketData = null;
        let signalsData = null;
        let manipulationData = null;
        let realTimeAssets = [];

        // WebSocket Management
        let dashboardWebSocket = null;
        let wsReconnectAttempts = 0;
        let maxReconnectAttempts = 5;
        
        // Enhanced API call with fallback data
        async function fetchWithFallback(url, fallbackData = null, options = {}) {
            try {
                const response = await fetch(url, options);
                if (!response.ok) {
                    console.warn(`[API] ${url} returned ${response.status}, using fallback`);
                    return fallbackData;
                }
                return await response.json();
            } catch (error) {
                console.warn(`[API] ${url} failed:`, error.message, 'using fallback');
                return fallbackData;
            }
        }

        // Fetch real dashboard data
        async function fetchDashboardData() {
            try {
                const response = await fetch(`${API_BASE_URL}/api/dashboard/overview`);

                if (!response.ok) {
                    throw new Error(`API returned ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data) {
                    dashboardData = data;
                    return data;
                }
                return null;
            } catch (error) {
                console.error('[API] Error fetching dashboard data:', error);
                const errorPanel = document.getElementById('error-panel');
                if(errorPanel) {
                    errorPanel.textContent = 'Error: Could not connect to backend. Please check system status.';
                    errorPanel.style.display = 'block';
                }
                return null;
            }
        }

        // Fetch liquidation intelligence data
        async function fetchLiquidationData() {
            try {
                // Get liquidation alerts
                const alerts_res = await fetch(`${API_BASE_URL}/api/liquidation/alerts`);
                if (!alerts_res.ok) throw new Error('Failed to fetch liquidation alerts');
                const alerts = await alerts_res.json();

                // Get market stress indicators
                const stressData_res = await fetch(`${API_BASE_URL}/api/liquidation/stress-indicators`);
                if (!stressData_res.ok) throw new Error('Failed to fetch stress indicators');
                const stressData = await stressData_res.json();

                // Get cascade risk
                const cascadeData_res = await fetch(`${API_BASE_URL}/api/liquidation/cascade-risk`);
                if (!cascadeData_res.ok) throw new Error('Failed to fetch cascade risk');
                const cascadeData = await cascadeData_res.json();

                liquidationData = {
                    alerts: alerts,
                    stress: stressData,
                    cascade: cascadeData,
                    last_updated: new Date().toISOString()
                };

                console.log('[LIQUIDATION API] Data fetched successfully:', liquidationData);
                return liquidationData;
            } catch (error) {
                console.error('[LIQUIDATION API] Error fetching liquidation data:', error);
                return null;
            }
        }

        // Fetch alpha scanner data
        async function fetchAlphaData() {
            try {
                // Get alpha opportunities
                const opportunities_res = await fetch(`${API_BASE_URL}/api/alpha/opportunities`);
                if(!opportunities_res.ok) throw new Error('Failed to fetch alpha opportunities');
                const opportunities = await opportunities_res.json();

                // Get alpha scan results
                const scanData_res = await fetch(`${API_BASE_URL}/api/alpha/scan`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        symbols: realTimeAssets.slice(0, 10),
                        timeframes: ['1h', '4h'],
                        min_confluence_score: 0.5
                    })
                });
                if(!scanData_res.ok) throw new Error('Failed to fetch alpha scan data');
                const scanData = await scanData_res.json();

                alphaData = {
                    opportunities: opportunities,
                    scan_results: scanData,
                    last_updated: new Date().toISOString()
                };

                console.log('[ALPHA API] Data fetched successfully:', alphaData);
                return alphaData;
            } catch (error) {
                console.warn('[ALPHA API] Alpha endpoints not available, using fallback data');
                return {
                    opportunities: [],
                    scan_results: [],
                    last_updated: new Date().toISOString()
                };
            }
        }

        // Fetch system monitoring data  
        async function fetchSystemData() {
            try {
                const systemStatus_res = await fetch(`${API_BASE_URL}/api/system/status`);
                if(!systemStatus_res.ok) throw new Error('Failed to fetch system status');
                const systemStatus = await systemStatus_res.json();

                const performanceData_res = await fetch(`${API_BASE_URL}/api/system/performance`);
                if(!performanceData_res.ok) throw new Error('Failed to fetch system performance');
                const performanceData = await performanceData_res.json();

                const systemData = {
                    status: systemStatus,
                    performance: performanceData,
                    last_updated: new Date().toISOString()
                };

                console.log('[SYSTEM API] Data fetched successfully:', systemData);
                return systemData;
            } catch (error) {
                console.warn('[SYSTEM API] System endpoints not available, using fallback data');
                return {
                    status: { status: 'unknown', message: 'System API not available' },
                    performance: { cpu: 0, memory: 0, uptime: 0 },
                    last_updated: new Date().toISOString()
                };
            }
        }

        // Fetch trading and portfolio data
        async function fetchTradingData() {
            try {
                // Get portfolio summary
                const portfolioData_res = await fetch(`${API_BASE_URL}/api/trading/portfolio`);
                if(!portfolioData_res.ok) throw new Error('Failed to fetch portfolio data');
                const portfolioData = await portfolioData_res.json();

                // Get recent orders
                const ordersData_res = await fetch(`${API_BASE_URL}/api/trading/orders?limit=10`);
                if(!ordersData_res.ok) throw new Error('Failed to fetch orders');
                const ordersData = await ordersData_res.json();

                // Get current positions
                const positionsData_res = await fetch(`${API_BASE_URL}/api/trading/positions`);
                if(!positionsData_res.ok) throw new Error('Failed to fetch positions');
                const positionsData = await positionsData_res.json();

                const tradingData = {
                    portfolio: portfolioData,
                    orders: ordersData,
                    positions: positionsData,
                    last_updated: new Date().toISOString()
                };

                console.log('[TRADING API] Data fetched successfully:', tradingData);
                return tradingData;
            } catch (error) {
                console.error('[TRADING API] Error fetching trading data:', error);
                return null;
            }
        }

        // Fetch market analysis data
        async function fetchMarketData() {
            try {
                const marketOverview_res = await fetch(`${API_BASE_URL}/api/market/overview`);
                if(!marketOverview_res.ok) throw new Error('Failed to fetch market overview');
                const marketOverview = await marketOverview_res.json();

                const betaData_res = await fetch(`${API_BASE_URL}/api/bitcoin-beta/status`);
                if(!betaData_res.ok) throw new Error('Failed to fetch beta status');
                const betaData = await betaData_res.json();

                marketData = {
                    overview: marketOverview,
                    beta: betaData,
                    last_updated: new Date().toISOString()
                };

                console.log('[MARKET API] Data fetched successfully:', marketData);
                return marketData;
            } catch (error) {
                console.error('[MARKET API] Error fetching market data:', error);
                return null;
            }
        }

        // Fetch signals and alerts data
        async function fetchSignalsData() {
            try {
                const signalsData = await fetchWithFallback(`${API_BASE_URL}/api/signals/signals/latest?limit=10`, []);

                const alertsData = await fetchWithFallback(`${API_BASE_URL}/api/dashboard/alerts/recent?limit=10`, []);

                const signalsAndAlerts = {
                    signals: signalsData,
                    alerts: alertsData,
                    last_updated: new Date().toISOString()
                };

                console.log('[SIGNALS API] Data fetched successfully:', signalsAndAlerts);
                return signalsAndAlerts;
            } catch (error) {
                console.error('[SIGNALS API] Error fetching signals data:', error);
                return null;
            }
        }

        // Fetch manipulation detection data
        async function fetchManipulationData() {
            try {
                const manipulationData = await fetchWithFallback(`${API_BASE_URL}/api/manipulation/alerts`, []);

                const statsData = await fetchWithFallback(`${API_BASE_URL}/api/manipulation/stats`, {
                    total_alerts: 0,
                    severity_breakdown: {}
                });

                const manipulationInfo = {
                    alerts: manipulationData,
                    stats: statsData,
                    last_updated: new Date().toISOString()
                };

                console.log('[MANIPULATION API] Data fetched successfully:', manipulationInfo);
                return manipulationInfo;
            } catch (error) {
                console.error('[MANIPULATION API] Error fetching manipulation data:', error);
                return null;
            }
        }

        // Fetch top symbols for matrix - REAL DATA ONLY
        async function fetchTopSymbols() {
            try {
                console.log('[DEBUG] Fetching top symbols from API...');
                const data = await fetchWithFallback(`${API_BASE_URL}/api/top-symbols`, {
                    symbols: [
                        { symbol: "BTCUSDT", change_24h: 0 },
                        { symbol: "ETHUSDT", change_24h: 0 },
                        { symbol: "ADAUSDT", change_24h: 0 },
                        { symbol: "SOLUSDT", change_24h: 0 },
                        { symbol: "DOTUSDT", change_24h: 0 }
                    ]
                });
                console.log('[DEBUG] Response data:', data);
                console.log('[DEBUG] Raw API data:', data);
                
                // Extract symbols from API response with price change data
                if (data.symbols && Array.isArray(data.symbols)) {
                    console.log('[DEBUG] Processing symbols array of length:', data.symbols.length);
                    
                    realTimeAssets = data.symbols.map(item => {
                        // Handle both string symbols and object with symbol property
                        if (typeof item === 'string') {
                            return { symbol: item, change_24h: 0 };
                        } else if (item.symbol) {
                            return {
                                symbol: item.symbol,
                                change_24h: item.change_24h || 0
                            };
                        }
                        return null;
                    }).filter(item => item !== null).slice(0, 15); // Top 15 symbols
                    
                    console.log(`[API] Fetched ${realTimeAssets.length} real symbols:`, realTimeAssets);
                    
                    // Update ticker with new symbols
                    console.log('[DEBUG] Updating ticker with symbols...');
                    updateSymbolTicker(realTimeAssets);
                    
                    return realTimeAssets;
                } else {
                    console.error('[API] Invalid symbols data structure:', data);
                    console.error('[API] Expected data.symbols to be an array, got:', typeof data.symbols);
                    realTimeAssets = [];
                    return [];
                }
            } catch (error) {
                console.error('[API] Error fetching symbols:', error);
                realTimeAssets = [];
                return [];
            }
        }

        // Fetch correlation matrix data
        async function fetchCorrelationData() {
            try {
                const correlationData = await fetchWithFallback(`${API_BASE_URL}/api/correlation/live-matrix`, {
                    live_matrix: {},
                    performance_metrics: {
                        accuracy: "0%",
                        latency: "0ms",
                        signals_pnl: "$0",
                        active_count: 0,
                        win_rate: "0%",
                        sharpe: "0x"
                    }
                });

                console.log('[CORRELATION API] Data fetched successfully:', correlationData);
                return correlationData;
            } catch (error) {
                console.error('[CORRELATION API] Error fetching correlation data:', error);
                return null;
            }
        }

        // Generate signal data using ONLY real API data - no mock fallbacks
        async function generateSignalData() {
            console.log('[DEBUG] Starting generateSignalData...');
            await fetchTopSymbols();
            const apiData = await fetchDashboardData();
            
            console.log('[DEBUG] Dashboard API data:', apiData);
            
            // Fetch specialized API data (with fallbacks for 503 errors)
            const liqData = await fetchLiquidationData();
            const alphaDataFetched = await fetchAlphaData();
            const correlationData = await fetchCorrelationData();
            const manipulationDataFetched = await fetchManipulationData();
            
            // Store manipulation data globally
            manipulationData = manipulationDataFetched;
            
            // Prefer correlation matrix data if available, fallback to dashboard API
            if (correlationData && correlationData.live_matrix) {
                console.log('[CORRELATION] Using correlation matrix data');
                return correlationData.live_matrix;
            }
            
            // Use dashboard signals data if available
            if (apiData && apiData.signals && apiData.signals.length > 0) {
                console.log('[API] Using dashboard signals data');
                const data = {};
                
                // Process real assets that have actual signal data
                const availableSignals = apiData.signals.filter(signal => signal && signal.symbol);
                
                if (availableSignals.length === 0) {
                    console.warn('[API] No valid signal data found');
                    return null;
                }
                
                // Convert dashboard signals to matrix format
                availableSignals.forEach(signalData => {
                    const asset = signalData.symbol;
                    data[asset] = {
                        compositeScore: signalData.score || 50,
                        momentum: { confidence: signalData.score || 50, direction: signalData.type?.toLowerCase() || 'neutral', strength: signalData.strength || 'weak' },
                        technical: { confidence: signalData.score || 50, direction: signalData.type?.toLowerCase() || 'neutral', strength: signalData.strength || 'weak' },
                        volume: { confidence: signalData.score || 50, direction: 'neutral', strength: 'weak' },
                        orderflow: { confidence: signalData.score || 50, direction: 'neutral', strength: 'weak' },
                        orderbook: { confidence: signalData.score || 50, direction: 'neutral', strength: 'weak' },
                        sentiment: { confidence: signalData.score || 50, direction: 'neutral', strength: 'weak' },
                        priceStruct: { confidence: signalData.score || 50, direction: 'neutral', strength: 'weak' },
                        trend: { confidence: signalData.score || 50, direction: 'neutral', strength: 'weak' },
                        alpha: { confidence: signalData.score || 50, direction: 'neutral', strength: 'weak' },
                        betaExp: { confidence: signalData.score || 50, direction: 'neutral', strength: 'weak' },
                        whaleAct: { confidence: signalData.score || 50, direction: 'neutral', strength: 'weak' },
                        liquidation: { confidence: signalData.score || 50, direction: 'neutral', strength: 'weak' },
                        manipulation: { confidence: signalData.score || 50, direction: 'neutral', strength: 'weak' }
                    };
                });
                
                console.log('[API] Generated signal matrix data for', Object.keys(data).length, 'symbols');
                return data;
            }
            
            // Return null if no real API data is available
            console.warn('[API] No real signal data available from any API');
            return null;
        }
        
        // Legacy signal processing (kept for reference but not used)
        function processLegacySignals(availableSignals) {
            const data = {};
            availableSignals.forEach(signalData => {
                const asset = signalData.symbol;
                data[asset] = {};
                let totalScore = 0;
                let totalWeight = 0;
                
                signalTypes.forEach(signalType => {
                    let signalInfo = { confidence: 0, direction: 'neutral', strength: 'weak' };
                    
                    // Check for specialized API data first
                    if (signalType === 'liquidation' && liqData && liqData.alerts) {
                        // Use liquidation intelligence API data
                        const assetLiquidations = liqData.alerts.filter(alert => 
                            alert.symbol === asset || alert.affected_symbols?.includes(asset)
                        );
                        
                        if (assetLiquidations.length > 0) {
                            const avgSeverity = assetLiquidations.reduce((acc, alert) => {
                                const severityMap = { 'LOW': 25, 'MEDIUM': 50, 'HIGH': 75, 'CRITICAL': 100 };
                                return acc + (severityMap[alert.severity] || 50);
                            }, 0) / assetLiquidations.length;
                            
                            signalInfo = {
                                confidence: avgSeverity,
                                direction: avgSeverity > 60 ? 'bearish' : 'neutral',
                                strength: avgSeverity > 75 ? 'strong' : avgSeverity > 50 ? 'medium' : 'weak'
                            };
                        }
                    } else if (signalType === 'alpha' && alphaDataFetched && alphaDataFetched.scan_results) {
                        // Use alpha scanner API data for dedicated alpha column
                        const assetAlpha = alphaDataFetched.scan_results.find(result => result.symbol === asset);
                        if (assetAlpha) {
                            const alphaScore = assetAlpha.confluence_score * 100;
                            signalInfo = {
                                confidence: alphaScore,
                                direction: alphaScore > 65 ? 'bullish' : alphaScore < 35 ? 'bearish' : 'neutral',
                                strength: alphaScore > 80 ? 'strong' : alphaScore > 60 ? 'medium' : 'weak'
                            };
                        }
                    } else if (signalType === 'manipulation') {
                        // Use manipulation detection data if available
                        if (manipulationDataFetched && manipulationDataFetched.alerts) {
                            const assetManipulation = manipulationDataFetched.alerts.filter(alert => 
                                alert.symbol === asset
                            );
                            
                            if (assetManipulation.length > 0) {
                                const avgConfidence = assetManipulation.reduce((acc, alert) => {
                                    return acc + (alert.confidence_score * 100);
                                }, 0) / assetManipulation.length;
                                
                                signalInfo = {
                                    confidence: avgConfidence,
                                    direction: avgConfidence > 70 ? 'bearish' : 'neutral', // High manipulation risk is bearish
                                    strength: avgConfidence > 80 ? 'strong' : avgConfidence > 60 ? 'medium' : 'weak'
                                };
                            }
                        } else {
                            // Fallback: Calculate manipulation risk from volume and volatility patterns
                            const volumeScore = signalData.confluence_signals?.volume?.confidence || 50;
                            const technicalScore = signalData.confluence_signals?.technical?.confidence || 50;
                            
                            // Higher manipulation risk with extreme volume + technical divergence
                            const manipulationRisk = Math.min(100, Math.abs(volumeScore - technicalScore) + (volumeScore > 80 ? 20 : 0));
                            
                            signalInfo = {
                                confidence: manipulationRisk,
                                direction: manipulationRisk > 70 ? 'bearish' : 'neutral',
                                strength: manipulationRisk > 80 ? 'strong' : manipulationRisk > 60 ? 'medium' : 'weak'
                            };
                        }
                    } else if ((signalType === 'momentum' || signalType === 'betaExp') && alphaDataFetched && alphaDataFetched.scan_results) {
                        // Use alpha scanner API data for momentum and beta signals (existing logic)
                        const assetAlpha = alphaDataFetched.scan_results.find(result => result.symbol === asset);
                        if (assetAlpha) {
                            const alphaScore = assetAlpha.confluence_score * 100;
                            signalInfo = {
                                confidence: alphaScore,
                                direction: alphaScore > 60 ? 'bullish' : alphaScore < 40 ? 'bearish' : 'neutral',
                                strength: alphaScore > 75 ? 'strong' : alphaScore > 50 ? 'medium' : 'weak'
                            };
                        }
                    } else if (signalData.confluence_signals && signalData.confluence_signals[signalType]) {
                        // Use general dashboard API data
                        const realSignal = signalData.confluence_signals[signalType];
                        signalInfo = {
                            confidence: realSignal.confidence || 0,
                            direction: realSignal.direction || 'neutral',
                            strength: realSignal.strength || 'weak'
                        };
                    } else if (signalType === 'trend') {
                        // Multi-timeframe trend analysis
                        if (correlationData && correlationData.timeframe_analysis) {
                            const timeframes = correlationData.timeframe_analysis;
                            let trendScore = 50.0;
                            let trendCount = 0;
                            
                            // Analyze trend across timeframes
                            for (const [tf, data] of Object.entries(timeframes)) {
                                if (data && data.trend_direction) {
                                    const direction = data.trend_direction.toLowerCase();
                                    if (direction === 'bullish' || direction === 'up') {
                                        trendScore += 15;
                                    } else if (direction === 'bearish' || direction === 'down') {
                                        trendScore -= 15;
                                    }
                                    trendCount++;
                                }
                            }
                            
                            // Normalize based on timeframe count
                            if (trendCount > 0) {
                                trendScore = Math.max(0, Math.min(100, trendScore));
                                signalInfo = {
                                    confidence: trendScore,
                                    direction: trendScore > 60 ? 'bullish' : trendScore < 40 ? 'bearish' : 'neutral',
                                    strength: trendScore > 75 ? 'strong' : trendScore > 50 ? 'medium' : 'weak'
                                };
                            }
                        }
                        
                        // Fallback to alpha data if correlation data unavailable
                        if (!signalInfo && alphaDataFetched && alphaDataFetched.scan_results) {
                            const assetAlpha = alphaDataFetched.scan_results.find(result => result.symbol === asset);
                            if (assetAlpha && assetAlpha.trend_analysis) {
                                const trendStrength = assetAlpha.trend_analysis.strength || 50;
                                signalInfo = {
                                    confidence: trendStrength,
                                    direction: trendStrength > 60 ? 'bullish' : trendStrength < 40 ? 'bearish' : 'neutral',
                                    strength: trendStrength > 75 ? 'strong' : trendStrength > 50 ? 'medium' : 'weak'
                                };
                            }
                        }
                    }
                    
                    data[asset][signalType] = signalInfo;
                    
                    // Calculate weighted contribution to composite score
                    const weight = signalWeights[signalType] || 0.05;
                    const confidence = signalInfo.confidence || 0;
                    
                    let scoreContribution = 0;
                    if (signalInfo.direction === 'bullish') {
                        scoreContribution = confidence * weight;
                    } else if (signalInfo.direction === 'bearish') {
                        scoreContribution = (100 - confidence) * weight;
                    } else {
                        scoreContribution = 50 * weight; // neutral
                    }
                    
                    totalScore += scoreContribution;
                    totalWeight += weight;
                });
                
                // Use real composite score if available, otherwise calculate from signals
                if (signalData.confluence_score !== undefined) {
                    data[asset].compositeScore = Math.round(signalData.confluence_score);
                } else if (totalWeight > 0) {
                    data[asset].compositeScore = Math.round(totalScore / totalWeight);
                } else {
                    data[asset].compositeScore = 0;
                }
            });
            
            return data;
        }

        // Get signal class based on direction and strength
        function getSignalClass(signal) {
            // Always return a colored class - no neutrals
            return `signal-${signal.strength}-${signal.direction}`;
        }

        // Get signal icon based on direction
        function getSignalIcon(signal) {
            switch(signal.direction) {
                case 'bullish': return '';
                case 'bearish': return '';
                default: return '';
            }
        }

        // Get composite score class
        function getCompositeScoreClass(score) {
            if (score >= 85) return 'score-excellent';
            if (score >= 75) return 'score-good';
            if (score >= 60) return 'score-fair';
            if (score >= 45) return 'score-poor';
            return 'score-avoid';
        }

        // Create composite score cell
        function createCompositeScoreCell(asset, compositeScore) {
            const cell = document.createElement('div');
            cell.className = `matrix-cell composite-score-cell ${getCompositeScoreClass(compositeScore)}`;
            
            const value = document.createElement('div');
            value.className = 'composite-score-value';
            value.textContent = compositeScore;
            
            const label = document.createElement('div');
            label.className = 'composite-score-label';
            if (compositeScore >= 85) label.textContent = 'EXCELLENT';
            else if (compositeScore >= 75) label.textContent = 'GOOD';
            else if (compositeScore >= 60) label.textContent = 'FAIR';
            else if (compositeScore >= 45) label.textContent = 'POOR';
            else label.textContent = 'AVOID';
            
            cell.appendChild(value);
            cell.appendChild(label);
            
            return cell;
        }

        // Create matrix cell
        function createMatrixCell(asset, signalType, signalData) {
            const cell = document.createElement('div');
            cell.className = `matrix-cell ${getSignalClass(signalData)}`;
            
            const icon = document.createElement('div');
            icon.className = 'signal-icon';
            icon.textContent = getSignalIcon(signalData);
            
            const confidence = document.createElement('div');
            confidence.className = 'signal-confidence';
            confidence.textContent = `${signalData.confidence.toFixed(0)}%`;
            
            cell.appendChild(icon);
            cell.appendChild(confidence);
            
            // Add hover tooltip
            cell.addEventListener('mouseenter', (e) => showTooltip(e, asset, signalType, signalData));
            cell.addEventListener('mouseleave', hideTooltip);
            
            return cell;
        }

        // Show tooltip
        function showTooltip(event, asset, signalType, signalData) {
            const tooltip = document.getElementById('matrixTooltip');
            const title = document.getElementById('tooltipTitle');
            const details = document.getElementById('tooltipDetails');
            
            title.textContent = `${asset} - ${signalType.toUpperCase()}`;
            
            details.innerHTML = `
                <span>Direction:</span><span>${signalData.direction.toUpperCase()}</span>
                <span>Confidence:</span><span>${signalData.confidence.toFixed(1)}%</span>
                <span>Strength:</span><span>${signalData.strength.toUpperCase()}</span>
                <span>Signal Type:</span><span>${signalType.replace(/([A-Z])/g, ' $1').toUpperCase()}</span>
            `;
            
            tooltip.style.display = 'block';
            tooltip.style.left = event.pageX + 10 + 'px';
            tooltip.style.top = event.pageY - 50 + 'px';
        }

        // Hide tooltip
        function hideTooltip() {
            document.getElementById('matrixTooltip').style.display = 'none';
        }

        // Create opportunity item for top opportunities panel
        function createOpportunityItem(asset, data, rank) {
            const item = document.createElement('div');
            item.className = 'opportunity-item';
            
            const scoreClass = getCompositeScoreClass(data.compositeScore);
            
            item.innerHTML = `
                <div class="opportunity-header">
                    <span class="opportunity-symbol">#${rank} ${asset}</span>
                    <span class="opportunity-score ${scoreClass}">${data.compositeScore}</span>
                </div>
                <div class="opportunity-metrics">
                    <div class="opportunity-metric">
                        <div class="metric-value">${(Math.random() * 15 + 5).toFixed(1)}%</div>
                        <div class="metric-label">Expected Return</div>
                    </div>
                    <div class="opportunity-metric">
                        <div class="metric-value">${(Math.random() * 5 + 1).toFixed(1)}%</div>
                        <div class="metric-label">Risk Level</div>
                    </div>
                    <div class="opportunity-metric">
                        <div class="metric-value">${(Math.random() * 10 + 2).toFixed(1)}K</div>
                        <div class="metric-label">Max Position</div>
                    </div>
                    <div class="opportunity-metric">
                        <div class="metric-value">${(Math.random() * 0.5 + 2.0).toFixed(1)}x</div>
                        <div class="metric-label">Risk/Reward</div>
                    </div>
                </div>
                <div class="opportunity-actions">
                    <button class="action-btn btn-trade" onclick="executeTrade('${asset}')">TRADE</button>
                    <button class="action-btn btn-analyze" onclick="analyzeAsset('${asset}')">ANALYZE</button>
                </div>
            `;
            
            return item;
        }

        // Populate top opportunities with real data only
        async function populateTopOpportunities(signalData) {
            const container = document.getElementById('opportunitiesContainer');
            container.innerHTML = '';
            
            if (!signalData || Object.keys(signalData).length === 0) {
                container.innerHTML = '<div class="no-data-message">Real signal data required</div>';
                return;
            }
            
            // Get available assets and sort by composite score
            const availableAssets = Object.keys(signalData);
            const sortedAssets = availableAssets
                .map(asset => ({ 
                    asset, 
                    score: signalData[asset].compositeScore,
                    momentum: signalData[asset].momentum,
                    volume: signalData[asset].volume,
                    whaleActivity: signalData[asset].whaleAct
                }))
                .sort((a, b) => b.score - a.score)
                .slice(0, 5); // Top 5 opportunities
            
            sortedAssets.forEach((item, index) => {
                const opportunityItem = createOpportunityItem(item.asset, signalData[item.asset], index + 1);
                container.appendChild(opportunityItem);
            });
        }

        // Update Alpha targets with real alpha API data
        async function updateAlphaTargets(signalData) {
            const alphaContainer = document.querySelector('.alpha-panel').children[1];
            
            // Use real alpha API data if available
            if (alphaData && alphaData.opportunities && alphaData.opportunities.length > 0) {
                console.log('[ALPHA] Using real alpha API data');
                
                const alphaOpportunities = alphaData.opportunities
                    .sort((a, b) => b.confluence_score - a.confluence_score)
                    .slice(0, 4);
                
                alphaContainer.innerHTML = alphaOpportunities.map((opportunity, index) => {
                    const expectedReturn = (opportunity.expected_return * 100).toFixed(1);
                    const confidenceScore = (opportunity.confluence_score * 100).toFixed(1);
                    
                    return `
                        <div class="alpha-item">
                            <div class="alpha-symbol">${opportunity.symbol}</div>
                            <div class="alpha-pattern">${opportunity.pattern_type || 'ALPHA_CONFLUENCE'}</div>
                            <div class="alpha-stats">
                                <span class="alpha-confidence">${confidenceScore}%</span>
                                <span class="alpha-target">+${expectedReturn}%</span>
                            </div>
                        </div>
                    `;
                }).join('');
                
                document.querySelector('.alpha-panel .panel-count').textContent = `${alphaOpportunities.length} IDENTIFIED`;
                return;
            }
            
            // Fallback to dashboard signal data
            if (!signalData || Object.keys(signalData).length === 0) {
                alphaContainer.innerHTML = '<div class="no-data-message">Real alpha data required</div>';
                document.querySelector('.alpha-panel .panel-count').textContent = '0 IDENTIFIED';
                return;
            }
            
            // Get available assets and find top alpha opportunities based on specific criteria
            const availableAssets = Object.keys(signalData);
            const alphaOpportunities = availableAssets
                .map(asset => ({
                    asset,
                    score: signalData[asset].compositeScore,
                    momentum: signalData[asset].momentum.confidence,
                    whaleActivity: signalData[asset].whaleAct.confidence,
                    volume: signalData[asset].volume.confidence,
                    
                    // Calculate alpha score from real data
                    alphaScore: (
                        signalData[asset].momentum.confidence * 0.3 +
                        signalData[asset].whaleAct.confidence * 0.25 +
                        signalData[asset].volume.confidence * 0.2 +
                        signalData[asset].technical.confidence * 0.15 +
                        signalData[asset].orderflow.confidence * 0.1
                    )
                }))
                .filter(item => item.alphaScore > 30) // Lower threshold for real data
                .sort((a, b) => b.alphaScore - a.alphaScore)
                .slice(0, 4);

            if (alphaOpportunities.length > 0) {
                const patterns = ['MOMENTUM_BREAKOUT', 'SUPPORT_BOUNCE', 'WHALE_ACTIVITY', 'VOLUME_SURGE', 'CONFLUENCE_ALIGN'];
                
                alphaContainer.innerHTML = alphaOpportunities.map((item, index) => {
                    // Calculate expected return based on actual confidence levels
                    const expectedReturn = (item.alphaScore / 100 * 15).toFixed(1);
                    return `
                        <div class="alpha-item">
                            <div class="alpha-symbol">${item.asset}</div>
                            <div class="alpha-pattern">${patterns[index] || 'CONFLUENCE_SIGNAL'}</div>
                            <div class="alpha-stats">
                                <span class="alpha-confidence">${item.alphaScore.toFixed(1)}%</span>
                                <span class="alpha-target">+${expectedReturn}%</span>
                            </div>
                        </div>
                    `;
                }).join('');
                
                // Update panel count
                document.querySelector('.alpha-panel .panel-count').textContent = `${alphaOpportunities.length} IDENTIFIED`;
            } else {
                alphaContainer.innerHTML = '<div class="no-data-message">No alpha opportunities above threshold</div>';
                document.querySelector('.alpha-panel .panel-count').textContent = '0 IDENTIFIED';
            }
        }

        // Update Live Signals panel with liquidation alerts and alpha signals
        async function updateLiveSignals() {
            const signalsContainer = document.getElementById('signalsContainer');
            let signals = [];
            
            // Add liquidation alerts
            if (liquidationData && liquidationData.alerts) {
                liquidationData.alerts.slice(0, 3).forEach(alert => {
                    signals.push({
                        symbol: alert.symbol,
                        type: 'liquidation',
                        action: alert.severity === 'CRITICAL' ? 'AVOID' : 'WATCH',
                        confidence: alert.cascade_probability ? (alert.cascade_probability * 100).toFixed(0) : '75',
                        details: `${alert.severity} liquidation risk`,
                        priority: alert.severity === 'CRITICAL' ? 1 : alert.severity === 'HIGH' ? 2 : 3
                    });
                });
            }
            
            // Add alpha signals
            if (alphaData && alphaData.opportunities) {
                alphaData.opportunities.slice(0, 3).forEach(opportunity => {
                    signals.push({
                        symbol: opportunity.symbol,
                        type: 'alpha',
                        action: opportunity.confluence_score > 0.7 ? 'LONG' : 'WATCH',
                        confidence: (opportunity.confluence_score * 100).toFixed(0),
                        details: `Alpha: +${(opportunity.expected_return * 100).toFixed(1)}%`,
                        priority: opportunity.confluence_score > 0.8 ? 1 : 2
                    });
                });
            }
            
            // Add manipulation alerts
            if (manipulationData && manipulationData.alerts) {
                manipulationData.alerts.slice(0, 2).forEach(alert => {
                    signals.push({
                        symbol: alert.symbol,
                        type: 'manipulation',
                        action: alert.severity === 'critical' ? 'AVOID' : 'CAUTION',
                        confidence: (alert.confidence_score * 100).toFixed(0),
                        details: `${alert.manipulation_type} detected`,
                        priority: alert.severity === 'critical' ? 1 : alert.severity === 'high' ? 2 : 3
                    });
                });
            }
            
            // Sort by priority and display
            signals.sort((a, b) => a.priority - b.priority);
            
            if (signals.length > 0) {
                signalsContainer.innerHTML = signals.map(signal => {
                    const actionClass = signal.action === 'LONG' ? 'action-long' : 
                                       signal.action === 'AVOID' ? 'action-short' : 
                                       signal.action === 'CAUTION' ? 'action-caution' : 'action-watch';
                    
                    return `
                        <div class="signal-compact">
                            <div class="signal-compact-header">
                                <span class="signal-symbol">${signal.symbol}</span>
                                <span class="signal-action ${actionClass}">${signal.action}</span>
                            </div>
                            <div class="signal-details">
                                <span>${signal.details}</span>
                                <span>${signal.confidence}%</span>
                            </div>
                        </div>
                    `;
                }).join('');
                
                // Update panel count
                document.querySelector('.signals-panel .panel-count').textContent = `${signals.length} ACTIVE`;
            } else {
                signalsContainer.innerHTML = '<div class="no-data-message">No active signals</div>';
                document.querySelector('.signals-panel .panel-count').textContent = '0 ACTIVE';
            }
        }

        // Update performance metrics with comprehensive data
        async function updatePerformanceMetrics(signalData) {
            const performanceGrid = document.getElementById('performanceGrid');
            
            // Use system data if available
            let systemMetrics = { cpu_usage: 0, memory_usage: 0, uptime: '0h 0m' };
            if (systemData && systemData.performance) {
                systemMetrics = {
                    cpu_usage: systemData.performance.cpu_usage || 0,
                    memory_usage: systemData.performance.memory_usage || 0,
                    uptime: systemData.performance.uptime || '0h 0m'
                };
            }

            // Use trading data if available
            let tradingMetrics = { 
                total_positions: 0, 
                portfolio_value: 0,
                pnl: 0,
                win_rate: 0
            };
            if (tradingData) {
                if (tradingData.positions) {
                    tradingMetrics.total_positions = tradingData.positions.length;
                }
                if (tradingData.portfolio) {
                    tradingMetrics.portfolio_value = tradingData.portfolio.total_value || 0;
                    tradingMetrics.pnl = tradingData.portfolio.unrealized_pnl || 0;
                    tradingMetrics.win_rate = tradingData.portfolio.win_rate || 0;
                }
            }

            // Calculate signal metrics if available
            let signalMetrics = {
                avgConfidence: 0,
                availableAssets: 0,
                totalSignals: 0,
                strongSignalRate: 0
            };

            if (signalData && Object.keys(signalData).length > 0) {
                const availableAssets = Object.keys(signalData);
                const totalSignals = availableAssets.length * signalTypes.length;
                
                const avgConfidence = availableAssets.reduce((acc, asset) => {
                    const assetAvg = signalTypes.reduce((sum, signal) => sum + signalData[asset][signal].confidence, 0) / signalTypes.length;
                    return acc + assetAvg;
                }, 0) / availableAssets.length;
                
                const strongSignals = availableAssets.reduce((count, asset) => {
                    return count + signalTypes.filter(signal => signalData[asset][signal].strength === 'strong').length;
                }, 0);
                
                const strongSignalRate = totalSignals > 0 ? (strongSignals / totalSignals * 100).toFixed(1) : '0.0';
                
                signalMetrics = {
                    avgConfidence: avgConfidence.toFixed(1),
                    availableAssets: availableAssets.length,
                    totalSignals: totalSignals,
                    strongSignalRate: strongSignalRate
                };
            }

            // Get API latency (estimate or from system data)
            const latency = systemData?.performance?.api_latency || '12';

            performanceGrid.innerHTML = `
                <div class="perf-metric">
                    <div class="perf-value">${signalMetrics.avgConfidence}%</div>
                    <div class="perf-label">AVG CONFIDENCE</div>
                </div>
                <div class="perf-metric">
                    <div class="perf-value">${latency}ms</div>
                    <div class="perf-label">API LATENCY</div>
                </div>
                <div class="perf-metric">
                    <div class="perf-value">${signalMetrics.availableAssets}</div>
                    <div class="perf-label">ACTIVE ASSETS</div>
                </div>
                <div class="perf-metric">
                    <div class="perf-value">${tradingMetrics.total_positions}</div>
                    <div class="perf-label">OPEN POSITIONS</div>
                </div>
                <div class="perf-metric">
                    <div class="perf-value">${systemMetrics.cpu_usage.toFixed(1)}%</div>
                    <div class="perf-label">CPU USAGE</div>
                </div>
                <div class="perf-metric">
                    <div class="perf-value">${systemMetrics.memory_usage.toFixed(1)}%</div>
                    <div class="perf-label">MEMORY</div>
                </div>
                <div class="perf-metric">
                    <div class="perf-value">${tradingMetrics.win_rate.toFixed(1)}%</div>
                    <div class="perf-label">WIN RATE</div>
                </div>
                <div class="perf-metric">
                    <div class="perf-value">$${(tradingMetrics.portfolio_value / 1000).toFixed(1)}K</div>
                    <div class="perf-label">PORTFOLIO</div>
                </div>
                <div class="perf-metric">
                    <div class="perf-value">${tradingMetrics.pnl >= 0 ? '+' : ''}${(tradingMetrics.pnl / 1000).toFixed(1)}K</div>
                    <div class="perf-label">UNREALIZED PNL</div>
                </div>
            `;
        }

        // Populate matrix with real data only
        async function populateMatrix() {
            const matrixGrid = document.getElementById('signalMatrix');
            const signalData = await generateSignalData();
            
            // Clear existing content
            matrixGrid.innerHTML = '';
            
            // Handle case where no real data is available
            if (!signalData || Object.keys(signalData).length === 0) {
                matrixGrid.innerHTML = `
                    <div class="matrix-no-data">
                        <div class="no-data-icon"></div>
                        <div class="no-data-title">NO REAL SIGNAL DATA AVAILABLE</div>
                        <div class="no-data-message">
                            Dashboard requires live trading system integration.<br/>
                            Start the integrated trading server to access real-time signals.
                        </div>
                        <div class="no-data-actions">
                            <button onclick="window.location.reload()" class="retry-btn">RETRY CONNECTION</button>
                        </div>
                    </div>
                `;
                
                // Clear other components
                document.getElementById('opportunitiesContainer').innerHTML = '<div class="no-data-message">Real data required</div>';
                document.querySelector('.alpha-panel').children[1].innerHTML = '<div class="no-data-message">Real data required</div>';
                document.getElementById('performanceGrid').innerHTML = '<div class="no-data-message">Real data required</div>';
                
                return;
            }
            
            // Get available assets from real data
            const availableAssets = Object.keys(signalData);
            
            // Sort assets by composite score for better visual hierarchy
            const sortedAssets = availableAssets
                .map(asset => ({ asset, score: signalData[asset].compositeScore }))
                .sort((a, b) => b.score - a.score);
            
            sortedAssets.forEach(item => {
                const asset = item.asset;
                
                // Asset row header
                const rowHeader = document.createElement('div');
                rowHeader.className = 'matrix-row-header';
                rowHeader.textContent = asset;
                matrixGrid.appendChild(rowHeader);
                
                // Composite score cell
                const scoreCell = createCompositeScoreCell(asset, signalData[asset].compositeScore);
                matrixGrid.appendChild(scoreCell);
                
                // Signal cells for this asset
                signalTypes.forEach(signalType => {
                    const cell = createMatrixCell(asset, signalType, signalData[asset][signalType]);
                    matrixGrid.appendChild(cell);
                });
            });
            
            // Fetch all API data in parallel
            const [systemFetched, tradingFetched, marketFetched, signalsFetched] = await Promise.all([
                fetchSystemData(),
                fetchTradingData(), 
                fetchMarketData(),
                fetchSignalsData()
            ]);

            // Store the fetched data
            systemData = systemFetched;
            tradingData = tradingFetched;
            marketData = marketFetched;
            signalsData = signalsFetched;

            // Update all dashboard components with integrated data
            await updateLiveSignals();
            await populateTopOpportunities(signalData);
            await updateAlphaTargets(signalData);
            await updatePerformanceMetrics(signalData);
        }

        // Market Analysis Interpretation Functions
        function interpretTechnical(score, components) {
            if (score > 65) {
                if (score > 80) {
                    return "Extremely strong bullish technical setup with multiple indicators aligned. RSI in healthy uptrend territory while momentum oscillators show sustained buying pressure. Moving averages displaying bullish convergence with breakout above key resistance levels.";
                } else {
                    return "Strong bullish technical indicators with trend momentum building. Technical analysis shows consistent higher highs and higher lows formation with volume confirmation supporting the upward trajectory.";
                }
            } else if (score < 35) {
                if (score < 20) {
                    return "Extremely bearish technical configuration with multiple downside confirmations. Oscillators showing oversold conditions while trend indicators signal continued weakness. Moving averages in bearish alignment with breakdown below support.";
                } else {
                    return "Bearish technical setup with trend momentum deteriorating. Key support levels under pressure while momentum indicators show selling pressure building across multiple timeframes.";
                }
            } else {
                return "Neutral technical conditions with mixed signals from oscillators and trend indicators. Market appears to be in consolidation phase awaiting directional catalyst for next move.";
            }
        }

        function interpretVolume(score, components) {
            if (score > 65) {
                return "Strong volume confirmation supporting current price action. Above-average participation rates indicate institutional involvement with significant buying interest. Volume profile shows accumulation at higher price levels.";
            } else if (score < 35) {
                return "Declining volume participation suggests waning conviction in current price movement. Volume profile indicates distribution pressure with sellers becoming more active at these levels.";
            } else {
                return "Moderate volume levels showing balanced participation between buyers and sellers. Volume patterns suggest consolidation phase with potential for volatility expansion.";
            }
        }

        function interpretOrderflow(score, components) {
            if (score > 65) {
                return "Dominant buying pressure evident in orderflow with large trades executed predominantly on the bid side. Cumulative volume delta showing positive momentum with institutional-sized orders providing support.";
            } else if (score < 35) {
                return "Selling pressure dominating orderflow with aggressive selling into bids. Large trade analysis suggests institutional distribution with negative cumulative volume delta indicating sustained outflows.";
            } else {
                return "Balanced orderflow conditions with equal buying and selling pressure. Trade flow analysis shows neutral institutional positioning with no clear directional bias from large participants.";
            }
        }

        function interpretSentiment(score, components) {
            if (score > 65) {
                return "Bullish market sentiment with positive risk appetite evident across market participants. Funding rates showing willingness to pay premiums for long exposure while trader positioning remains constructive.";
            } else if (score < 35) {
                return "Bearish sentiment dominating with risk-off positioning prevalent. Negative funding rates indicating short bias while trader sentiment surveys showing pessimistic outlook for near-term price action.";
            } else {
                return "Neutral market sentiment with balanced risk appetite. Funding rates near equilibrium while trader positioning shows no strong directional bias suggesting wait-and-see approach.";
            }
        }

        function generateTradingRecommendation(overallScore, signalData) {
            if (overallScore > 70) {
                return "Strong bullish confluence suggests long-biased strategies. Consider breakout entries above resistance levels with defined risk management. Target key profit zones while maintaining trailing stops to capture momentum moves.";
            } else if (overallScore < 30) {
                return "Bearish confluence indicates short-biased strategies. Look for breakdown entries below support with tight risk controls. Focus on momentum continuation while avoiding oversold bounces.";
            } else if (overallScore > 55) {
                return "Slight bullish bias present but wait for stronger confirmation. Consider small long positions on pullbacks to support with conservative position sizing. Monitor for trend acceleration signals.";
            } else if (overallScore < 45) {
                return "Weak bearish bias suggests caution on long positions. Consider defensive strategies or wait for clearer directional signals. Range-bound trading may be most appropriate until trend emerges.";
            } else {
                return "Neutral market conditions suggest range-bound strategies. Focus on mean-reversion trades at support/resistance levels. Avoid trend-following until clear directional break emerges.";
            }
        }



        // Update matrix periodically



        function updateMatrix() {
            if (Math.random() > 0.8) {
                populateMatrix();
            }
        }

        // Update scrolling ticker with real symbols and price changes
        function updateSymbolTicker(symbols = []) {
            console.log('[DEBUG] updateSymbolTicker called with:', symbols);
            const tickerContent = document.getElementById('symbolTicker');
            console.log('[DEBUG] Ticker element found:', !!tickerContent);
            
            if (!symbols || symbols.length === 0) {
                console.log('[DEBUG] No symbols provided, showing loading message');
                tickerContent.innerHTML = '<div class="ticker-loading">LOADING SYMBOLS</div>';
                return;
            }
            
            // Create ticker items for each symbol with price change
            const tickerItems = symbols.map(item => {
                const symbol = typeof item === 'string' ? item : item.symbol;
                const change = typeof item === 'string' ? 0 : (item.change_24h || 0);
                const changeStr = change >= 0 ? `+${change.toFixed(2)}%` : `${change.toFixed(2)}%`;
                const changeClass = change > 0 ? 'price-positive' : change < 0 ? 'price-negative' : 'price-neutral';
                
                return `<div class="ticker-item" onclick="focusSymbol('${symbol}')">
                    <span class="ticker-symbol">${symbol}</span>
                    <span class="ticker-change ${changeClass}">${changeStr}</span>
                </div>`;
            }).join('');
            
            console.log('[DEBUG] Generated ticker HTML length:', tickerItems.length);
            
            // Duplicate the items to create seamless scrolling
            tickerContent.innerHTML = tickerItems + tickerItems;
            
            console.log(`[TICKER] Updated with ${symbols.length} symbols`);
        }
        
        // Focus on a specific symbol in the matrix
        function focusSymbol(symbol) {
            console.log(`[TICKER] Focusing on symbol: ${symbol}`);
            
            // Find the symbol row in the matrix and highlight it
            const matrixRows = document.querySelectorAll('.matrix-row-header');
            matrixRows.forEach(row => {
                if (row.textContent === symbol) {
                    // Remove previous highlights
                    document.querySelectorAll('.matrix-row-focused').forEach(el => {
                        el.classList.remove('matrix-row-focused');
                    });
                    
                    // Add highlight to this row and its cells
                    row.classList.add('matrix-row-focused');
                    let nextSibling = row.nextElementSibling;
                    for (let i = 0; i < 13 && nextSibling; i++) { // 12 signal types + 1 composite score
                        nextSibling.classList.add('matrix-row-focused');
                        nextSibling = nextSibling.nextElementSibling;
                    }
                    
                    // Scroll to the row
                    row.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            });
        }

        // Enhanced hover effects
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('[SYSTEM] Initializing Virtuoso Terminal with real data only...');
            
            // Initialize Lucide icons
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
                console.log('[SYSTEM] Lucide icons initialized');
            }
            
            // Initialize ticker
            console.log('[DEBUG] Initializing ticker...');
            updateSymbolTicker();
            
            // Initialize matrix with real data
            console.log('[DEBUG] Initializing matrix...');
            await populateMatrix();
            
            // Initialize signal tracking
            console.log('[DEBUG] Initializing signal tracking...');
            await updateSignalTracking();
            
            // Add event listeners for signal tracking controls
            document.getElementById('autoTrackToggle').addEventListener('click', toggleAutoTrack);
            document.getElementById('signalTypeFilter').addEventListener('change', changeSignalFilter);
            
            // Initialize WebSocket connection
            console.log('[DEBUG] Initializing WebSocket...');
            initializeWebSocket();
            
            // Update matrix every 30 seconds (only if we have real data)
            setInterval(async () => {
                console.log('[DEBUG] Periodic update - realTimeAssets length:', realTimeAssets.length);
                if (realTimeAssets.length > 0) {
                    await populateMatrix();
                    updateSymbolTicker(realTimeAssets); // Keep ticker updated
                } else {
                    console.warn('[SYSTEM] No real symbols available - skipping update');
                }
            }, 30000);
            
            // Update signal tracking every 10 seconds
            setInterval(async () => {
                await updateSignalTracking();
            }, 10000);
            
            // Enhanced hover effects for other elements
            document.querySelectorAll('.signal-compact, .alpha-item, .perf-metric').forEach(item => {
                item.addEventListener('mouseenter', function() {
                    this.style.filter = 'brightness(1.1)';
                    this.style.boxShadow = '0 8px 25px rgba(255, 153, 0, 0.4)';
                });
                
                item.addEventListener('mouseleave', function() {
                    this.style.filter = '';
                    this.style.boxShadow = '';
                });
            });

            console.log(`
[SYSTEM] ========================================================
[SYSTEM] VIRTUOSO TERMINAL SIGNAL CONFLUENCE v10.0 READY
[SYSTEM] COMPREHENSIVE API INTEGRATION + SIGNAL TRACKING ACTIVE
[SYSTEM] ========================================================
[SYSTEM]  LIQUIDATION INTELLIGENCE API INTEGRATED
[SYSTEM]  ALPHA SCANNER API INTEGRATED  
[SYSTEM]  MANIPULATION DETECTION API INTEGRATED
[SYSTEM]  SYSTEM MONITORING API INTEGRATED
[SYSTEM]  TRADING & PORTFOLIO API INTEGRATED
[SYSTEM]  MARKET ANALYSIS API INTEGRATED
[SYSTEM]  SIGNALS & ALERTS API INTEGRATED
[SYSTEM]  WEBSOCKET REAL-TIME UPDATES ACTIVE
[SYSTEM]  LIVE SIGNALS PANEL (MULTI-SOURCE)
[SYSTEM]  ALPHA TARGETS (REAL API DATA)
[SYSTEM]  SIGNAL MATRIX: 80% CONFLUENCE + 20% DIRECT
[SYSTEM]  TREND ANALYSIS (MULTI-TIMEFRAME)
[SYSTEM]  WEIGHT NORMALIZATION (CONFIG-BASED)
[SYSTEM]  SIGNAL TRACKING PANEL ACTIVE
[SYSTEM]  REAL-TIME P&L MONITORING
[SYSTEM]  AUTO-TRACKING: BUY/SELL SIGNALS
[SYSTEM]  CONFLUENCE ANALYSIS INTEGRATION
[SYSTEM] ========================================================
[SYSTEM] CONFLUENCE WEIGHTS: Technical(13.6%) | Orderflow(20.0%) | Volume(9.6%)
[SYSTEM] CONFLUENCE WEIGHTS: Orderbook(16.0%) | PriceStruct(12.0%) | Sentiment(8.0%)
[SYSTEM] DIRECT SIGNALS: Alpha(8.0%) | Beta(4.0%) | Whale(6.0%) | Liq(3.0%) | Manip(3.0%)
[SYSTEM] TREND ANALYSIS: Multi-timeframe(0.8%) - Overall trend direction
[SYSTEM] SIGNAL TRACKING: Auto-enabled | 10s updates | Real-time P&L
[SYSTEM] ========================================================`);
        });

        // WebSocket Management
        function initializeWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.hostname}:${window.location.port}/api/dashboard/ws`;
            
            try {
                dashboardWebSocket = new WebSocket(wsUrl);
                
                dashboardWebSocket.onopen = function() {
                    console.log('[WEBSOCKET] Connected to dashboard WebSocket');
                    wsReconnectAttempts = 0;
                    updateConnectionStatus('online');
                };
                
                dashboardWebSocket.onmessage = function(event) {
                    try {
                        const data = JSON.parse(event.data);
                        handleWebSocketMessage(data);
                    } catch (error) {
                        console.error('[WEBSOCKET] Error parsing message:', error);
                    }
                };
                
                dashboardWebSocket.onclose = function() {
                    console.log('[WEBSOCKET] Connection closed');
                    updateConnectionStatus('error');
                    attemptReconnect();
                };
                
                dashboardWebSocket.onerror = function(error) {
                    console.error('[WEBSOCKET] Error:', error);
                    updateConnectionStatus('error');
                };
                
            } catch (error) {
                console.error('[WEBSOCKET] Failed to initialize:', error);
                updateConnectionStatus('error');
            }
        }

        function handleWebSocketMessage(data) {
            console.log('[WEBSOCKET] Received update:', data.type);
            
            switch(data.type) {
                case 'dashboard_update':
                    // Update dashboard with real-time data
                    if (data.data) {
                        dashboardData = data.data;
                        updateDashboardComponents();
                    }
                    break;
                case 'liquidation_alert':
                    // Handle real-time liquidation alerts
                    if (data.alert) {
                        handleLiquidationAlert(data.alert);
                    }
                    break;
                case 'alpha_opportunity':
                    // Handle new alpha opportunities
                    if (data.opportunity) {
                        handleAlphaOpportunity(data.opportunity);
                    }
                    break;
                case 'trading_signal':
                    // Handle new trading signals from confluence analysis
                    if (data.signal) {
                        handleNewSignal(data.signal);
                    }
                    break;
                case 'signal_update':
                    // Handle signal status updates (closed, modified, etc.)
                    if (data.signal) {
                        updateSignalTracking();
                    }
                    break;
                case 'system_status':
                    // Handle system status updates
                    if (data.status) {
                        systemData = { ...systemData, status: data.status };
                        updateSystemStatus();
                    }
                    break;
                default:
                    console.warn('[WEBSOCKET] Unknown message type:', data.type);
            }
        }

        function handleLiquidationAlert(alert) {
            console.log('[LIQUIDATION ALERT]', alert);
            // Add to liquidation data and refresh displays
            if (!liquidationData) liquidationData = { alerts: [] };
            liquidationData.alerts.unshift(alert);
            updateLiveSignals();
        }

        function handleAlphaOpportunity(opportunity) {
            console.log('[ALPHA OPPORTUNITY]', opportunity);
            // Add to alpha data and refresh displays  
            if (!alphaData) alphaData = { opportunities: [] };
            alphaData.opportunities.unshift(opportunity);
            updateAlphaTargets();
        }

        function updateSystemStatus() {
            // Update system status indicators in the UI
            if (systemData && systemData.status) {
                const statusIndicator = document.querySelector('.status-light');
                if (statusIndicator && systemData.status.status === 'online') {
                    statusIndicator.style.background = 'var(--accent-positive)';
                } else if (statusIndicator) {
                    statusIndicator.style.background = 'var(--accent-negative)';
                }
            }
        }

        function attemptReconnect() {
            if (wsReconnectAttempts < maxReconnectAttempts) {
                wsReconnectAttempts++;
                console.log(`[WEBSOCKET] Attempting reconnect ${wsReconnectAttempts}/${maxReconnectAttempts}`);
                setTimeout(() => {
                    initializeWebSocket();
                }, 2000 * wsReconnectAttempts); // Exponential backoff
            } else {
                console.error('[WEBSOCKET] Max reconnection attempts reached');
                updateConnectionStatus('disconnected');
            }
        }

        function updateConnectionStatus(status) {
            const statusLight = document.querySelector('.status-light');
            const statusText = document.querySelector('.status-text');
            
            if (statusLight && statusText) {
                switch(status) {
                    case 'online':
                        statusLight.style.background = 'var(--accent-positive)';
                        statusLight.style.boxShadow = '0 0 15px var(--accent-positive)';
                        statusText.textContent = 'LIVE';
                        break;
                    case 'error':
                        statusLight.style.background = 'var(--accent-warning)';
                        statusLight.style.boxShadow = '0 0 15px var(--accent-warning)';
                        statusText.textContent = 'RECONNECTING';
                        break;
                    case 'disconnected':
                        statusLight.style.background = 'var(--accent-negative)';
                        statusLight.style.boxShadow = '0 0 15px var(--accent-negative)';
                        statusText.textContent = 'OFFLINE';
                        break;
                }
            }
        }

        async function updateDashboardComponents() {
            // Refresh all dashboard components with latest data
            if (dashboardData && dashboardData.signals) {
                const signalData = await generateSignalData();
                if (signalData) {
                    await updateLiveSignals();
                    await populateTopOpportunities(signalData);
                    await updateAlphaTargets(signalData);
                    await updatePerformanceMetrics(signalData);
                }
            }
        }

        // Signal Tracking Management
        let activeSignals = new Map(); // Store active trading signals
        let autoTrackEnabled = true;
        let signalTypeFilter = 'all';

        // API endpoints for signal tracking
        async function fetchActiveSignals() {
            try {
                const data = await fetchWithFallback(`${API_BASE_URL}/api/signals/active`, {
                    signals: []
                });
                console.log('[SIGNAL TRACKING] Fetched active signals:', data);
                return data.signals || [];
            } catch (error) {
                console.error('[SIGNAL TRACKING] Error fetching active signals:', error);
                return [];
            }
        }

        // Get current price for P&L calculation
        async function getCurrentPrice(symbol) {
            try {
                // Validate symbol before making API call
                if (!symbol || typeof symbol !== 'string' || symbol.toUpperCase() === 'UNKNOWN' || 
                    ['NULL', 'UNDEFINED', 'NONE', '', 'INVALID', 'ERROR'].includes(symbol.toUpperCase())) {
                    console.warn(`[SIGNAL TRACKING] Skipping price fetch for invalid symbol: '${symbol}'`);
                    return 0;
                }
                
                const data = await fetchWithFallback(`${API_BASE_URL}/api/market/ticker/${symbol}`, {
                    last: 0,
                    price: 0
                });
                return data.last || data.price || 0;
            } catch (error) {
                console.error(`[SIGNAL TRACKING] Error fetching price for ${symbol}:`, error);
                return 0;
            }
        }

        // Calculate signal P&L and metrics
        function calculateSignalMetrics(signal, currentPrice) {
            const entryPrice = signal.entry_price || signal.price;
            const quantity = signal.quantity || 1;
            const signalType = signal.action || signal.signal_type;
            
            let pnl = 0;
            let pnlPercent = 0;
            
            if (entryPrice > 0 && currentPrice > 0) {
                if (signalType.toLowerCase() === 'buy' || signalType.toLowerCase() === 'long') {
                    pnl = (currentPrice - entryPrice) * quantity;
                    pnlPercent = ((currentPrice - entryPrice) / entryPrice) * 100;
                } else if (signalType.toLowerCase() === 'sell' || signalType.toLowerCase() === 'short') {
                    pnl = (entryPrice - currentPrice) * quantity;
                    pnlPercent = ((entryPrice - currentPrice) / entryPrice) * 100;
                }
            }
            
            // Calculate duration
            const entryTime = new Date(signal.timestamp || signal.created_at);
            const currentTime = new Date();
            const durationMs = currentTime - entryTime;
            const durationMins = Math.floor(durationMs / (1000 * 60));
            const durationHours = Math.floor(durationMins / 60);
            const remainingMins = durationMins % 60;
            
            const duration = durationHours > 0 
                ? `${durationHours}h ${remainingMins}m` 
                : `${durationMins}m`;
            
            return {
                pnl: pnl,
                pnlPercent: pnlPercent,
                duration: duration,
                entryPrice: entryPrice,
                currentPrice: currentPrice,
                isProfit: pnl > 0,
                durationMs: durationMs
            };
        }

        // Create tracked signal UI element
        function createTrackedSignalElement(signal, metrics) {
            const signalDiv = document.createElement('div');
            signalDiv.className = `tracked-signal ${metrics.isProfit ? 'profitable' : 'losing'}`;
            signalDiv.id = `signal-${signal.id || signal.symbol}-${signal.timestamp}`;
            
            const signalType = signal.action || signal.signal_type || 'UNKNOWN';
            const confidence = signal.confidence || signal.score || 0;
            
            signalDiv.innerHTML = `
                <div class="signal-header">
                    <span class="signal-symbol">${signal.symbol}</span>
                    <div style="display: flex; align-items: center; gap: 6px;">
                        <span class="signal-type ${signalType.toLowerCase()}">${signalType}</span>
                        <span class="signal-score ${getCompositeScoreClass(confidence)}">${confidence.toFixed(0)}%</span>
                    </div>
                </div>
                
                <div class="signal-pnl ${metrics.isProfit ? 'positive' : 'negative'}">
                    ${metrics.pnl >= 0 ? '+' : ''}$${metrics.pnl.toFixed(2)} (${metrics.pnlPercent >= 0 ? '+' : ''}${metrics.pnlPercent.toFixed(2)}%)
                </div>
                
                <div class="signal-metrics">
                    <div class="signal-metric">
                        <div class="metric-value">$${metrics.entryPrice.toFixed(4)}</div>
                        <div class="metric-label">Entry</div>
                    </div>
                    <div class="signal-metric">
                        <div class="metric-value">$${metrics.currentPrice.toFixed(4)}</div>
                        <div class="metric-label">Current</div>
                    </div>
                    <div class="signal-metric">
                        <div class="metric-value">${metrics.duration}</div>
                        <div class="metric-label">Duration</div>
                    </div>
                </div>
                
                <div class="signal-actions">
                    <button class="signal-action-btn btn-stop" onclick="stopTracking('${signal.id || signal.symbol}')">STOP</button>
                    <button class="signal-action-btn btn-details" onclick="viewSignalDetails('${signal.symbol}')">DETAILS</button>
                </div>
            `;
            
            return signalDiv;
        }

        // Update signal tracking panel
        async function updateSignalTracking() {
            const container = document.getElementById('trackedSignalsContainer');
            const countElement = document.getElementById('trackingCount');
            
            try {
                const signals = await fetchActiveSignals();
                const filteredSignals = filterSignalsByType(signals);
                
                // Filter out signals with invalid symbols
                const validSignals = filteredSignals.filter(signal => {
                    const symbol = signal.symbol;
                    if (!symbol || typeof symbol !== 'string' || symbol.toUpperCase() === 'UNKNOWN' || 
                        ['NULL', 'UNDEFINED', 'NONE', '', 'INVALID', 'ERROR'].includes(symbol.toUpperCase())) {
                        console.warn(`[SIGNAL TRACKING] Filtering out signal with invalid symbol: '${symbol}'`);
                        return false;
                    }
                    return true;
                });
                
                if (validSignals.length === 0) {
                    container.innerHTML = `
                        <div class="no-data-message" style="text-align: center; padding: 20px; color: var(--text-secondary);">
                            <div style="font-size: 1.5rem; margin-bottom: 8px;"></div>
                            <div>No active trading signals</div>
                            <div style="font-size: 9px; margin-top: 4px; opacity: 0.7;">
                                Signals will appear when confluence analysis generates buy/sell alerts
                            </div>
                        </div>
                    `;
                    countElement.textContent = '0 ACTIVE';
                    return;
                }
                
                // Update each signal with current market data
                const signalElements = await Promise.all(validSignals.map(async (signal) => {
                    const currentPrice = await getCurrentPrice(signal.symbol);
                    const metrics = calculateSignalMetrics(signal, currentPrice);
                    return createTrackedSignalElement(signal, metrics);
                }));
                
                // Clear and update container
                container.innerHTML = '';
                signalElements.forEach(element => container.appendChild(element));
                
                // Update count
                countElement.textContent = `${validSignals.length} ACTIVE`;
                
                // Store signals for reference
                activeSignals.clear();
                validSignals.forEach(signal => {
                    activeSignals.set(signal.id || signal.symbol, signal);
                });
                
                console.log(`[SIGNAL TRACKING] Updated ${validSignals.length} active signals`);
                
            } catch (error) {
                console.error('[SIGNAL TRACKING] Error updating signals:', error);
                container.innerHTML = '<div class="no-data-message">Error loading signals</div>';
                countElement.textContent = 'ERROR';
            }
        }

        // Filter signals by type
        function filterSignalsByType(signals) {
            if (signalTypeFilter === 'all') return signals;
            
            return signals.filter(signal => {
                const signalType = (signal.action || signal.signal_type || '').toLowerCase();
                if (signalTypeFilter === 'buy') {
                    return signalType === 'buy' || signalType === 'long';
                } else if (signalTypeFilter === 'sell') {
                    return signalType === 'sell' || signalType === 'short';
                }
                return true;
            });
        }

        // Handle new signal from WebSocket
        function handleNewSignal(signalData) {
            console.log('[SIGNAL TRACKING] New signal received:', signalData);
            
            if (autoTrackEnabled) {
                // Add to active signals and refresh display
                activeSignals.set(signalData.id || signalData.symbol, signalData);
                updateSignalTracking();
                
                // Show notification
                showSignalNotification(signalData);
            }
        }

        // Show signal notification
        function showSignalNotification(signal) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 80px;
                right: 20px;
                background: linear-gradient(135deg, var(--bg-hero), var(--bg-satellite));
                border: 1px solid var(--accent-positive);
                border-radius: 6px;
                padding: 12px 16px;
                color: var(--text-primary);
                font-family: 'JetBrains Mono', monospace;
                font-size: 11px;
                box-shadow: 0 8px 25px rgba(255, 193, 7, 0.3);
                z-index: 1000;
                animation: slideInRight 0.3s ease;
            `;
            
            const signalType = signal.action || signal.signal_type || 'SIGNAL';
            notification.innerHTML = `
                <div style="color: var(--accent-positive); font-weight: 700; margin-bottom: 4px;">
                     NEW ${signalType.toUpperCase()} SIGNAL
                </div>
                <div>${signal.symbol} - ${(signal.confidence || 0).toFixed(0)}% Confidence</div>
                <div style="font-size: 9px; color: var(--text-secondary); margin-top: 4px;">
                    Entry: $${(signal.entry_price || signal.price || 0).toFixed(4)}
                </div>
            `;
            
            document.body.appendChild(notification);
            
            // Auto-remove after 5 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.style.animation = 'slideOutRight 0.3s ease';
                    setTimeout(() => notification.remove(), 300);
                }
            }, 5000);
        }

        // Control functions
        function toggleAutoTrack() {
            autoTrackEnabled = !autoTrackEnabled;
            const toggle = document.getElementById('autoTrackToggle');
            
            if (autoTrackEnabled) {
                toggle.textContent = 'ENABLED';
                toggle.classList.add('active');
            } else {
                toggle.textContent = 'DISABLED';
                toggle.classList.remove('active');
            }
            
            console.log(`[SIGNAL TRACKING] Auto-tracking ${autoTrackEnabled ? 'enabled' : 'disabled'}`);
        }

        function changeSignalFilter() {
            const filter = document.getElementById('signalTypeFilter');
            signalTypeFilter = filter.value;
            updateSignalTracking();
            console.log(`[SIGNAL TRACKING] Filter changed to: ${signalTypeFilter}`);
        }

        function stopTracking(signalId) {
            console.log(`[SIGNAL TRACKING] Stopping tracking for signal: ${signalId}`);
            
            // Remove from active signals
            activeSignals.delete(signalId);
            
            // Refresh display
            updateSignalTracking();
            
            // Optionally, send API call to mark signal as closed
                            fetch(`${API_BASE_URL}/api/signal-tracking/tracked/${signalId}`, {
                method: 'DELETE'
            }).catch(err => console.error('Error stopping signal tracking:', err));
        }

        function viewSignalDetails(symbol) {
            console.log(`[SIGNAL TRACKING] Viewing details for: ${symbol}`);
            alert(`Signal Details for ${symbol}\n\nThis would open comprehensive signal analysis including:\n- Entry reasoning\n- Technical indicators used\n- Risk parameters\n- Exit conditions`);
        }

        // Trading action functions
        function executeTrade(asset) {
            console.log(`[TRADE] Executing trade for ${asset}`);
            alert(`Trade execution initiated for ${asset}\n\nThis would open your trading interface with pre-populated parameters.`);
        }

        function analyzeAsset(asset) {
            console.log(`[ANALYZE] Opening detailed analysis for ${asset}`);
            alert(`Opening detailed analysis for ${asset}\n\nThis would show comprehensive technical analysis, fundamentals, and risk metrics.`);
        }
    </script>
</body>
</html>