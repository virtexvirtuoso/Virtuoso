#!/usr/bin/env python3\n\"\"\"\nComprehensive test for orderflow indicator optimizations.\n\nThis script tests:\n1. CVD threshold alignment with OI sensitivity\n2. Intelligent debug logging and scenario tracking\n3. Performance summary generation\n4. All 5 OI scenarios + 4 CVD scenarios\n5. Cache hit tracking and performance metrics\n\"\"\"\n\nimport sys\nimport os\nimport asyncio\nimport logging\nimport time\nimport pandas as pd\nimport numpy as np\nfrom typing import Dict, Any\nfrom datetime import datetime, timezone, timedelta\n\n# Add project root to path\nproject_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..'))\nsys.path.insert(0, project_root)\n\nfrom src.indicators.orderflow_indicators import OrderflowIndicators\nfrom src.core.config.config_manager import ConfigManager\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.DEBUG,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\n\nclass CompleteOptimizationTest:\n    \"\"\"Test all orderflow optimizations together.\"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize the test.\"\"\"\n        self.config_manager = ConfigManager()\n        self.config = self.config_manager._config\n        \n    def create_comprehensive_test_data(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"Create test data covering all scenarios.\"\"\"\n        \n        # Base values\n        base_oi = 1000000\n        base_price = 2773.23\n        current_time = int(time.time() * 1000)\n        \n        # Create base OHLCV data\n        dates = pd.date_range(start='2024-01-01', periods=1000, freq='1min')\n        base_ohlcv_df = pd.DataFrame({\n            'open': np.random.normal(base_price, 10, 1000),\n            'high': np.random.normal(base_price + 5, 10, 1000),\n            'low': np.random.normal(base_price - 5, 10, 1000),\n            'close': np.random.normal(base_price, 10, 1000),\n            'volume': np.random.normal(1000, 100, 1000)\n        }, index=dates)\n        \n        # Ensure OHLC relationships are valid\n        for i in range(len(base_ohlcv_df)):\n            row = base_ohlcv_df.iloc[i]\n            base_ohlcv_df.loc[base_ohlcv_df.index[i], 'high'] = max(row['open'], row['close']) + abs(np.random.normal(0, 2))\n            base_ohlcv_df.loc[base_ohlcv_df.index[i], 'low'] = min(row['open'], row['close']) - abs(np.random.normal(0, 2))\n        \n        # Test scenarios combining OI and CVD patterns\n        scenarios = {\n            \"oi_bullish_cvd_confirmation\": {\n                \"description\": \"OI‚Üë + Price‚Üë + CVD‚Üë = Strong Bullish\",\n                \"oi_change_pct\": 0.08,\n                \"price_change_pct\": 0.05,\n                \"cvd_bias\": \"bullish\",  # More buy trades\n                \"expected_oi\": \"oi_scenario_1\",\n                \"expected_cvd\": \"cvd_bullish_confirmation\"\n            },\n            \"oi_bearish_cvd_divergence\": {\n                \"description\": \"OI‚Üì + Price‚Üë + CVD‚Üì = Bearish Divergence\",\n                \"oi_change_pct\": -0.06,\n                \"price_change_pct\": 0.04,\n                \"cvd_bias\": \"bearish\",  # More sell trades despite price up\n                \"expected_oi\": \"oi_scenario_2\",\n                \"expected_cvd\": \"cvd_bearish_divergence\"\n            },\n            \"oi_bearish_cvd_confirmation\": {\n                \"description\": \"OI‚Üë + Price‚Üì + CVD‚Üì = Strong Bearish\",\n                \"oi_change_pct\": 0.07,\n                \"price_change_pct\": -0.05,\n                \"cvd_bias\": \"bearish\",  # Sell pressure confirming downtrend\n                \"expected_oi\": \"oi_scenario_3\",\n                \"expected_cvd\": \"cvd_bearish_confirmation\"\n            },\n            \"oi_bullish_cvd_divergence\": {\n                \"description\": \"OI‚Üì + Price‚Üì + CVD‚Üë = Bullish Divergence\",\n                \"oi_change_pct\": -0.04,\n                \"price_change_pct\": -0.03,\n                \"cvd_bias\": \"bullish\",  # Buying despite falling price\n                \"expected_oi\": \"oi_scenario_4\",\n                \"expected_cvd\": \"cvd_bullish_divergence\"\n            },\n            \"threshold_sensitivity_test\": {\n                \"description\": \"Minimal changes (testing threshold sensitivity)\",\n                \"oi_change_pct\": 0.015,  # Just below old threshold (0.02%)\n                \"price_change_pct\": 0.008,  # Just below old threshold (0.01%)\n                \"cvd_bias\": \"neutral\",\n                \"expected_oi\": \"oi_neutral\",\n                \"expected_cvd\": None\n            },\n            \"cache_performance_test\": {\n                \"description\": \"Identical data (testing cache performance)\",\n                \"oi_change_pct\": 0.05,\n                \"price_change_pct\": 0.03,\n                \"cvd_bias\": \"bullish\",\n                \"expected_oi\": \"oi_scenario_1\",\n                \"expected_cvd\": \"cvd_bullish_confirmation\",\n                \"duplicate\": True  # Will be run multiple times to test caching\n            }\n        }\n        \n        test_data = {}\n        \n        for scenario_name, scenario in scenarios.items():\n            oi_change_pct = scenario[\"oi_change_pct\"]\n            price_change_pct = scenario[\"price_change_pct\"]\n            cvd_bias = scenario[\"cvd_bias\"]\n            \n            # Calculate actual values\n            current_oi = base_oi * (1 + oi_change_pct / 100)\n            previous_oi = base_oi\n            \n            # Adjust OHLCV to reflect price change\n            adjusted_ohlcv = base_ohlcv_df.copy()\n            price_multiplier = 1 + (price_change_pct / 100)\n            \n            # Adjust the last few candles to show the price change\n            last_close = adjusted_ohlcv['close'].iloc[-2]\n            new_close = last_close * price_multiplier\n            adjusted_ohlcv.loc[adjusted_ohlcv.index[-1], 'close'] = new_close\n            adjusted_ohlcv.loc[adjusted_ohlcv.index[-1], 'open'] = last_close\n            adjusted_ohlcv.loc[adjusted_ohlcv.index[-1], 'high'] = max(last_close, new_close) + 0.5\n            adjusted_ohlcv.loc[adjusted_ohlcv.index[-1], 'low'] = min(last_close, new_close) - 0.5\n            \n            # Create trades data with CVD bias\n            trades = []\n            total_trades = 150\n            \n            if cvd_bias == \"bullish\":\n                buy_ratio = 0.7  # 70% buy trades\n            elif cvd_bias == \"bearish\":\n                buy_ratio = 0.3  # 30% buy trades\n            else:\n                buy_ratio = 0.5  # 50% buy trades (neutral)\n            \n            for i in range(total_trades):\n                is_buy = np.random.random() < buy_ratio\n                side = \"Buy\" if is_buy else \"Sell\"\n                price = new_close + np.random.normal(0, 0.5)\n                size = np.random.uniform(0.01, 1.0)\n                \n                trades.append({\n                    'execId': f'trade_{i}',\n                    'symbol': 'ETHUSDT',\n                    'price': str(price),\n                    'size': str(size),\n                    'side': side,\n                    'time': str(current_time + i * 1000),\n                    'isBlockTrade': False,\n                    'isRPITrade': False\n                })\n            \n            test_data[scenario_name] = {\n                'symbol': 'ETHUSDT',\n                'exchange': 'bybit',\n                'timestamp': current_time,\n                \n                # Open interest data\n                'open_interest': {\n                    'current': current_oi,\n                    'previous': previous_oi,\n                    'timestamp': current_time\n                },\n                \n                # OHLCV data for price direction\n                'ohlcv': {\n                    'base': adjusted_ohlcv,\n                    'ltf': adjusted_ohlcv,\n                    'mtf': adjusted_ohlcv,\n                    'htf': adjusted_ohlcv\n                },\n                \n                # Ticker data\n                'ticker': {\n                    'symbol': 'ETHUSDT',\n                    'last': new_close,\n                    'openInterest': current_oi,\n                    'timestamp': current_time\n                },\n                \n                # Trades data with CVD bias\n                'trades': trades,\n                \n                # Orderbook data (minimal for validation)\n                'orderbook': {\n                    'bids': [[str(new_close - i * 0.1), str(100 + i * 10)] for i in range(25)],\n                    'asks': [[str(new_close + i * 0.1), str(100 + i * 10)] for i in range(25)],\n                    'timestamp': current_time\n                },\n                \n                # Add scenario info for testing\n                'test_scenario': scenario\n            }\n        \n        return test_data\n    \n    def test_complete_optimization(self, test_data: Dict[str, Dict[str, Any]]):\n        \"\"\"Test all optimizations working together.\"\"\"\n        \n        print(\"\\n\" + \"=\"*80)\n        print(\"COMPLETE ORDERFLOW OPTIMIZATION TEST\")\n        print(\"=\"*80)\n        \n        # Initialize orderflow indicators\n        orderflow = OrderflowIndicators(self.config, None)\n        \n        # Check current configuration\n        oi_config = self.config.get('analysis', {}).get('indicators', {}).get('orderflow', {}).get('open_interest', {})\n        cvd_config = self.config.get('analysis', {}).get('indicators', {}).get('orderflow', {}).get('cvd', {})\n        \n        print(f\"\\nConfiguration Verification:\")\n        print(f\"  OI minimal_change_threshold: {oi_config.get('minimal_change_threshold', 'NOT SET')}%\")\n        print(f\"  OI price_direction_threshold: {oi_config.get('price_direction_threshold', 'NOT SET')}%\")\n        print(f\"  CVD price_direction_threshold: {cvd_config.get('price_direction_threshold', 'NOT SET')}%\")\n        print(f\"  CVD cvd_significance_threshold: {cvd_config.get('cvd_significance_threshold', 'NOT SET')}%\")\n        \n        # Verify threshold alignment\n        oi_price_threshold = oi_config.get('price_direction_threshold', 0.1)\n        cvd_price_threshold = cvd_config.get('price_direction_threshold', 0.1)\n        \n        if oi_price_threshold == cvd_price_threshold:\n            print(f\"  ‚úÖ Thresholds aligned: {oi_price_threshold}%\")\n        else:\n            print(f\"  ‚ùå Thresholds misaligned: OI={oi_price_threshold}%, CVD={cvd_price_threshold}%\")\n        \n        results = {}\n        \n        # Test each scenario\n        for scenario_name, market_data in test_data.items():\n            scenario_info = market_data['test_scenario']\n            \n            print(f\"\\n{'-'*60}\")\n            print(f\"Testing: {scenario_name}\")\n            print(f\"Description: {scenario_info['description']}\")\n            \n            # Test cache performance by running identical data multiple times\n            if scenario_info.get('duplicate', False):\n                print(f\"Running cache performance test (3 iterations)...\")\n                for i in range(3):\n                    start_time = time.time()\n                    result = orderflow.calculate(market_data)\n                    execution_time = time.time() - start_time\n                    print(f\"  Iteration {i+1}: {execution_time:.4f}s\")\n            else:\n                # Single calculation\n                start_time = time.time()\n                result = orderflow.calculate(market_data)\n                execution_time = time.time() - start_time\n                \n                print(f\"Results:\")\n                print(f\"  Final Score: {result['score']:.2f}\")\n                print(f\"  Execution Time: {execution_time:.4f}s\")\n                print(f\"  Status: {result['metadata']['status']}\")\n                \n                # Component scores\n                components = result.get('components', {})\n                print(f\"  Component Scores:\")\n                print(f\"    OI Score: {components.get('open_interest_score', 'N/A'):.2f}\")\n                print(f\"    CVD Score: {components.get('cvd', 'N/A'):.2f}\")\n                print(f\"    Trade Flow: {components.get('trade_flow_score', 'N/A'):.2f}\")\n                print(f\"    Pressure: {components.get('pressure_score', 'N/A'):.2f}\")\n                \n                results[scenario_name] = {\n                    'score': result['score'],\n                    'execution_time': execution_time,\n                    'components': components,\n                    'success': result['metadata']['status'] == 'SUCCESS'\n                }\n        \n        # Performance summary\n        print(f\"\\n{'-'*60}\")\n        print(\"PERFORMANCE SUMMARY\")\n        print(f\"{'-'*60}\")\n        \n        total_tests = len([r for r in results.values() if r.get('success', False)])\n        avg_execution_time = np.mean([r['execution_time'] for r in results.values() if 'execution_time' in r])\n        \n        print(f\"Tests Completed: {total_tests}/{len(test_data)}\")\n        print(f\"Average Execution Time: {avg_execution_time:.4f}s\")\n        \n        # Debug stats summary\n        if hasattr(orderflow, '_debug_stats'):\n            debug_stats = orderflow._debug_stats\n            print(f\"\\nIntelligent Debug Statistics:\")\n            \n            # Calculation counts\n            calc_counts = debug_stats.get('calculation_counts', {})\n            if calc_counts:\n                print(f\"  Calculation Counts:\")\n                for component, count in calc_counts.items():\n                    print(f\"    {component}: {count}\")\n            \n            # Cache hits\n            cache_hits = debug_stats.get('cache_hits', {})\n            if cache_hits:\n                print(f\"  Cache Hits:\")\n                for component, hits in cache_hits.items():\n                    total_calcs = calc_counts.get(component, 0)\n                    hit_ratio = (hits / total_calcs * 100) if total_calcs > 0 else 0\n                    print(f\"    {component}: {hits}/{total_calcs} ({hit_ratio:.1f}%)\")\n            \n            # Scenario distribution\n            scenario_counts = debug_stats.get('scenario_counts', {})\n            if scenario_counts:\n                print(f\"  Scenario Distribution:\")\n                \n                # OI scenarios\n                oi_scenarios = {k: v for k, v in scenario_counts.items() if k.startswith('oi_')}\n                if oi_scenarios:\n                    total_oi = sum(oi_scenarios.values())\n                    print(f\"    Open Interest Scenarios (Total: {total_oi}):\")\n                    for scenario, count in oi_scenarios.items():\n                        percentage = (count / total_oi * 100) if total_oi > 0 else 0\n                        print(f\"      {scenario}: {count} ({percentage:.1f}%)\")\n                \n                # CVD scenarios\n                cvd_scenarios = {k: v for k, v in scenario_counts.items() if k.startswith('cvd_')}\n                if cvd_scenarios:\n                    total_cvd = sum(cvd_scenarios.values())\n                    print(f\"    CVD Scenarios (Total: {total_cvd}):\")\n                    for scenario, count in cvd_scenarios.items():\n                        percentage = (count / total_cvd * 100) if total_cvd > 0 else 0\n                        print(f\"      {scenario}: {count} ({percentage:.1f}%)\")\n        \n        # Final assessment\n        print(f\"\\n{'-'*60}\")\n        print(\"OPTIMIZATION ASSESSMENT\")\n        print(f\"{'-'*60}\")\n        \n        if total_tests == len(test_data):\n            print(\"üéâ ALL TESTS PASSED!\")\n            print(\"‚úÖ CVD threshold alignment: VERIFIED\")\n            print(\"‚úÖ Intelligent debug logging: ACTIVE\")\n            print(\"‚úÖ Scenario tracking: WORKING\")\n            print(\"‚úÖ Performance monitoring: ENABLED\")\n            print(\"‚úÖ Cache optimization: FUNCTIONAL\")\n        else:\n            print(\"‚ö†Ô∏è  Some tests failed. Review the results above.\")\n        \n        return results\n\nasync def main():\n    \"\"\"Run the complete optimization test.\"\"\"\n    print(\"Starting Complete Orderflow Optimization Test...\")\n    \n    test = CompleteOptimizationTest()\n    \n    # Create comprehensive test data\n    test_data = test.create_comprehensive_test_data()\n    \n    # Run the complete test\n    results = test.test_complete_optimization(test_data)\n    \n    print(\"\\nComplete optimization test finished.\")\n    return results\n\nif __name__ == \"__main__\":\n    asyncio.run(main()) 