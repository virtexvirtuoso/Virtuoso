{\rtf1\ansi\ansicpg1252\cocoartf2822
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\froman\fcharset0 Times-Bold;\f1\froman\fcharset0 Times-Roman;\f2\fmodern\fcharset0 Courier;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}}{\leveltext\leveltemplateid1\'01\'00;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid101\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid2}
{\list\listtemplateid3\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid201\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid3}
{\list\listtemplateid4\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid301\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid4}
{\list\listtemplateid5\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid401\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid5}
{\list\listtemplateid6\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid501\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid6}
{\list\listtemplateid7\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid601\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid7}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}{\listoverride\listid4\listoverridecount0\ls4}{\listoverride\listid5\listoverridecount0\ls5}{\listoverride\listid6\listoverridecount0\ls6}{\listoverride\listid7\listoverridecount0\ls7}}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sa298\partightenfactor0

\f0\b\fs36 \cf0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Implementation Strategy\
\pard\pardeftab720\sa240\partightenfactor0

\f1\b0\fs24 \cf0 The SFP implementation will follow your existing pattern:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240\partightenfactor0
\ls1\ilvl0\cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	1	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Add SFP to component weights and mapping\
\ls1\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	2	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Implement SFP detection logic with multi-timeframe analysis\
\ls1\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	3	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Integrate with your existing scoring system\
\ls1\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	4	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Add proper error handling and logging\
\pard\pardeftab720\sa240\partightenfactor0
\cf0 Here's the implementation:\
\pard\pardeftab720\partightenfactor0

\f2\fs26 \cf0 # ... existing code ...\
\
class PriceStructureIndicators(BaseIndicator):\
    """Price-based trading indicators that analyze market structure and price action.\
    \
    The Market Prism Concept - Price Structure Analysis Face:\
    Analyzes market structure and price action to identify key levels, trends, and potential \
    reversal points. This refers to market structure/price action, not actual trading positions.\
    \
    Note: This class has been refactored to consolidate redundant methods. The main entry point\
    for all price structure analysis is the `calculate` method, which provides comprehensive\
    analysis results including component scores, signals, and interpretation.\
    \
    Components and weights:\
    1. Support/Resistance levels (18%)\
       - Identifies key price levels where market has shown significant reaction\
       - Uses historical price action to map support and resistance zones\
       \
    2. Order blocks and supply/demand zones (18%)\
       - Maps significant supply and demand areas\
       - Identifies institutional order blocks using ICT methodology\
       - Tracks zone reaction strength and validity\
       \
    3. Trend position relative to key moving averages (18%)\
       - Analyzes price position relative to major MAs\
       - Tracks MA crossovers and alignments\
       - Measures trend strength and momentum\
       \
    4. Swing structure including swing points (18%)\
       - Tracks higher highs/lows or lower highs/lows\
       - Identifies swing points and pivots\
       - Analyzes structural breaks and continuations\
       \
    5. Swing Failure Patterns (SFP) (10%)\
       - Detects price breaks of key swing levels that fail to hold\
       - Identifies stop-hunt patterns and false breakouts\
       - Multi-timeframe validation for higher probability setups\
       \
    6. Fair Value Gaps (FVG) - Smart Money Concepts (8%)\
       - Detects price gaps that represent inefficient price delivery\
       - Tracks mitigation when price returns to fill gaps\
       - Acts as magnets for future price action\
       \
    7. Break of Structure (BOS) & Change of Character (CHoCH) (5%)\
       - BOS: Trend continuation when price breaks previous structure\
       - CHoCH: Potential reversal when market structure changes\
       - Enhanced market structure analysis using ICT concepts\
       \
    8. Composite Value Analysis (5%)\
       - Price position relative to moving averages\
       - Multi-factor value assessment\
       \
    Note: Volume Profile and VWAP analysis moved to volume_indicators.py\
    """\
\
    def __init__(self, config: Dict[str, Any], logger: Optional[Logger] = None):\
        """Initialize the PriceStructureIndicators with configuration."""\
        # Set indicator type BEFORE calling super().__init__\
        self.indicator_type = 'price_structure'\
        \
        # Store config for later use\
        self.config = config\
        \
        # Get price structure specific configuration\
        price_structure_config = config.get('analysis', \{\}).get('indicators', \{\}).get('price_structure', \{\})\
        \
        # Component mapping for consistent naming between internal and config names\
        self.component_mapping = \{\
            'support_resistance': 'support_resistance',\
            'order_blocks': 'order_block',\
            'trend_position': 'trend_position',\
            'swing_structure': 'swing_structure',\
            'swing_failure_patterns': 'swing_failure_patterns',  # Added SFP\
            'composite_value': 'composite_value',\
            'fair_value_gaps': 'fair_value_gaps',\
            'liquidity_zones': 'liquidity_zones',\
            'bos_choch': 'bos_choch'\
        \}\
        \
        # Get component weights from config BEFORE calling super().__init__\
        sub_component_weights = config.get('confluence', \{\}).get('weights', \{\}).get('sub_components', \{\}).get('price_structure', \{\})\
        \
        # Set component weights with defaults BEFORE calling super().__init__\
        # Updated to include SFP component with rebalanced weights\
        self.component_weights = \{\
            'support_resistance': sub_component_weights.get('support_resistance', 0.18),\
            'order_block': sub_component_weights.get('order_block', 0.18),\
            'trend_position': sub_component_weights.get('trend_position', 0.18),\
            'swing_structure': sub_component_weights.get('swing_structure', 0.18),\
            'swing_failure_patterns': sub_component_weights.get('swing_failure_patterns', 0.10),  # Added SFP\
            'composite_value': sub_component_weights.get('composite_value', 0.05),\
            'fair_value_gaps': sub_component_weights.get('fair_value_gaps', 0.08),\
            'bos_choch': sub_component_weights.get('bos_choch', 0.05)\
        \}\
        \
        # SFP-specific configuration\
        self.sfp_config = \{\
            'lookback_period': price_structure_config.get('sfp_lookback_period', 20),\
            'swing_detection_period': price_structure_config.get('sfp_swing_period', 5),\
            'min_wick_body_ratio': price_structure_config.get('sfp_min_wick_ratio', 1.5),\
            'volume_spike_threshold': price_structure_config.get('sfp_volume_threshold', 1.2),\
            'quality_filter': price_structure_config.get('sfp_quality_filter', True),\
            'multi_exchange_validation': price_structure_config.get('sfp_multi_exchange', False)\
        \}\
        \
        # ... rest of existing __init__ code ...\
\
    @debug_method(DebugLevel.DETAILED)\
    async def _calculate_component_scores(self, data: Dict[str, Any]) -> Dict[str, float]:\
        """Calculate individual scores for each position component."""\
        try:\
            if not self._validate_input(data):\
                raise ValueError("Invalid input data structure")\
\
            ohlcv_data = data['ohlcv']\
            scores = \{\}\
            \
            # ... existing component calculations ...\
            \
            # Add SFP calculation\
            try:\
                scores['swing_failure_patterns'] = self._calculate_sfp_score(ohlcv_data)\
                self.logger.debug(f"SFP score: \{scores['swing_failure_patterns']:.2f\}")\
            except Exception as e:\
                self.logger.warning(f"Error calculating swing_failure_patterns score: \{str(e)\}")\
                scores['swing_failure_patterns'] = 50.0\
            \
            # ... rest of existing component calculations ...\
            \
            return scores\
            \
        except Exception as e:\
            self.logger.error(f"Error calculating component scores: \{str(e)\}")\
            self.logger.error(traceback.format_exc())\
            # Return default scores for all components\
            return \{comp: 50.0 for comp in self.component_weights\}\
\
    def _calculate_sfp_score(self, ohlcv_data: Dict[str, pd.DataFrame]) -> float:\
        """\
        Calculate Swing Failure Pattern (SFP) score across multiple timeframes.\
        \
        SFP Definition (Hsaka Strategy):\
        - Price breaks a key swing high/low, triggers stops, but closes back inside the swing range\
        - Entry: On the close of the SFP candle\
        - Stop: Just above/below the SFP candle's high/low\
        - Higher score indicates more reversal potential\
        \
        Returns:\
            float: SFP score (0-100), where higher values indicate more SFP activity\
        """\
        try:\
            timeframe_scores = []\
            total_weight = 0\
            \
            for tf_name, df in ohlcv_data.items():\
                if df is None or df.empty or len(df) < self.sfp_config['lookback_period']:\
                    continue\
                    \
                # Get timeframe weight\
                weight = self.timeframe_weights.get(tf_name, 0.0)\
                if weight == 0:\
                    continue\
                \
                # Calculate SFP signals for this timeframe\
                sfp_signals = self._detect_sfps(df, tf_name)\
                \
                # Convert to score (0-100)\
                tf_score = self._score_sfp_signals(sfp_signals, df)\
                \
                timeframe_scores.append(tf_score * weight)\
                total_weight += weight\
                \
                self.logger.debug(f"SFP \{tf_name\}: \{len(sfp_signals)\} signals, score: \{tf_score:.2f\}")\
            \
            if total_weight == 0:\
                return 50.0\
            \
            # Weighted average across timeframes\
            weighted_score = sum(timeframe_scores) / total_weight\
            \
            # Normalize to 0-100 range\
            final_score = float(np.clip(weighted_score, 0, 100))\
            \
            self.logger.debug(f"Final SFP score: \{final_score:.2f\}")\
            return final_score\
            \
        except Exception as e:\
            self.logger.error(f"Error calculating SFP score: \{str(e)\}")\
            return 50.0\
\
    def _detect_sfps(self, df: pd.DataFrame, timeframe: str) -> List[Dict[str, Any]]:\
        """\
        Detect Swing Failure Patterns in price data.\
        \
        Args:\
            df: OHLCV DataFrame\
            timeframe: Timeframe name for logging\
            \
        Returns:\
            List of SFP signal dictionaries\
        """\
        try:\
            sfp_signals = []\
            lookback = self.sfp_config['lookback_period']\
            swing_period = self.sfp_config['swing_detection_period']\
            \
            # Need sufficient data for swing detection\
            if len(df) < lookback:\
                return sfp_signals\
            \
            # Calculate volume moving average for spike detection\
            df_work = df.copy()\
            df_work['volume_ma'] = df_work['volume'].rolling(window=10).mean()\
            \
            # Scan for SFP patterns\
            for i in range(swing_period, len(df_work) - 1):\
                current_candle = df_work.iloc[i]\
                \
                # Get recent swing levels (last N candles)\
                swing_window = df_work.iloc[max(0, i - swing_period):i]\
                recent_high = swing_window['high'].max()\
                recent_low = swing_window['low'].min()\
                \
                # Check for bullish SFP (failed breakdown)\
                bullish_sfp = self._check_bullish_sfp(\
                    current_candle, recent_low, df_work, i\
                )\
                if bullish_sfp:\
                    sfp_signals.append(bullish_sfp)\
                \
                # Check for bearish SFP (failed breakout)\
                bearish_sfp = self._check_bearish_sfp(\
                    current_candle, recent_high, df_work, i\
                )\
                if bearish_sfp:\
                    sfp_signals.append(bearish_sfp)\
            \
            return sfp_signals\
            \
        except Exception as e:\
            self.logger.error(f"Error detecting SFPs in \{timeframe\}: \{str(e)\}")\
            return []\
\
    def _check_bullish_sfp(self, candle: pd.Series, recent_low: float, \
                          df: pd.DataFrame, index: int) -> Optional[Dict[str, Any]]:\
        """\
        Check for bullish SFP pattern (failed breakdown below support).\
        \
        Pattern:\
        - Price breaks below recent swing low (triggers stops)\
        - But closes back above the swing low (failure)\
        - Indicates potential reversal higher\
        """\
        try:\
            # Must break below recent low but close above it\
            if candle['low'] < recent_low and candle['close'] > recent_low:\
                \
                # Quality filters if enabled\
                if self.sfp_config['quality_filter']:\
                    # Check wick-to-body ratio\
                    body_size = abs(candle['close'] - candle['open'])\
                    lower_wick = candle['open'] - candle['low'] if candle['close'] > candle['open'] else candle['close'] - candle['low']\
                    \
                    if body_size > 0:\
                        wick_ratio = lower_wick / body_size\
                        if wick_ratio < self.sfp_config['min_wick_body_ratio']:\
                            return None\
                    \
                    # Check volume spike\
                    if index > 10:  # Need history for volume MA\
                        volume_ma = df['volume_ma'].iloc[index]\
                        if volume_ma > 0:\
                            volume_ratio = candle['volume'] / volume_ma\
                            if volume_ratio < self.sfp_config['volume_spike_threshold']:\
                                return None\
                \
                return \{\
                    'type': 'bullish_sfp',\
                    'timestamp': candle.name,\
                    'price': candle['close'],\
                    'swing_level': recent_low,\
                    'low_break': candle['low'],\
                    'strength': self._calculate_sfp_strength(candle, recent_low, 'bullish'),\
                    'timeframe': df.index.freq if hasattr(df.index, 'freq') else 'unknown'\
                \}\
                \
        except Exception as e:\
            self.logger.error(f"Error checking bullish SFP: \{str(e)\}")\
            \
        return None\
\
    def _check_bearish_sfp(self, candle: pd.Series, recent_high: float, \
                          df: pd.DataFrame, index: int) -> Optional[Dict[str, Any]]:\
        """\
        Check for bearish SFP pattern (failed breakout above resistance).\
        \
        Pattern:\
        - Price breaks above recent swing high (triggers stops)\
        - But closes back below the swing high (failure)\
        - Indicates potential reversal lower\
        """\
        try:\
            # Must break above recent high but close below it\
            if candle['high'] > recent_high and candle['close'] < recent_high:\
                \
                # Quality filters if enabled\
                if self.sfp_config['quality_filter']:\
                    # Check wick-to-body ratio\
                    body_size = abs(candle['close'] - candle['open'])\
                    upper_wick = candle['high'] - candle['close'] if candle['close'] > candle['open'] else candle['high'] - candle['open']\
                    \
                    if body_size > 0:\
                        wick_ratio = upper_wick / body_size\
                        if wick_ratio < self.sfp_config['min_wick_body_ratio']:\
                            return None\
                    \
                    # Check volume spike\
                    if index > 10:  # Need history for volume MA\
                        volume_ma = df['volume_ma'].iloc[index]\
                        if volume_ma > 0:\
                            volume_ratio = candle['volume'] / volume_ma\
                            if volume_ratio < self.sfp_config['volume_spike_threshold']:\
                                return None\
                \
                return \{\
                    'type': 'bearish_sfp',\
                    'timestamp': candle.name,\
                    'price': candle['close'],\
                    'swing_level': recent_high,\
                    'high_break': candle['high'],\
                    'strength': self._calculate_sfp_strength(candle, recent_high, 'bearish'),\
                    'timeframe': df.index.freq if hasattr(df.index, 'freq') else 'unknown'\
                \}\
                \
        except Exception as e:\
            self.logger.error(f"Error checking bearish SFP: \{str(e)\}")\
            \
        return None\
\
    def _calculate_sfp_strength(self, candle: pd.Series, swing_level: float, \
                               sfp_type: str) -> float:\
        """\
        Calculate the strength of an SFP signal based on multiple factors.\
        \
        Args:\
            candle: The SFP candle\
            swing_level: The swing level that was broken\
            sfp_type: 'bullish' or 'bearish'\
            \
        Returns:\
            float: Strength score (0-1)\
        """\
        try:\
            strength_factors = []\
            \
            # Factor 1: Wick penetration distance\
            if sfp_type == 'bullish':\
                penetration = swing_level - candle['low']\
                rejection = candle['close'] - candle['low']\
            else:  # bearish\
                penetration = candle['high'] - swing_level\
                rejection = candle['high'] - candle['close']\
            \
            if penetration > 0:\
                rejection_ratio = rejection / penetration\
                strength_factors.append(min(rejection_ratio, 1.0))\
            \
            # Factor 2: Body size relative to range\
            candle_range = candle['high'] - candle['low']\
            body_size = abs(candle['close'] - candle['open'])\
            \
            if candle_range > 0:\
                body_ratio = body_size / candle_range\
                strength_factors.append(body_ratio)\
            \
            # Factor 3: Close position within candle range\
            if candle_range > 0:\
                if sfp_type == 'bullish':\
                    close_position = (candle['close'] - candle['low']) / candle_range\
                else:  # bearish\
                    close_position = (candle['high'] - candle['close']) / candle_range\
                strength_factors.append(close_position)\
            \
            # Average all factors\
            if strength_factors:\
                return sum(strength_factors) / len(strength_factors)\
            else:\
                return 0.5\
                \
        except Exception as e:\
            self.logger.error(f"Error calculating SFP strength: \{str(e)\}")\
            return 0.5\
\
    def _score_sfp_signals(self, sfp_signals: List[Dict[str, Any]], df: pd.DataFrame) -> float:\
        """\
        Convert SFP signals to a score (0-100).\
        \
        Args:\
            sfp_signals: List of detected SFP signals\
            df: Price data DataFrame\
            \
        Returns:\
            float: Score representing SFP activity level\
        """\
        try:\
            if not sfp_signals:\
                return 50.0  # Neutral when no signals\
            \
            # Base score on signal frequency and recency\
            total_signals = len(sfp_signals)\
            recent_signals = 0\
            strength_sum = 0\
            \
            # Weight recent signals more heavily\
            current_time = df.index[-1]\
            lookback_periods = len(df) // 4  # Last 25% of data\
            \
            for signal in sfp_signals:\
                signal_time = signal['timestamp']\
                strength = signal.get('strength', 0.5)\
                strength_sum += strength\
                \
                # Check if signal is recent\
                if hasattr(df.index, 'get_loc'):\
                    try:\
                        signal_idx = df.index.get_loc(signal_time)\
                        if signal_idx >= len(df) - lookback_periods:\
                            recent_signals += 1\
                    except KeyError:\
                        pass\
            \
            # Calculate base score\
            avg_strength = strength_sum / total_signals if total_signals > 0 else 0.5\
            \
            # Frequency score (more signals = higher reversal potential)\
            frequency_score = min(total_signals * 10, 40)  # Cap at 40 points\
            \
            # Recency score (recent signals more important)\
            recency_score = min(recent_signals * 15, 30)  # Cap at 30 points\
            \
            # Strength score\
            strength_score = avg_strength * 30  # Up to 30 points\
            \
            # Combine scores\
            final_score = 50 + frequency_score + recency_score + strength_score - 50\
            \
            return float(np.clip(final_score, 0, 100))\
            \
        except Exception as e:\
            self.logger.error(f"Error scoring SFP signals: \{str(e)\}")\
            return 50.0\
\
    # ... rest of existing methods ...\
\pard\pardeftab720\sa298\partightenfactor0

\f0\b\fs36 \cf0 Key Implementation Features:\
\pard\pardeftab720\sa280\partightenfactor0

\fs28 \cf0 1. Multi-Timeframe Analysis\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240\partightenfactor0
\ls2\ilvl0
\f1\b0\fs24 \cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Analyzes SFP patterns across all configured timeframes (1m, 5m, 30m, 4h)\
\ls2\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Applies timeframe weights to create composite score\
\ls2\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Higher timeframe SFPs carry more weight\
\pard\pardeftab720\sa280\partightenfactor0

\f0\b\fs28 \cf0 2. Quality Filtering\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240\partightenfactor0
\ls3\ilvl0
\fs24 \cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Wick-to-body ratio
\f1\b0 : Ensures significant rejection (default 1.5x)\
\ls3\ilvl0
\f0\b \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Volume spike detection
\f1\b0 : Confirms institutional involvement\
\ls3\ilvl0
\f0\b \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Configurable thresholds
\f1\b0 : Adjustable via configuration\
\pard\pardeftab720\sa280\partightenfactor0

\f0\b\fs28 \cf0 3. Pattern Detection Logic\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240\partightenfactor0
\ls4\ilvl0
\fs24 \cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Bullish SFP
\f1\b0 : Price breaks below swing low but closes above it\
\ls4\ilvl0
\f0\b \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Bearish SFP
\f1\b0 : Price breaks above swing high but closes below it\
\ls4\ilvl0
\f0\b \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Swing level identification
\f1\b0 : Uses recent N-period highs/lows\
\pard\pardeftab720\sa280\partightenfactor0

\f0\b\fs28 \cf0 4. Strength Calculation\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240\partightenfactor0
\ls5\ilvl0
\fs24 \cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Penetration distance
\f1\b0 : How far price broke the level\
\ls5\ilvl0
\f0\b \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Rejection strength
\f1\b0 : How much price recovered\
\ls5\ilvl0
\f0\b \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Body positioning
\f1\b0 : Where the close is within the candle range\
\pard\pardeftab720\sa280\partightenfactor0

\f0\b\fs28 \cf0 5. Scoring System\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240\partightenfactor0
\ls6\ilvl0
\fs24 \cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Frequency
\f1\b0 : More SFPs = higher reversal potential\
\ls6\ilvl0
\f0\b \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Recency
\f1\b0 : Recent signals weighted more heavily\
\ls6\ilvl0
\f0\b \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Strength
\f1\b0 : Average quality of detected patterns\
\ls6\ilvl0
\f0\b \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Normalized output
\f1\b0 : 0-100 scale integrated with existing system\
\pard\pardeftab720\sa280\partightenfactor0

\f0\b\fs28 \cf0 6. Configuration Options\
\pard\pardeftab720\partightenfactor0

\f2\b0\fs26 \cf0 analysis:\
  indicators:\
    price_structure:\
      sfp_lookback_period: 20        # Candles to scan\
      sfp_swing_period: 5            # Swing detection period\
      sfp_min_wick_ratio: 1.5        # Min wick-to-body ratio\
      sfp_volume_threshold: 1.2      # Volume spike threshold\
      sfp_quality_filter: true       # Enable quality filters\
      sfp_multi_exchange: false      # Multi-exchange validation\
\pard\pardeftab720\sa280\partightenfactor0

\f0\b\fs28 \cf0 7. Integration Benefits\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240\partightenfactor0
\ls7\ilvl0
\fs24 \cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Confluence scoring
\f1\b0 : SFP combines with other PSI components\
\ls7\ilvl0
\f0\b \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Signal generation
\f1\b0 : Can trigger alerts when SFP + other factors align\
\ls7\ilvl0
\f0\b \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Risk management
\f1\b0 : SFP levels provide natural stop-loss points\
\ls7\ilvl0
\f0\b \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Multi-timeframe context
\f1\b0 : Higher timeframe SFPs validate lower timeframe entries\
\pard\pardeftab720\sa240\partightenfactor0
\cf0 This implementation follows the Hsaka strategy principles while integrating seamlessly with your existing PriceStructureIndicators architecture. The SFP component adds valuable reversal detection capabilities that complement your existing swing structure and order block analysis.\
}